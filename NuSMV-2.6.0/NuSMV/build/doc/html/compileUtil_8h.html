<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NuSMV Developers Manual: /root/research/NuSMV-2.6.0/NuSMV/code/nusmv/core/compile/compileUtil.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NuSMV Developers Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_e650388f3f4ae1d8076907aea9dae3d3.html">nusmv</a></li><li class="navelem"><a class="el" href="dir_ccc42eeb4cd84d5168c1b8bab2dc74d3.html">core</a></li><li class="navelem"><a class="el" href="dir_d9eb3c68c735e7ea57feacad0cd66dff.html">compile</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">compileUtil.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="SymbTable_8h_source.html">nusmv/core/compile/symb_table/SymbTable.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="NuSMVEnv_8h_source.html">nusmv/core/cinit/NuSMVEnv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="NodeList_8h_source.html">nusmv/core/utils/NodeList.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="NodeMgr_8h_source.html">nusmv/core/node/NodeMgr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="node_8h_source.html">nusmv/core/node/node.h</a>&quot;</code><br />
</div>
<p><a href="compileUtil_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af516f9cd13fcd45d502c83f8cb857bbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="set_8h.html#a0beb5bfe44c73e9239f023bde8a305b2">Set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compileUtil_8h.html#af516f9cd13fcd45d502c83f8cb857bbd">Compile_make_sorted_vars_list_from_order</a> (const <a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a> st, const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> vars, const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> vars_order)</td></tr>
<tr class="memdesc:af516f9cd13fcd45d502c83f8cb857bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a new list of variables that will contain the same symbols into 'vars', but ordered wrt to 'vars_order' content.  <a href="#af516f9cd13fcd45d502c83f8cb857bbd">More...</a><br /></td></tr>
<tr class="separator:af516f9cd13fcd45d502c83f8cb857bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00ce7e50ea6257de4debe7d9f56c2df"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compileUtil_8h.html#ac00ce7e50ea6257de4debe7d9f56c2df">Compile_pop_distrib_ops</a> (const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a> env, node_ptr prop)</td></tr>
<tr class="memdesc:ac00ce7e50ea6257de4debe7d9f56c2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies the given property by exploiting the distributivity of G, AG and H over AND, and distributivity of F, AF and O over OR.  <a href="#ac00ce7e50ea6257de4debe7d9f56c2df">More...</a><br /></td></tr>
<tr class="separator:ac00ce7e50ea6257de4debe7d9f56c2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33b96e4db292b109d0e5b01f2ebc3a4"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compileUtil_8h.html#af33b96e4db292b109d0e5b01f2ebc3a4">Compile_remove_ltl_bop</a> (const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a> env, node_ptr prop)</td></tr>
<tr class="memdesc:af33b96e4db292b109d0e5b01f2ebc3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove bounded LTL temporal operators if any.  <a href="#af33b96e4db292b109d0e5b01f2ebc3a4">More...</a><br /></td></tr>
<tr class="separator:af33b96e4db292b109d0e5b01f2ebc3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456b2f6396a1465bc25fb3502a3b581b"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compileUtil_8h.html#a456b2f6396a1465bc25fb3502a3b581b">Compile_Util_symbol_from_expr</a> (<a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a> const env, node_ptr const var, const char *prefix, const char *suffix)</td></tr>
<tr class="memdesc:a456b2f6396a1465bc25fb3502a3b581b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility functions for compile.  <a href="#a456b2f6396a1465bc25fb3502a3b581b">More...</a><br /></td></tr>
<tr class="separator:a456b2f6396a1465bc25fb3502a3b581b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03becab1ddc8700a09cbc2cb75e077ef"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compileUtil_8h.html#a03becab1ddc8700a09cbc2cb75e077ef">sym_intern</a> (const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a> env, const char *)</td></tr>
<tr class="memdesc:a03becab1ddc8700a09cbc2cb75e077ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an internal representation for a given string.  <a href="#a03becab1ddc8700a09cbc2cb75e077ef">More...</a><br /></td></tr>
<tr class="separator:a03becab1ddc8700a09cbc2cb75e077ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71cf241b16476cc8117390bed1ccd88"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compileUtil_8h.html#af71cf241b16476cc8117390bed1ccd88">sym_intern_from_ustring</a> (const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a> env, const string_ptr _string)</td></tr>
<tr class="separator:af71cf241b16476cc8117390bed1ccd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213096b3051f27f73d23078776132ae2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compileUtil_8h.html#a213096b3051f27f73d23078776132ae2">sym_names_are_equal</a> (const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a> env, node_ptr name1, node_ptr name2)</td></tr>
<tr class="memdesc:a213096b3051f27f73d23078776132ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two names and returns true iff the names are equal.  <a href="#a213096b3051f27f73d23078776132ae2">More...</a><br /></td></tr>
<tr class="separator:a213096b3051f27f73d23078776132ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="af516f9cd13fcd45d502c83f8cb857bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af516f9cd13fcd45d502c83f8cb857bbd">&#9670;&nbsp;</a></span>Compile_make_sorted_vars_list_from_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="set_8h.html#a0beb5bfe44c73e9239f023bde8a305b2">Set_t</a> Compile_make_sorted_vars_list_from_order </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a>&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>vars_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates a new list of variables that will contain the same symbols into 'vars', but ordered wrt to 'vars_order' content. </p>
<p>This function can be used to construct an ordered list of symbols. The set of symbols is provided by the input list 'vars', whereas the ordering is provided by the 'vars_order' list, that can be an intersecting set over 'vars'. The resulting list will contain those symbols that occur in vars_order (respecting their order), plus all the symbols in vars that do not occur in vars_order, pushed at the end of the list. All duplicates (if any) will not occur into the resulting list. The returned set must be destroyed by the caller. </p>

</div>
</div>
<a id="ac00ce7e50ea6257de4debe7d9f56c2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00ce7e50ea6257de4debe7d9f56c2df">&#9670;&nbsp;</a></span>Compile_pop_distrib_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr Compile_pop_distrib_ops </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies the given property by exploiting the distributivity of G, AG and H over AND, and distributivity of F, AF and O over OR. </p>
<p>Transformation rules are: 1) &lt;OP&gt; &lt;OP&gt; a :-&gt; &lt;OP&gt; a 2) (&lt;OP&gt; a) * (&lt;OP&gt; b) :-&gt; &lt;OP&gt; (a * b); 3) (&lt;OP&gt; (a * &lt;OP&gt; b)) :-&gt; &lt;OP&gt; (a * b); 4) (&lt;OP&gt; (&lt;OP&gt; a * b)) :-&gt; &lt;OP&gt; (a * b); 5) (&lt;OP&gt; (&lt;OP&gt; a * &lt;OP&gt; b)) :-&gt; &lt;OP&gt; (a * b);</p>
<p>Where &lt;OP&gt; can be either: G|AG|H for * := &amp; F|AF|O for * := |</p>
<p>Given property can be both flattened or unflattened. </p>

</div>
</div>
<a id="af33b96e4db292b109d0e5b01f2ebc3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33b96e4db292b109d0e5b01f2ebc3a4">&#9670;&nbsp;</a></span>Compile_remove_ltl_bop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr Compile_remove_ltl_bop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove bounded LTL temporal operators if any. </p>
<p>Transformation rules are: 1) F [l, u] p :-&gt; X^l( p | X ( p | ... | X p)) 2) G [l, u] p :-&gt; X^l( p &amp; X ( p &amp; ... &amp; X p)) 3) O [l, u] p :-&gt; Y^l( p | Y ( p | ... | Y p)) 4) H [l, u] p :-&gt; Y^l( p &amp; Y ( p &amp; ... &amp; Y p))</p>
<p>Given property can be both flattened or unflattened. </p>

</div>
</div>
<a id="a456b2f6396a1465bc25fb3502a3b581b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456b2f6396a1465bc25fb3502a3b581b">&#9670;&nbsp;</a></span>Compile_Util_symbol_from_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr Compile_Util_symbol_from_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a> const&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr const&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility functions for compile. </p>
<dl class="section author"><dt>Author</dt><dd>Michele Dorigatti </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000452">Todo:</a></b></dt><dd>: Missing description</dd></dl>
<p>AutomaticStart</p>
<p>Given an expression, it creates a symbol which name is the concatenation of prefix, the expression itself as a string and suffix</p>
<p>The new symbol is find_noded. This function does not declare the symbol in a Symbol Table and does not check if it has been already declared. Passing empty strings as both prefix and suffix gives a symbol whose name is the expression itself. A possible improvement could be adding suitable defaults for prefix and suffix.</p>
<h6></h6>
<p>WARNING: This function is a draft, and has not be tested for every case.</p>
<p>In particular, newline characters (it should happen with CASE) in the string returned by sprint_node are not correctly handled.</p>
<h6></h6>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbTable.html#ada62a1701c82c6126ff7adb273ccde68" title="Given a prefix, returns a fresh symbol name. This function NEVER returns the same symbol twice and NE...">SymbTable_get_fresh_symbol_name</a>, for an alternative way to achieve a similar result </dd></dl>

</div>
</div>
<a id="a03becab1ddc8700a09cbc2cb75e077ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03becab1ddc8700a09cbc2cb75e077ef">&#9670;&nbsp;</a></span>sym_intern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr sym_intern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds an internal representation for a given string. </p>
<p>Builds an internal representation for a given string. If the conversion has been performed in the past, then the hashed value is returned back, else a new one is created, hashed and returned. We hash this in order to allow the following: </p><pre>
 VAR
 x : {a1, a2, a3};
 y : {a3, a4, a5};</pre><pre> ASSIGN
 next(x) := case
 x = y    : a2;
 !(x = y) : a1;
 1        : a3;
 esac;
 </pre><p> i.e. to allow the equality test between x and y. This can be performed because we internally have a unique representation of the atom <code>a3</code>.</p>
<p>ownership of char* is NOT taken</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="NodeMgr_8h.html#ab99fc7e08e0c912beb9a0d2b38d867ff">find_atom</a> </dd></dl>

</div>
</div>
<a id="af71cf241b16476cc8117390bed1ccd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71cf241b16476cc8117390bed1ccd88">&#9670;&nbsp;</a></span>sym_intern_from_ustring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr sym_intern_from_ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string_ptr&#160;</td>
          <td class="paramname"><em>_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like sym_intern, but taking a string_ptr instead of C string</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="compileUtil_8h.html#a03becab1ddc8700a09cbc2cb75e077ef" title="Builds an internal representation for a given string. ">sym_intern</a> </dd></dl>

</div>
</div>
<a id="a213096b3051f27f73d23078776132ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213096b3051f27f73d23078776132ae2">&#9670;&nbsp;</a></span>sym_names_are_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> sym_names_are_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>name2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two names and returns true iff the names are equal. </p>
<p>This can be applied only on names containing DOT and ATOM, and work well with both find-noded and new-noded nodes, even independently on the <a class="el" href="structNodeMgr.html" title="Definition of the public accessor for class NodeMgr. ">NodeMgr</a> the names were built with. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 18 2022 22:26:35 for NuSMV Developers Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
