<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NuSMV Developers Manual: BddEnc Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NuSMV Developers Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">BddEnc Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structBddEnc.html" title="BddEnc class definition derived from class BoolEncClient. ">BddEnc</a> class definition derived from class <a class="el" href="structBoolEncClient.html" title="Private and protected interface of class &#39;BoolEncClient&#39;. ">BoolEncClient</a>.  
 <a href="structBddEnc.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BddEnc__private_8h_source.html">BddEnc_private.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a578f13a9fd46cca72fa39285aec05489"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a578f13a9fd46cca72fa39285aec05489">INHERITS_FROM</a> (<a class="el" href="structBoolEncClient.html">BoolEncClient</a>)</td></tr>
<tr class="separator:a578f13a9fd46cca72fa39285aec05489"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a313a05867430cf470bf006c951ba621b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BddEncCache_8h.html#a6a2ed2878c6a7d38974ec6e634471c8a">BddEncCache_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a313a05867430cf470bf006c951ba621b">cache</a></td></tr>
<tr class="separator:a313a05867430cf470bf006c951ba621b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e331225af4a6cc7157a1414d44c7bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dd_8h.html#ac6ffa51d43f9f83f2507504d56d24d4c">dd_reorderingtype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a3e331225af4a6cc7157a1414d44c7bf0">curr_reord_type</a></td></tr>
<tr class="separator:a3e331225af4a6cc7157a1414d44c7bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad461e29954fb1ffd9d19199b77c63c4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ad461e29954fb1ffd9d19199b77c63c4b">curr_reorderings</a></td></tr>
<tr class="separator:ad461e29954fb1ffd9d19199b77c63c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17acf7ecb9633eacfaf490998c990c6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray__t.html">array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a17acf7ecb9633eacfaf490998c990c6d">current2next</a></td></tr>
<tr class="separator:a17acf7ecb9633eacfaf490998c990c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8fa268a3b7e10509f90aec7b897b2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DDMgr_8h.html#aaf9e5f2c269dadf9fa0c1ccea1680d78">DDMgr_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a9b8fa268a3b7e10509f90aec7b897b2e">dd</a></td></tr>
<tr class="separator:a9b8fa268a3b7e10509f90aec7b897b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82969ed73b3725761fc3d8af413f048"><td class="memItemLeft" align="right" valign="top"><a class="el" href="VarsHandler_8h.html#a7ec02b3199a5a626f08cf8edec989b7d">VarsHandler_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#af82969ed73b3725761fc3d8af413f048">dd_vars_hndr</a></td></tr>
<tr class="separator:af82969ed73b3725761fc3d8af413f048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895d4b3ceb0b23b9b7825d24761f6f82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a895d4b3ceb0b23b9b7825d24761f6f82">enforce_constant</a></td></tr>
<tr class="separator:a895d4b3ceb0b23b9b7825d24761f6f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d6d6aafa843ac3489362fccda10674"><td class="memItemLeft" align="right" valign="top">hash_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a59d6d6aafa843ac3489362fccda10674">failures_hash</a></td></tr>
<tr class="separator:a59d6d6aafa843ac3489362fccda10674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a7ebafc8385dfd898e859ac79ddf51"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ad5a7ebafc8385dfd898e859ac79ddf51">frozen_vars_add</a></td></tr>
<tr class="separator:ad5a7ebafc8385dfd898e859ac79ddf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7280952ce253ee54cc99a8cf104fa33b"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a7280952ce253ee54cc99a8cf104fa33b">frozen_vars_bdd</a></td></tr>
<tr class="separator:a7280952ce253ee54cc99a8cf104fa33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919f31681f1779c51b4f63bd8e4f98ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a919f31681f1779c51b4f63bd8e4f98ff">frozen_vars_num</a></td></tr>
<tr class="separator:a919f31681f1779c51b4f63bd8e4f98ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5545f11447fa011393e0d9004614a4ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray__t.html">array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a5545f11447fa011393e0d9004614a4ad">index2name</a></td></tr>
<tr class="separator:a5545f11447fa011393e0d9004614a4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d158061646f6aad64dc9c9bcb4b464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a29d158061646f6aad64dc9c9bcb4b464">index_gaps</a></td></tr>
<tr class="separator:a29d158061646f6aad64dc9c9bcb4b464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d9a3adaa3facc9ba2cc890a40e114a"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a65d9a3adaa3facc9ba2cc890a40e114a">input_vars_add</a></td></tr>
<tr class="separator:a65d9a3adaa3facc9ba2cc890a40e114a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee26275e9de3d61f871ed953b1ce2cb"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#acee26275e9de3d61f871ed953b1ce2cb">input_vars_bdd</a></td></tr>
<tr class="separator:acee26275e9de3d61f871ed953b1ce2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457423fd0f11bfd2c3abc1313947c255"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a457423fd0f11bfd2c3abc1313947c255">input_vars_mask_add</a></td></tr>
<tr class="separator:a457423fd0f11bfd2c3abc1313947c255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42b857c552009b3a0ae8e93f90db833"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ac42b857c552009b3a0ae8e93f90db833">input_vars_mask_bdd</a></td></tr>
<tr class="separator:ac42b857c552009b3a0ae8e93f90db833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc72e38d7539cdbf89c52e20d5f2f17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#acbc72e38d7539cdbf89c52e20d5f2f17">input_vars_num</a></td></tr>
<tr class="separator:acbc72e38d7539cdbf89c52e20d5f2f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2115dda0c8e8289f8cdaf008691136df"><td class="memItemLeft" align="right" valign="top">hash_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a2115dda0c8e8289f8cdaf008691136df">layer2groups</a></td></tr>
<tr class="separator:a2115dda0c8e8289f8cdaf008691136df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6b90098abe79f68dc7286dfe11edfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray__t.html">array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#aea6b90098abe79f68dc7286dfe11edfd">level2index</a></td></tr>
<tr class="separator:aea6b90098abe79f68dc7286dfe11edfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5283f92b78d25c9c5f9a28b05c81946"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray__t.html">array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ad5283f92b78d25c9c5f9a28b05c81946">minterm_frozen_vars</a></td></tr>
<tr class="separator:ad5283f92b78d25c9c5f9a28b05c81946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d25ba354540cb8c6e8ef256167f8611"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a5d25ba354540cb8c6e8ef256167f8611">minterm_frozen_vars_dim</a></td></tr>
<tr class="separator:a5d25ba354540cb8c6e8ef256167f8611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac10dd42dca378678c8c166d4358419"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray__t.html">array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#aaac10dd42dca378678c8c166d4358419">minterm_input_vars</a></td></tr>
<tr class="separator:aaac10dd42dca378678c8c166d4358419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b42be60e837ec24c026b35ab1749e50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a3b42be60e837ec24c026b35ab1749e50">minterm_input_vars_dim</a></td></tr>
<tr class="separator:a3b42be60e837ec24c026b35ab1749e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b5f85734c08ec4d9edd42bdd592a50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray__t.html">array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a37b5f85734c08ec4d9edd42bdd592a50">minterm_next_state_vars</a></td></tr>
<tr class="separator:a37b5f85734c08ec4d9edd42bdd592a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e8afa1dce163f4df42b4ec53d9e135"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a56e8afa1dce163f4df42b4ec53d9e135">minterm_next_state_vars_dim</a></td></tr>
<tr class="separator:a56e8afa1dce163f4df42b4ec53d9e135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02199bebb0a74af217fdae4a70b0b78a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray__t.html">array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a02199bebb0a74af217fdae4a70b0b78a">minterm_state_frozen_input_vars</a></td></tr>
<tr class="separator:a02199bebb0a74af217fdae4a70b0b78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d25a5630e38b591ef923f5c35f1c121"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a3d25a5630e38b591ef923f5c35f1c121">minterm_state_frozen_input_vars_dim</a></td></tr>
<tr class="separator:a3d25a5630e38b591ef923f5c35f1c121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a551deee94c8ab8fe7ca24154c5ea8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray__t.html">array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ad5a551deee94c8ab8fe7ca24154c5ea8">minterm_state_frozen_vars</a></td></tr>
<tr class="separator:ad5a551deee94c8ab8fe7ca24154c5ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac106b19e8be1402454d17c7af73c1b56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ac106b19e8be1402454d17c7af73c1b56">minterm_state_frozen_vars_dim</a></td></tr>
<tr class="separator:ac106b19e8be1402454d17c7af73c1b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1989afd79a4649cfb5ff6b30b4e941bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray__t.html">array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a1989afd79a4649cfb5ff6b30b4e941bd">minterm_state_vars</a></td></tr>
<tr class="separator:a1989afd79a4649cfb5ff6b30b4e941bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867c249a1d1b7fd7fef24bb4576d1eca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a867c249a1d1b7fd7fef24bb4576d1eca">minterm_state_vars_dim</a></td></tr>
<tr class="separator:a867c249a1d1b7fd7fef24bb4576d1eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80aff137ea64e89c50e45ac5ee76a316"><td class="memItemLeft" align="right" valign="top">hash_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a80aff137ea64e89c50e45ac5ee76a316">name2index</a></td></tr>
<tr class="separator:a80aff137ea64e89c50e45ac5ee76a316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027a9bea4538fd156e0f6cad80b69afc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray__t.html">array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a027a9bea4538fd156e0f6cad80b69afc">next2current</a></td></tr>
<tr class="separator:a027a9bea4538fd156e0f6cad80b69afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fd8b6ca28934242feb5fb61ec49c23"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#af2fd8b6ca28934242feb5fb61ec49c23">next_state_vars_add</a></td></tr>
<tr class="separator:af2fd8b6ca28934242feb5fb61ec49c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c08e863d81adebc68f38f9b88326b32"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a3c08e863d81adebc68f38f9b88326b32">next_state_vars_bdd</a></td></tr>
<tr class="separator:a3c08e863d81adebc68f38f9b88326b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2daa270d377b5c26569bffb4e5aa6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="OrdGroups_8h.html#a2b5af2202934a3d350e4be0a09bf0a02">OrdGroups_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a3a2daa270d377b5c26569bffb4e5aa6b">ord_groups</a></td></tr>
<tr class="separator:a3a2daa270d377b5c26569bffb4e5aa6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaecaf57f040e8c907d30dbc66d376d8"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#adaecaf57f040e8c907d30dbc66d376d8">print_stack</a></td></tr>
<tr class="separator:adaecaf57f040e8c907d30dbc66d376d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89df8bcf4d233590332641a09a71358"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ab89df8bcf4d233590332641a09a71358">reord_locked_num</a></td></tr>
<tr class="separator:ab89df8bcf4d233590332641a09a71358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93ef6475a9a40a808cd3b5383510318"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#af93ef6475a9a40a808cd3b5383510318">reord_status</a></td></tr>
<tr class="separator:af93ef6475a9a40a808cd3b5383510318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ff531a64b53413dda853a56bf51b6c"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a96ff531a64b53413dda853a56bf51b6c">state_frozen_input_vars_mask_add</a></td></tr>
<tr class="separator:a96ff531a64b53413dda853a56bf51b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7077615733bd43d6c507120bcef7c9"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#adf7077615733bd43d6c507120bcef7c9">state_frozen_input_vars_mask_bdd</a></td></tr>
<tr class="separator:adf7077615733bd43d6c507120bcef7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedee83a117bc6612ee64defba6f99d9"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#adedee83a117bc6612ee64defba6f99d9">state_frozen_vars_bdd</a></td></tr>
<tr class="separator:adedee83a117bc6612ee64defba6f99d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8967d46a12227a4f070691685e003f7d"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a8967d46a12227a4f070691685e003f7d">state_frozen_vars_mask_add</a></td></tr>
<tr class="separator:a8967d46a12227a4f070691685e003f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9c10d8d82fd4121c9eb43627904982"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a0a9c10d8d82fd4121c9eb43627904982">state_frozen_vars_mask_bdd</a></td></tr>
<tr class="separator:a0a9c10d8d82fd4121c9eb43627904982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e6e472dd7ee6f647ac7e00fe662cac"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a31e6e472dd7ee6f647ac7e00fe662cac">state_vars_add</a></td></tr>
<tr class="separator:a31e6e472dd7ee6f647ac7e00fe662cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9adf0b32a8b156ca43bc6c6e230cbec"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ac9adf0b32a8b156ca43bc6c6e230cbec">state_vars_bdd</a></td></tr>
<tr class="separator:ac9adf0b32a8b156ca43bc6c6e230cbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a91c45110b686c7c0543265a2ced2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a84a91c45110b686c7c0543265a2ced2e">state_vars_num</a></td></tr>
<tr class="separator:a84a91c45110b686c7c0543265a2ced2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549685e9470a559111f71007fab70e8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a549685e9470a559111f71007fab70e8b">type_checker</a></td></tr>
<tr class="separator:a549685e9470a559111f71007fab70e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022d4d99f5a5c31e393b465cf192f473"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a022d4d99f5a5c31e393b465cf192f473">used_indices_frontier</a></td></tr>
<tr class="separator:a022d4d99f5a5c31e393b465cf192f473"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ade12f053c44e784b43c54f0ed0d3a289"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ade12f053c44e784b43c54f0ed0d3a289">bdd_enc_deinit</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="separator:ade12f053c44e784b43c54f0ed0d3a289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab402dde3088e11e31da95637ef7ed022"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ab402dde3088e11e31da95637ef7ed022">bdd_enc_init</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, <a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a> symb_table, <a class="el" href="BoolEnc_8h.html#aa0e4c6a22ddb7ac20c5dc94254d859e9">BoolEnc_ptr</a> bool_enc, <a class="el" href="VarsHandler_8h.html#a7ec02b3199a5a626f08cf8edec989b7d">VarsHandler_ptr</a> dd_vars_hdlr, <a class="el" href="OrdGroups_8h.html#a2b5af2202934a3d350e4be0a09bf0a02">OrdGroups_ptr</a> <a class="el" href="structBddEnc.html#a3a2daa270d377b5c26569bffb4e5aa6b">ord_groups</a>)</td></tr>
<tr class="separator:ab402dde3088e11e31da95637ef7ed022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b033132888ab030c5db672405368f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ac8b033132888ab030c5db672405368f4">bdd_enc_shuffle_variables_order</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> vars)</td></tr>
<tr class="separator:ac8b033132888ab030c5db672405368f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0671de923f9e870ea227440595099fb4"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a0671de923f9e870ea227440595099fb4">BddEnc_add_to_expr</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, const add_ptr add, <a class="el" href="SymbLayer_8h.html#aefd4aad33d23e220d585b5736d6aaa90">SymbLayer_ptr</a> det_layer)</td></tr>
<tr class="memdesc:a0671de923f9e870ea227440595099fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a ADD into the corresponding (boolean) expression.  <a href="#a0671de923f9e870ea227440595099fb4">More...</a><br /></td></tr>
<tr class="separator:a0671de923f9e870ea227440595099fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78af61afb5301b56875967c85530e28b"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a78af61afb5301b56875967c85530e28b">BddEnc_add_to_scalar_expr</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, const add_ptr add, <a class="el" href="SymbLayer_8h.html#aefd4aad33d23e220d585b5736d6aaa90">SymbLayer_ptr</a> det_layer)</td></tr>
<tr class="memdesc:a78af61afb5301b56875967c85530e28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a ADD into the corresponding (possibly scalar) expression.  <a href="#a78af61afb5301b56875967c85530e28b">More...</a><br /></td></tr>
<tr class="separator:a78af61afb5301b56875967c85530e28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7f5d0757ce55aabc0c94cda58302f5"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a1f7f5d0757ce55aabc0c94cda58302f5">BddEnc_apply_input_vars_mask_add</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, add_ptr inputs)</td></tr>
<tr class="memdesc:a1f7f5d0757ce55aabc0c94cda58302f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a mask to the given add which must contain only input variables.  <a href="#a1f7f5d0757ce55aabc0c94cda58302f5">More...</a><br /></td></tr>
<tr class="separator:a1f7f5d0757ce55aabc0c94cda58302f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7fa43b37f79aa8e32633f027a03d76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#a27b39245a3288de2e162fdcf5f6edd54">BddInputs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a7f7fa43b37f79aa8e32633f027a03d76">BddEnc_apply_input_vars_mask_bdd</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#a27b39245a3288de2e162fdcf5f6edd54">BddInputs</a> inputs)</td></tr>
<tr class="memdesc:a7f7fa43b37f79aa8e32633f027a03d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a mask to the given BDD which must contain only input variables.  <a href="#a7f7fa43b37f79aa8e32633f027a03d76">More...</a><br /></td></tr>
<tr class="separator:a7f7fa43b37f79aa8e32633f027a03d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85cd57851c78906b9b9dc27cf5554ef"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#aa85cd57851c78906b9b9dc27cf5554ef">BddEnc_apply_state_frozen_input_vars_mask_add</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, add_ptr states_inputs)</td></tr>
<tr class="memdesc:aa85cd57851c78906b9b9dc27cf5554ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a mask to the given add which must contain frozen, state and input variables.  <a href="#aa85cd57851c78906b9b9dc27cf5554ef">More...</a><br /></td></tr>
<tr class="separator:aa85cd57851c78906b9b9dc27cf5554ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f158312614edc1f66b935bd74de23cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a7f158312614edc1f66b935bd74de23cb">BddEnc_apply_state_frozen_input_vars_mask_bdd</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a> states_inputs)</td></tr>
<tr class="memdesc:a7f158312614edc1f66b935bd74de23cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a mask to the given BDD which must contain frozen, state and input variables.  <a href="#a7f158312614edc1f66b935bd74de23cb">More...</a><br /></td></tr>
<tr class="separator:a7f158312614edc1f66b935bd74de23cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10cbe4f2c50eb1e1cfdafef11ef6e86"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ab10cbe4f2c50eb1e1cfdafef11ef6e86">BddEnc_apply_state_frozen_vars_mask_add</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, add_ptr states)</td></tr>
<tr class="memdesc:ab10cbe4f2c50eb1e1cfdafef11ef6e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a mask to the given add which must contain only frozen and state variables.  <a href="#ab10cbe4f2c50eb1e1cfdafef11ef6e86">More...</a><br /></td></tr>
<tr class="separator:ab10cbe4f2c50eb1e1cfdafef11ef6e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2da022883fe4e35e2508bbbb1c2ff41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ac2da022883fe4e35e2508bbbb1c2ff41">BddEnc_apply_state_frozen_vars_mask_bdd</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> states)</td></tr>
<tr class="memdesc:ac2da022883fe4e35e2508bbbb1c2ff41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a mask to the given BDD which must contain only frozen and state variables.  <a href="#ac2da022883fe4e35e2508bbbb1c2ff41">More...</a><br /></td></tr>
<tr class="separator:ac2da022883fe4e35e2508bbbb1c2ff41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb539a063b3a743a6618e0af0dd4dbb"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#aabb539a063b3a743a6618e0af0dd4dbb">BddEnc_assign_symbols</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr bdd, <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> symbols, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> onlyRequiredSymbs, bdd_ptr *resultBdd)</td></tr>
<tr class="memdesc:aabb539a063b3a743a6618e0af0dd4dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is similar to BddEnc_print_set_of... functions except that instead of printing values of variables, this funtion creates a list of pairs var-itsValue.  <a href="#aabb539a063b3a743a6618e0af0dd4dbb">More...</a><br /></td></tr>
<tr class="separator:aabb539a063b3a743a6618e0af0dd4dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843ac1cf473530d988e8da05cf98da71"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a843ac1cf473530d988e8da05cf98da71">BddEnc_bdd_to_expr</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, const bdd_ptr bdd)</td></tr>
<tr class="memdesc:a843ac1cf473530d988e8da05cf98da71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a BDD into the corresponding (boolean) expression.  <a href="#a843ac1cf473530d988e8da05cf98da71">More...</a><br /></td></tr>
<tr class="separator:a843ac1cf473530d988e8da05cf98da71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a29732e6d2193423266107aa1fdf77"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#aa8a29732e6d2193423266107aa1fdf77">BddEnc_bdd_to_wff</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr bdd, <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> vars)</td></tr>
<tr class="memdesc:aa8a29732e6d2193423266107aa1fdf77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a bdd into a Well Formed Formula representing it.  <a href="#aa8a29732e6d2193423266107aa1fdf77">More...</a><br /></td></tr>
<tr class="separator:aa8a29732e6d2193423266107aa1fdf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f1504c000a86ca7554d87a1a565852"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#af6f1504c000a86ca7554d87a1a565852">BddEnc_clean_evaluation_cache</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:af6f1504c000a86ca7554d87a1a565852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean the internal cache which contains the results of evaluation of expressions to ADD or BDD form.  <a href="#af6f1504c000a86ca7554d87a1a565852">More...</a><br /></td></tr>
<tr class="separator:af6f1504c000a86ca7554d87a1a565852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc78d975072ae08f20cb6a5a7d7db0b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray__t.html">array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#acc78d975072ae08f20cb6a5a7d7db0b8">BddEnc_ComputePrimeImplicants</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, const <a class="el" href="structarray__t.html">array_t</a> *layer_names, bdd_ptr formula)</td></tr>
<tr class="memdesc:acc78d975072ae08f20cb6a5a7d7db0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a set of prime implicants for a formula represented as a BDD.  <a href="#acc78d975072ae08f20cb6a5a7d7db0b8">More...</a><br /></td></tr>
<tr class="separator:acc78d975072ae08f20cb6a5a7d7db0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033b33f78929c4f75b3f067c5f89010d"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a033b33f78929c4f75b3f067c5f89010d">BddEnc_constant_to_add</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, node_ptr constant)</td></tr>
<tr class="memdesc:a033b33f78929c4f75b3f067c5f89010d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ADD leaf corresponding to the given atom.  <a href="#a033b33f78929c4f75b3f067c5f89010d">More...</a><br /></td></tr>
<tr class="separator:a033b33f78929c4f75b3f067c5f89010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e74bd16b646121af5be9d17ac24b77"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#af5e74bd16b646121af5be9d17ac24b77">BddEnc_count_inputs_of_bdd</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr bdd)</td></tr>
<tr class="memdesc:af5e74bd16b646121af5be9d17ac24b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of inputs of a given BDD.  <a href="#af5e74bd16b646121af5be9d17ac24b77">More...</a><br /></td></tr>
<tr class="separator:af5e74bd16b646121af5be9d17ac24b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6960fb5513c7dd4dc7bbcb7812b38f0c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a6960fb5513c7dd4dc7bbcb7812b38f0c">BddEnc_count_states_inputs_of_bdd</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr bdd)</td></tr>
<tr class="memdesc:a6960fb5513c7dd4dc7bbcb7812b38f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of states inputs of a given BDD.  <a href="#a6960fb5513c7dd4dc7bbcb7812b38f0c">More...</a><br /></td></tr>
<tr class="separator:a6960fb5513c7dd4dc7bbcb7812b38f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7ed2a9b3f7477379a1e964969469e9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a8b7ed2a9b3f7477379a1e964969469e9">BddEnc_count_states_of_add</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, add_ptr add)</td></tr>
<tr class="memdesc:a8b7ed2a9b3f7477379a1e964969469e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of states of a given ADD.  <a href="#a8b7ed2a9b3f7477379a1e964969469e9">More...</a><br /></td></tr>
<tr class="separator:a8b7ed2a9b3f7477379a1e964969469e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5265c13b40cbb7e2225354653e9b48"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#aae5265c13b40cbb7e2225354653e9b48">BddEnc_count_states_of_bdd</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr bdd)</td></tr>
<tr class="memdesc:aae5265c13b40cbb7e2225354653e9b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of states of a given BDD.  <a href="#aae5265c13b40cbb7e2225354653e9b48">More...</a><br /></td></tr>
<tr class="separator:aae5265c13b40cbb7e2225354653e9b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052105e4cf05127462ec8a05c289ed78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a052105e4cf05127462ec8a05c289ed78">BddEnc_create</a> (<a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a> symb_table, <a class="el" href="BoolEnc_8h.html#aa0e4c6a22ddb7ac20c5dc94254d859e9">BoolEnc_ptr</a> bool_enc, <a class="el" href="VarsHandler_8h.html#a7ec02b3199a5a626f08cf8edec989b7d">VarsHandler_ptr</a> <a class="el" href="structBddEnc.html#af82969ed73b3725761fc3d8af413f048">dd_vars_hndr</a>, <a class="el" href="OrdGroups_8h.html#a2b5af2202934a3d350e4be0a09bf0a02">OrdGroups_ptr</a> <a class="el" href="structBddEnc.html#a3a2daa270d377b5c26569bffb4e5aa6b">ord_groups</a>)</td></tr>
<tr class="memdesc:a052105e4cf05127462ec8a05c289ed78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structBddEnc.html" title="BddEnc class definition derived from class BoolEncClient. ">BddEnc</a> class constructor.  <a href="#a052105e4cf05127462ec8a05c289ed78">More...</a><br /></td></tr>
<tr class="separator:a052105e4cf05127462ec8a05c289ed78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7d6f019a0046e9d77c237fec1af092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="object_8h.html#a6dd04ec3fff7c731cc71d6796699d902">VIRTUAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a3d7d6f019a0046e9d77c237fec1af092">BddEnc_destroy</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:a3d7d6f019a0046e9d77c237fec1af092"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structBddEnc.html" title="BddEnc class definition derived from class BoolEncClient. ">BddEnc</a> class destructor.  <a href="#a3d7d6f019a0046e9d77c237fec1af092">More...</a><br /></td></tr>
<tr class="separator:a3d7d6f019a0046e9d77c237fec1af092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03de599446f6fc20066baca4b6829f2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a03de599446f6fc20066baca4b6829f2b">BddEnc_dump_addarray_davinci</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, <a class="el" href="AddArray_8h.html#a8a16776941b1dcd3374e6868ede6df30">AddArray_ptr</a> addarray, const char **labels, FILE *outfile)</td></tr>
<tr class="memdesc:a03de599446f6fc20066baca4b6829f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the given <a class="el" href="structAddArray.html" title="The header file of AddArray class. ">AddArray</a> in DAVINCI format.  <a href="#a03de599446f6fc20066baca4b6829f2b">More...</a><br /></td></tr>
<tr class="separator:a03de599446f6fc20066baca4b6829f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f012ca17d75296f2e2674b35215738"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ab0f012ca17d75296f2e2674b35215738">BddEnc_dump_addarray_dot</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, <a class="el" href="AddArray_8h.html#a8a16776941b1dcd3374e6868ede6df30">AddArray_ptr</a> addarray, const char **labels, FILE *outfile)</td></tr>
<tr class="memdesc:ab0f012ca17d75296f2e2674b35215738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the given <a class="el" href="structAddArray.html" title="The header file of AddArray class. ">AddArray</a> in DOT format.  <a href="#ab0f012ca17d75296f2e2674b35215738">More...</a><br /></td></tr>
<tr class="separator:ab0f012ca17d75296f2e2674b35215738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb9c9a116f458bd8e7c0d20fe19cf6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#affb9c9a116f458bd8e7c0d20fe19cf6e">BddEnc_dump_expr</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, const node_ptr parsed_expr, const char *str_constr, const <a class="el" href="BddEnc_8h.html#a919a813398bf83941c5e49bd79c8de4a">t_format</a> format, FILE *outfile)</td></tr>
<tr class="memdesc:affb9c9a116f458bd8e7c0d20fe19cf6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps an expression in the specified output format.  <a href="#affb9c9a116f458bd8e7c0d20fe19cf6e">More...</a><br /></td></tr>
<tr class="separator:affb9c9a116f458bd8e7c0d20fe19cf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d4a8b8b14abc613191c7b42ec5605b"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a61d4a8b8b14abc613191c7b42ec5605b">BddEnc_eval_constant</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, <a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a> expr, node_ptr context)</td></tr>
<tr class="memdesc:a61d4a8b8b14abc613191c7b42ec5605b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a constant expression.  <a href="#a61d4a8b8b14abc613191c7b42ec5605b">More...</a><br /></td></tr>
<tr class="separator:a61d4a8b8b14abc613191c7b42ec5605b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b58719af8e9801c3fbd1564b2c4b3a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a7b58719af8e9801c3fbd1564b2c4b3a5">BddEnc_eval_num</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, node_ptr e, node_ptr context)</td></tr>
<tr class="memdesc:a7b58719af8e9801c3fbd1564b2c4b3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a number in a context.  <a href="#a7b58719af8e9801c3fbd1564b2c4b3a5">More...</a><br /></td></tr>
<tr class="separator:a7b58719af8e9801c3fbd1564b2c4b3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bd182ebdb3c65efaaf91177a2cd5f7"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a09bd182ebdb3c65efaaf91177a2cd5f7">BddEnc_eval_sign_add</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, add_ptr a, int flag)</td></tr>
<tr class="memdesc:a09bd182ebdb3c65efaaf91177a2cd5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complements an ADD according to a flag.  <a href="#a09bd182ebdb3c65efaaf91177a2cd5f7">More...</a><br /></td></tr>
<tr class="separator:a09bd182ebdb3c65efaaf91177a2cd5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ef7418fd7e9897383623150385cf65"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ae7ef7418fd7e9897383623150385cf65">BddEnc_eval_sign_bdd</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr a, int flag)</td></tr>
<tr class="memdesc:ae7ef7418fd7e9897383623150385cf65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complements a BDD according to a flag.  <a href="#ae7ef7418fd7e9897383623150385cf65">More...</a><br /></td></tr>
<tr class="separator:ae7ef7418fd7e9897383623150385cf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f790309c63957b4f385db93063dca5"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a24f790309c63957b4f385db93063dca5">BddEnc_expr_to_add</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, const <a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a> expr, const node_ptr context)</td></tr>
<tr class="memdesc:a24f790309c63957b4f385db93063dca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ADD representing the expression expr, in the given context.  <a href="#a24f790309c63957b4f385db93063dca5">More...</a><br /></td></tr>
<tr class="separator:a24f790309c63957b4f385db93063dca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd21b1d7062274d3dc9d200518b00c46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AddArray_8h.html#a8a16776941b1dcd3374e6868ede6df30">AddArray_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#abd21b1d7062274d3dc9d200518b00c46">BddEnc_expr_to_addarray</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, const <a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a> expr, const node_ptr context)</td></tr>
<tr class="memdesc:abd21b1d7062274d3dc9d200518b00c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ADD array representing the expression expr, in the given context.  <a href="#abd21b1d7062274d3dc9d200518b00c46">More...</a><br /></td></tr>
<tr class="separator:abd21b1d7062274d3dc9d200518b00c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acb9d83c2ad48204a98433e64df7840"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a8acb9d83c2ad48204a98433e64df7840">BddEnc_expr_to_bdd</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, const <a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a> expr, const node_ptr context)</td></tr>
<tr class="memdesc:a8acb9d83c2ad48204a98433e64df7840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the BDD representing the expression expr, in the given contex.  <a href="#a8acb9d83c2ad48204a98433e64df7840">More...</a><br /></td></tr>
<tr class="separator:a8acb9d83c2ad48204a98433e64df7840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2583907e1ab6429416051b2d8143e74f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a2583907e1ab6429416051b2d8143e74f">BddEnc_force_order</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, <a class="el" href="OrdGroups_8h.html#a2b5af2202934a3d350e4be0a09bf0a02">OrdGroups_ptr</a> new_po_grps)</td></tr>
<tr class="memdesc:a2583907e1ab6429416051b2d8143e74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces a variable ordering in the BDD encoding.  <a href="#a2583907e1ab6429416051b2d8143e74f">More...</a><br /></td></tr>
<tr class="separator:a2583907e1ab6429416051b2d8143e74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83e4db814cd61725a0cdda461347539"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ae83e4db814cd61725a0cdda461347539">BddEnc_force_order_from_file</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, FILE *orderfile)</td></tr>
<tr class="memdesc:ae83e4db814cd61725a0cdda461347539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces a variable ordering in the BDD encoding reading it from a file.  <a href="#ae83e4db814cd61725a0cdda461347539">More...</a><br /></td></tr>
<tr class="separator:ae83e4db814cd61725a0cdda461347539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4e90958f6bf6fee2506041bafc5831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DDMgr_8h.html#aaf9e5f2c269dadf9fa0c1ccea1680d78">DDMgr_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a1d4e90958f6bf6fee2506041bafc5831">BddEnc_get_dd_manager</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:a1d4e90958f6bf6fee2506041bafc5831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the DD manager this encoding refers to.  <a href="#a1d4e90958f6bf6fee2506041bafc5831">More...</a><br /></td></tr>
<tr class="separator:a1d4e90958f6bf6fee2506041bafc5831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21c1b8f6058d3c031d26325736735a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="VarsHandler_8h.html#a7ec02b3199a5a626f08cf8edec989b7d">VarsHandler_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ab21c1b8f6058d3c031d26325736735a5">BddEnc_get_dd_vars_handler</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:ab21c1b8f6058d3c031d26325736735a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the DD vars handler this encoding refers to.  <a href="#ab21c1b8f6058d3c031d26325736735a5">More...</a><br /></td></tr>
<tr class="separator:ab21c1b8f6058d3c031d26325736735a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad3a1528b84e89fe578dd4370617c2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a1ad3a1528b84e89fe578dd4370617c2a">BddEnc_get_frozen_vars_cube</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:a1ad3a1528b84e89fe578dd4370617c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the support of the set of frozen variables.  <a href="#a1ad3a1528b84e89fe578dd4370617c2a">More...</a><br /></td></tr>
<tr class="separator:a1ad3a1528b84e89fe578dd4370617c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dd6aaa26b67105e8dee25087584139"><td class="memItemLeft" align="right" valign="top"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ab9dd6aaa26b67105e8dee25087584139">BddEnc_get_input_vars_cube</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:ab9dd6aaa26b67105e8dee25087584139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the support of the set of input variables.  <a href="#ab9dd6aaa26b67105e8dee25087584139">More...</a><br /></td></tr>
<tr class="separator:ab9dd6aaa26b67105e8dee25087584139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedca97ff054c7d72c3dd53337b495bd8"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#aedca97ff054c7d72c3dd53337b495bd8">BddEnc_get_input_vars_mask_add</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:aedca97ff054c7d72c3dd53337b495bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mask (as an ADD) in terms of input variables.  <a href="#aedca97ff054c7d72c3dd53337b495bd8">More...</a><br /></td></tr>
<tr class="separator:aedca97ff054c7d72c3dd53337b495bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24387a26b01778cbe9126a48af39ff22"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a24387a26b01778cbe9126a48af39ff22">BddEnc_get_input_vars_mask_bdd</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:a24387a26b01778cbe9126a48af39ff22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mask (as BDD) in terms of input variables.  <a href="#a24387a26b01778cbe9126a48af39ff22">More...</a><br /></td></tr>
<tr class="separator:a24387a26b01778cbe9126a48af39ff22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c48eb3561aad7cd481d40ad2ac9a935"><td class="memItemLeft" align="right" valign="top"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a8c48eb3561aad7cd481d40ad2ac9a935">BddEnc_get_layer_vars_cube</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, <a class="el" href="SymbLayer_8h.html#aefd4aad33d23e220d585b5736d6aaa90">SymbLayer_ptr</a> layer, <a class="el" href="SymbTable_8h.html#ab6f355273dfb298df3028c23c146d372">SymbFilterType</a> vt)</td></tr>
<tr class="memdesc:a8c48eb3561aad7cd481d40ad2ac9a935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a layer the function produces a cube of all layer's variables.  <a href="#a8c48eb3561aad7cd481d40ad2ac9a935">More...</a><br /></td></tr>
<tr class="separator:a8c48eb3561aad7cd481d40ad2ac9a935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f1c03fb0a1eebc320596bd93497ffc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a54f1c03fb0a1eebc320596bd93497ffc">BddEnc_get_minterms_of_add</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, add_ptr add)</td></tr>
<tr class="memdesc:a54f1c03fb0a1eebc320596bd93497ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of minterms of a given ADD.  <a href="#a54f1c03fb0a1eebc320596bd93497ffc">More...</a><br /></td></tr>
<tr class="separator:a54f1c03fb0a1eebc320596bd93497ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204816fbe8a07bfbac53a42b28707ab7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a204816fbe8a07bfbac53a42b28707ab7">BddEnc_get_minterms_of_bdd</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr bdd)</td></tr>
<tr class="memdesc:a204816fbe8a07bfbac53a42b28707ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of minterms of a given BDD.  <a href="#a204816fbe8a07bfbac53a42b28707ab7">More...</a><br /></td></tr>
<tr class="separator:a204816fbe8a07bfbac53a42b28707ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34dc08a3a0f7bde68c099a31b06570f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ae34dc08a3a0f7bde68c099a31b06570f">BddEnc_get_next_state_vars_cube</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:ae34dc08a3a0f7bde68c099a31b06570f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the support of the set of next-state variables.  <a href="#ae34dc08a3a0f7bde68c099a31b06570f">More...</a><br /></td></tr>
<tr class="separator:ae34dc08a3a0f7bde68c099a31b06570f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fb4cd7fa7d0b9e9b6a0a1013a580bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="OrdGroups_8h.html#a2b5af2202934a3d350e4be0a09bf0a02">OrdGroups_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ab0fb4cd7fa7d0b9e9b6a0a1013a580bc">BddEnc_get_ord_groups</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:ab0fb4cd7fa7d0b9e9b6a0a1013a580bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internally used order that was specified when creating the instance. Order is used when committing a layer and when forcing a reordering.  <a href="#ab0fb4cd7fa7d0b9e9b6a0a1013a580bc">More...</a><br /></td></tr>
<tr class="separator:ab0fb4cd7fa7d0b9e9b6a0a1013a580bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9383295a543ea442df1b6bb9b92ff5ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a9383295a543ea442df1b6bb9b92ff5ff">BddEnc_get_reordering_count</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:a9383295a543ea442df1b6bb9b92ff5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of reorderings that have been carried out since either the self construction or the last call to method reset_reordering_count.  <a href="#a9383295a543ea442df1b6bb9b92ff5ff">More...</a><br /></td></tr>
<tr class="separator:a9383295a543ea442df1b6bb9b92ff5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ef4777ec170a976cb40515e2ed4ff7"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ac9ef4777ec170a976cb40515e2ed4ff7">BddEnc_get_state_frozen_input_vars_mask_add</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:ac9ef4777ec170a976cb40515e2ed4ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mask (as ADD) in terms of state, frozen and input variables.  <a href="#ac9ef4777ec170a976cb40515e2ed4ff7">More...</a><br /></td></tr>
<tr class="separator:ac9ef4777ec170a976cb40515e2ed4ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264bc4f0ea44a7bbad43e4242d794f69"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a264bc4f0ea44a7bbad43e4242d794f69">BddEnc_get_state_frozen_input_vars_mask_bdd</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:a264bc4f0ea44a7bbad43e4242d794f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mask (as BDD) in terms of frozen, state and input variables.  <a href="#a264bc4f0ea44a7bbad43e4242d794f69">More...</a><br /></td></tr>
<tr class="separator:a264bc4f0ea44a7bbad43e4242d794f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8f0afa3d56deaca40670bd023bf6f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a1f8f0afa3d56deaca40670bd023bf6f1">BddEnc_get_state_frozen_vars_cube</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:a1f8f0afa3d56deaca40670bd023bf6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the support of the set of state and frozen variables.  <a href="#a1f8f0afa3d56deaca40670bd023bf6f1">More...</a><br /></td></tr>
<tr class="separator:a1f8f0afa3d56deaca40670bd023bf6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af903ee062365a11739e36dca2a376518"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#af903ee062365a11739e36dca2a376518">BddEnc_get_state_frozen_vars_mask_add</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:af903ee062365a11739e36dca2a376518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mask (as an ADD) in terms of frozen and state variables.  <a href="#af903ee062365a11739e36dca2a376518">More...</a><br /></td></tr>
<tr class="separator:af903ee062365a11739e36dca2a376518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db3ca49d8a214a5b8bdb44e527dbd7d"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a4db3ca49d8a214a5b8bdb44e527dbd7d">BddEnc_get_state_frozen_vars_mask_bdd</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:a4db3ca49d8a214a5b8bdb44e527dbd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mask (as BDD) in terms of frozen and state variables.  <a href="#a4db3ca49d8a214a5b8bdb44e527dbd7d">More...</a><br /></td></tr>
<tr class="separator:a4db3ca49d8a214a5b8bdb44e527dbd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c51795b6f7debae61fb85a2f5317dcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a7c51795b6f7debae61fb85a2f5317dcd">BddEnc_get_state_next_state_frozen_vars_cube</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:a7c51795b6f7debae61fb85a2f5317dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the support of the set of state, next state and frozen variables.  <a href="#a7c51795b6f7debae61fb85a2f5317dcd">More...</a><br /></td></tr>
<tr class="separator:a7c51795b6f7debae61fb85a2f5317dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa721e26ca641f3ee6baeace84dafb2dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#aa721e26ca641f3ee6baeace84dafb2dc">BddEnc_get_state_vars_cube</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:aa721e26ca641f3ee6baeace84dafb2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the support of the set of state variables.  <a href="#aa721e26ca641f3ee6baeace84dafb2dc">More...</a><br /></td></tr>
<tr class="separator:aa721e26ca641f3ee6baeace84dafb2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9aa20627a19634040e416a3c148b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AddArray_8h.html#a8a16776941b1dcd3374e6868ede6df30">AddArray_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#acf9aa20627a19634040e416a3c148b91">BddEnc_get_symbol_add</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, node_ptr name)</td></tr>
<tr class="memdesc:acf9aa20627a19634040e416a3c148b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a variable, define or process constant the corresponding ADD array is returned.  <a href="#acf9aa20627a19634040e416a3c148b91">More...</a><br /></td></tr>
<tr class="separator:acf9aa20627a19634040e416a3c148b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc74045d241eba610406e3e7484a2864"><td class="memItemLeft" align="right" valign="top"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#adc74045d241eba610406e3e7484a2864">BddEnc_get_unfiltered_vars_cube</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, <a class="el" href="set_8h.html#a0beb5bfe44c73e9239f023bde8a305b2">Set_t</a> vars)</td></tr>
<tr class="memdesc:adc74045d241eba610406e3e7484a2864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of variables the function produces a cube of all of them.  <a href="#adc74045d241eba610406e3e7484a2864">More...</a><br /></td></tr>
<tr class="separator:adc74045d241eba610406e3e7484a2864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af227e42db5704349dfef5d2a729e70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a2af227e42db5704349dfef5d2a729e70">BddEnc_get_var_index_from_name</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, node_ptr name)</td></tr>
<tr class="memdesc:a2af227e42db5704349dfef5d2a729e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the DD index of the given variable.  <a href="#a2af227e42db5704349dfef5d2a729e70">More...</a><br /></td></tr>
<tr class="separator:a2af227e42db5704349dfef5d2a729e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41f3bae02783f5454905c086616c0ff"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ac41f3bae02783f5454905c086616c0ff">BddEnc_get_var_mask</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, node_ptr var_name)</td></tr>
<tr class="memdesc:ac41f3bae02783f5454905c086616c0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a variable, it returns the mask of its encoding.  <a href="#ac41f3bae02783f5454905c086616c0ff">More...</a><br /></td></tr>
<tr class="separator:ac41f3bae02783f5454905c086616c0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855c1816f33e8fd57ec1a74c0e9c3792"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a855c1816f33e8fd57ec1a74c0e9c3792">BddEnc_get_var_name_from_index</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, int index)</td></tr>
<tr class="memdesc:a855c1816f33e8fd57ec1a74c0e9c3792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a variable index, this method return the symbolic name of the correpsonding variable.  <a href="#a855c1816f33e8fd57ec1a74c0e9c3792">More...</a><br /></td></tr>
<tr class="separator:a855c1816f33e8fd57ec1a74c0e9c3792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecaa54023ac95a0073c3772322b0722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a8ecaa54023ac95a0073c3772322b0722">BddEnc_get_var_ordering</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, const <a class="el" href="BddEnc_8h.html#afb098ed39f292e2400784f450ec1a30c">VarOrderingType</a> ord_type)</td></tr>
<tr class="separator:a8ecaa54023ac95a0073c3772322b0722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffc61a970b6d11d2d0ff75577e01d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#abffc61a970b6d11d2d0ff75577e01d91">BddEnc_get_vars_cube</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, <a class="el" href="set_8h.html#a0beb5bfe44c73e9239f023bde8a305b2">Set_t</a> vars, <a class="el" href="SymbTable_8h.html#ab6f355273dfb298df3028c23c146d372">SymbFilterType</a> vt)</td></tr>
<tr class="memdesc:abffc61a970b6d11d2d0ff75577e01d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of variables the function produces a cube of them filtering out some of them.  <a href="#abffc61a970b6d11d2d0ff75577e01d91">More...</a><br /></td></tr>
<tr class="separator:abffc61a970b6d11d2d0ff75577e01d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32c0065941fea32e683ddff51c786eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ad32c0065941fea32e683ddff51c786eb">BddEnc_get_vars_in_cube</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr cube, node_ptr list_of_sym, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> include_next)</td></tr>
<tr class="memdesc:ad32c0065941fea32e683ddff51c786eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the symbolic names of boolean variables stored in a cube.  <a href="#ad32c0065941fea32e683ddff51c786eb">More...</a><br /></td></tr>
<tr class="separator:ad32c0065941fea32e683ddff51c786eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb5dfad3e717bb17f684ed3bd5a37a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a0bb5dfad3e717bb17f684ed3bd5a37a7">BddEnc_has_var_at_index</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, int index)</td></tr>
<tr class="memdesc:a0bb5dfad3e717bb17f684ed3bd5a37a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a variable index, this method return true iff the given variable belongs to the encoder.  <a href="#a0bb5dfad3e717bb17f684ed3bd5a37a7">More...</a><br /></td></tr>
<tr class="separator:a0bb5dfad3e717bb17f684ed3bd5a37a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea47276e86f8c187a9d7bd50150e0d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#aeea47276e86f8c187a9d7bd50150e0d8">BddEnc_is_var_in_cube</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, node_ptr name, add_ptr cube)</td></tr>
<tr class="memdesc:aeea47276e86f8c187a9d7bd50150e0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the variable is in the cube and false otherwise.  <a href="#aeea47276e86f8c187a9d7bd50150e0d8">More...</a><br /></td></tr>
<tr class="separator:aeea47276e86f8c187a9d7bd50150e0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a7524c2d02660a2e28cc7c699b0ea6"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a09a7524c2d02660a2e28cc7c699b0ea6">BddEnc_next_state_var_to_state_var</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr bdd)</td></tr>
<tr class="memdesc:a09a7524c2d02660a2e28cc7c699b0ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange state variables for next state variables.  <a href="#a09a7524c2d02660a2e28cc7c699b0ea6">More...</a><br /></td></tr>
<tr class="separator:a09a7524c2d02660a2e28cc7c699b0ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422726b5778e4ded7e8ee07e9e83bad"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a3422726b5778e4ded7e8ee07e9e83bad">BddEnc_next_state_var_to_state_var_add</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, add_ptr add)</td></tr>
<tr class="memdesc:a3422726b5778e4ded7e8ee07e9e83bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange state variables for next state variables in terms of ADD.  <a href="#a3422726b5778e4ded7e8ee07e9e83bad">More...</a><br /></td></tr>
<tr class="separator:a3422726b5778e4ded7e8ee07e9e83bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2c44c8941d8e4078ab6884d10eeafd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a4f2c44c8941d8e4078ab6884d10eeafd">BddEnc_pick_all_terms_inputs</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr bdd, bdd_ptr *result_array, const int array_len)</td></tr>
<tr class="memdesc:a4f2c44c8941d8e4078ab6884d10eeafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the array of All Possible Minterms.  <a href="#a4f2c44c8941d8e4078ab6884d10eeafd">More...</a><br /></td></tr>
<tr class="separator:a4f2c44c8941d8e4078ab6884d10eeafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3382f091bb950b1c60d0f404a294a54c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a3382f091bb950b1c60d0f404a294a54c">BddEnc_pick_all_terms_states</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr bdd, bdd_ptr *result_array, const int array_len)</td></tr>
<tr class="memdesc:a3382f091bb950b1c60d0f404a294a54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the array of All Possible Minterms.  <a href="#a3382f091bb950b1c60d0f404a294a54c">More...</a><br /></td></tr>
<tr class="separator:a3382f091bb950b1c60d0f404a294a54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4cbd8e1a9dd1c1d7b9c7011ffbefee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a6b4cbd8e1a9dd1c1d7b9c7011ffbefee">BddEnc_pick_all_terms_states_inputs</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr bdd, bdd_ptr *result_array, const int array_len)</td></tr>
<tr class="memdesc:a6b4cbd8e1a9dd1c1d7b9c7011ffbefee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the array of All Possible Minterms.  <a href="#a6b4cbd8e1a9dd1c1d7b9c7011ffbefee">More...</a><br /></td></tr>
<tr class="separator:a6b4cbd8e1a9dd1c1d7b9c7011ffbefee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad34a5db9b23b3010c5c8bce5d0d0546"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#aad34a5db9b23b3010c5c8bce5d0d0546">BddEnc_pick_one_input</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr inputs)</td></tr>
<tr class="memdesc:aad34a5db9b23b3010c5c8bce5d0d0546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a minterm from a given BDD.  <a href="#aad34a5db9b23b3010c5c8bce5d0d0546">More...</a><br /></td></tr>
<tr class="separator:aad34a5db9b23b3010c5c8bce5d0d0546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ac29320b15f542fb5cd5aa5d24367f"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a30ac29320b15f542fb5cd5aa5d24367f">BddEnc_pick_one_input_rand</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr inputs)</td></tr>
<tr class="memdesc:a30ac29320b15f542fb5cd5aa5d24367f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a random minterm from a given BDD.  <a href="#a30ac29320b15f542fb5cd5aa5d24367f">More...</a><br /></td></tr>
<tr class="separator:a30ac29320b15f542fb5cd5aa5d24367f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0f03cec1d2378bb69b3f602b5d84e3"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a8c0f03cec1d2378bb69b3f602b5d84e3">BddEnc_pick_one_input_state</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr inputs_states)</td></tr>
<tr class="memdesc:a8c0f03cec1d2378bb69b3f602b5d84e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a minterm over input/state variables from a given BDD.  <a href="#a8c0f03cec1d2378bb69b3f602b5d84e3">More...</a><br /></td></tr>
<tr class="separator:a8c0f03cec1d2378bb69b3f602b5d84e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e7dee89ed1bc2bf62a67269b65776d"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ab1e7dee89ed1bc2bf62a67269b65776d">BddEnc_pick_one_input_state_rand</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr inputs_states)</td></tr>
<tr class="memdesc:ab1e7dee89ed1bc2bf62a67269b65776d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a random minterm from a given BDD.  <a href="#ab1e7dee89ed1bc2bf62a67269b65776d">More...</a><br /></td></tr>
<tr class="separator:ab1e7dee89ed1bc2bf62a67269b65776d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1f8f95d3a377cd52f4b770ccae6796"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a3e1f8f95d3a377cd52f4b770ccae6796">BddEnc_pick_one_state</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr states)</td></tr>
<tr class="memdesc:a3e1f8f95d3a377cd52f4b770ccae6796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a minterm from a given BDD.  <a href="#a3e1f8f95d3a377cd52f4b770ccae6796">More...</a><br /></td></tr>
<tr class="separator:a3e1f8f95d3a377cd52f4b770ccae6796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae171530fd5116e43af5c91b25ce1181d"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ae171530fd5116e43af5c91b25ce1181d">BddEnc_pick_one_state_rand</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr states)</td></tr>
<tr class="memdesc:ae171530fd5116e43af5c91b25ce1181d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a random minterm from a given BDD.  <a href="#ae171530fd5116e43af5c91b25ce1181d">More...</a><br /></td></tr>
<tr class="separator:ae171530fd5116e43af5c91b25ce1181d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ea6e6ad6d16663a80041cedabc98ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ae8ea6e6ad6d16663a80041cedabc98ab">BddEnc_print_bdd</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr bdd, <a class="el" href="BddEnc_8h.html#ac90aff45aec92ff20e75f82312622fb4">VPFBEFNNV</a> p_fun, <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a> file, void *arg)</td></tr>
<tr class="memdesc:ae8ea6e6ad6d16663a80041cedabc98ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the given bdd. In particular prints only the symbols occuring in the symbols list passed to print_bdd_begin. Individual assignments may be printed using a user-defined function, passed as a parameter.  <a href="#ae8ea6e6ad6d16663a80041cedabc98ab">More...</a><br /></td></tr>
<tr class="separator:ae8ea6e6ad6d16663a80041cedabc98ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568122bc13bd27462f44056253fa2a31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a568122bc13bd27462f44056253fa2a31">BddEnc_print_bdd_begin</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> symbols, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> changes_only)</td></tr>
<tr class="memdesc:a568122bc13bd27462f44056253fa2a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call before a group of BddEnc_print_bdd calls.  <a href="#a568122bc13bd27462f44056253fa2a31">More...</a><br /></td></tr>
<tr class="separator:a568122bc13bd27462f44056253fa2a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5373027239419c78e21ff28c0d0f525a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a5373027239419c78e21ff28c0d0f525a">BddEnc_print_bdd_end</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:a5373027239419c78e21ff28c0d0f525a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be called after each call to BddEnc_print_bdd_begin.  <a href="#a5373027239419c78e21ff28c0d0f525a">More...</a><br /></td></tr>
<tr class="separator:a5373027239419c78e21ff28c0d0f525a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2260240da06d255923d05313ec610dca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a2260240da06d255923d05313ec610dca">BddEnc_print_bdd_wff</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr bdd, <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> vars, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> do_sharing, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> do_indent, int start_at_column, <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a> out)</td></tr>
<tr class="memdesc:a2260240da06d255923d05313ec610dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a BDD as a Well Formed Formula using optional sharing.  <a href="#a2260240da06d255923d05313ec610dca">More...</a><br /></td></tr>
<tr class="separator:a2260240da06d255923d05313ec610dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a38861e56f851d41c14ba5ef63a3d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a71a38861e56f851d41c14ba5ef63a3d1">BddEnc_print_formula_info</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, <a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a> formula, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> print_models, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> print_formula, <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a> out)</td></tr>
<tr class="memdesc:a71a38861e56f851d41c14ba5ef63a3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints statistical information of a formula.  <a href="#a71a38861e56f851d41c14ba5ef63a3d1">More...</a><br /></td></tr>
<tr class="separator:a71a38861e56f851d41c14ba5ef63a3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74b52ee32796eb0ba33784718f37038"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ab74b52ee32796eb0ba33784718f37038">BddEnc_print_set_of_inputs</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr inputs, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> changes_only, <a class="el" href="BddEnc_8h.html#ac90aff45aec92ff20e75f82312622fb4">VPFBEFNNV</a> p_fun, <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a> file, void *arg)</td></tr>
<tr class="memdesc:ab74b52ee32796eb0ba33784718f37038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a set of input pairs. Individual assignments may be printed using a user-defined function, passed as a parameter.  <a href="#ab74b52ee32796eb0ba33784718f37038">More...</a><br /></td></tr>
<tr class="separator:ab74b52ee32796eb0ba33784718f37038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07bc5539ce7d89b130ea149a9246d44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ad07bc5539ce7d89b130ea149a9246d44">BddEnc_print_set_of_state_input_pairs</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr state_input_pairs, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> changes_only, <a class="el" href="BddEnc_8h.html#ac90aff45aec92ff20e75f82312622fb4">VPFBEFNNV</a> p_fun, <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a> file, void *arg)</td></tr>
<tr class="memdesc:ad07bc5539ce7d89b130ea149a9246d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a set of state-input pairs. Individual assignments may be printed using a user-defined function, passed as a parameter.  <a href="#ad07bc5539ce7d89b130ea149a9246d44">More...</a><br /></td></tr>
<tr class="separator:ad07bc5539ce7d89b130ea149a9246d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2548dcc8f8a4e83033145ad3dee88ed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a2548dcc8f8a4e83033145ad3dee88ed5">BddEnc_print_set_of_states</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr states, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> changes_only, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> print_defines, <a class="el" href="BddEnc_8h.html#ac90aff45aec92ff20e75f82312622fb4">VPFBEFNNV</a> p_fun, <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a> file, void *arg)</td></tr>
<tr class="memdesc:a2548dcc8f8a4e83033145ad3dee88ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a set of states. Individual assignments may be printed using a user-defined function, passed as a parameter.  <a href="#a2548dcc8f8a4e83033145ad3dee88ed5">More...</a><br /></td></tr>
<tr class="separator:a2548dcc8f8a4e83033145ad3dee88ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa342aab1e97ae72374b9f4ce599be1ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#aa342aab1e97ae72374b9f4ce599be1ef">BddEnc_print_set_of_trans_models</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr state_input_pairs, <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a> file)</td></tr>
<tr class="memdesc:aa342aab1e97ae72374b9f4ce599be1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a set of models for given trans.  <a href="#aa342aab1e97ae72374b9f4ce599be1ef">More...</a><br /></td></tr>
<tr class="separator:aa342aab1e97ae72374b9f4ce599be1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf0aaca7197e340dd1cb119a32e7eeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#abcf0aaca7197e340dd1cb119a32e7eeb">BddEnc_print_vars_in_cube</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr cube, node_ptr list_of_sym, <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a> file)</td></tr>
<tr class="memdesc:abcf0aaca7197e340dd1cb119a32e7eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints out the symbolic names of boolean variables stored in a cube.  <a href="#abcf0aaca7197e340dd1cb119a32e7eeb">More...</a><br /></td></tr>
<tr class="separator:abcf0aaca7197e340dd1cb119a32e7eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae725276a2d468d3275436372704e2ae2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ae725276a2d468d3275436372704e2ae2">BddEnc_reset_reordering_count</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self)</td></tr>
<tr class="memdesc:ae725276a2d468d3275436372704e2ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the reordering count. The value returned by any following call to method get_reordering_count will be relative to the moment this method had been called.  <a href="#ae725276a2d468d3275436372704e2ae2">More...</a><br /></td></tr>
<tr class="separator:ae725276a2d468d3275436372704e2ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13243721b673d51b30d6e57bcc443ea0"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a13243721b673d51b30d6e57bcc443ea0">BddEnc_state_var_to_next_state_var</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, bdd_ptr bdd)</td></tr>
<tr class="memdesc:a13243721b673d51b30d6e57bcc443ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange next state variables for state variables.  <a href="#a13243721b673d51b30d6e57bcc443ea0">More...</a><br /></td></tr>
<tr class="separator:a13243721b673d51b30d6e57bcc443ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ecde8eb69ad1b1707d36f304dcc875"><td class="memItemLeft" align="right" valign="top">add_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#a63ecde8eb69ad1b1707d36f304dcc875">BddEnc_state_var_to_next_state_var_add</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, add_ptr add)</td></tr>
<tr class="memdesc:a63ecde8eb69ad1b1707d36f304dcc875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange next state variables for state variables, in terms of ADD.  <a href="#a63ecde8eb69ad1b1707d36f304dcc875">More...</a><br /></td></tr>
<tr class="separator:a63ecde8eb69ad1b1707d36f304dcc875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7260ed890fcf49fc77b6c7a18b2a40f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddEnc.html#ad7260ed890fcf49fc77b6c7a18b2a40f">BddEnc_write_var_ordering</a> (const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> self, const char *oo_filename, const <a class="el" href="BddEnc_8h.html#afb098ed39f292e2400784f450ec1a30c">VarOrderingType</a> dump_type)</td></tr>
<tr class="memdesc:ad7260ed890fcf49fc77b6c7a18b2a40f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes on a file the variable order.  <a href="#ad7260ed890fcf49fc77b6c7a18b2a40f">More...</a><br /></td></tr>
<tr class="separator:ad7260ed890fcf49fc77b6c7a18b2a40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="structBddEnc.html" title="BddEnc class definition derived from class BoolEncClient. ">BddEnc</a> class definition derived from class <a class="el" href="structBoolEncClient.html" title="Private and protected interface of class &#39;BoolEncClient&#39;. ">BoolEncClient</a>. </p>
<p>Public interface of class '<a class="el" href="structBddEnc.html" title="BddEnc class definition derived from class BoolEncClient. ">BddEnc</a>'.</p>
<dl class="section see"><dt>See also</dt><dd>Base class <a class="el" href="structBoolEncClient.html" title="Private and protected interface of class &#39;BoolEncClient&#39;. ">BoolEncClient</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>Roberto Cavada Encoder for bdds, derived from class <a class="el" href="structBoolEncClient.html" title="Private and protected interface of class &#39;BoolEncClient&#39;. ">BoolEncClient</a></dd></dl>
<p>Definition of the public accessor for class <a class="el" href="structBddEnc.html" title="BddEnc class definition derived from class BoolEncClient. ">BddEnc</a> </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a578f13a9fd46cca72fa39285aec05489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578f13a9fd46cca72fa39285aec05489">&#9670;&nbsp;</a></span>INHERITS_FROM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BddEnc::INHERITS_FROM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBoolEncClient.html">BoolEncClient</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ade12f053c44e784b43c54f0ed0d3a289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade12f053c44e784b43c54f0ed0d3a289">&#9670;&nbsp;</a></span>bdd_enc_deinit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdd_enc_deinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000751">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="ab402dde3088e11e31da95637ef7ed022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab402dde3088e11e31da95637ef7ed022">&#9670;&nbsp;</a></span>bdd_enc_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdd_enc_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a>&#160;</td>
          <td class="paramname"><em>symb_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoolEnc_8h.html#aa0e4c6a22ddb7ac20c5dc94254d859e9">BoolEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>bool_enc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="VarsHandler_8h.html#a7ec02b3199a5a626f08cf8edec989b7d">VarsHandler_ptr</a>&#160;</td>
          <td class="paramname"><em>dd_vars_hdlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="OrdGroups_8h.html#a2b5af2202934a3d350e4be0a09bf0a02">OrdGroups_ptr</a>&#160;</td>
          <td class="paramname"><em>ord_groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000750">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="ac8b033132888ab030c5db672405368f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b033132888ab030c5db672405368f4">&#9670;&nbsp;</a></span>bdd_enc_shuffle_variables_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdd_enc_shuffle_variables_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000752">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a0671de923f9e870ea227440595099fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0671de923f9e870ea227440595099fb4">&#9670;&nbsp;</a></span>BddEnc_add_to_expr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr BddEnc_add_to_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const add_ptr&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SymbLayer_8h.html#aefd4aad33d23e220d585b5736d6aaa90">SymbLayer_ptr</a>&#160;</td>
          <td class="paramname"><em>det_layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a ADD into the corresponding (boolean) expression. </p>
<p>Takes an ADD with leaves FALSE, TRUE, or {FALSE,TRUE}.</p>
<p>The case of {FALSE,TRUE} leaves is determinized if a valid layer is passed, otherwise it is preserved.</p>
<p>Important: if a valid determinization layer is given, the layer cannot be alreay commited to the encoder, and will have to be possibly committed later if the returned expression is intended to be used by this encoder in terms of ADD or BDD.</p>
<p>Recurs down on the structure of the ADD, and maps each non terminal node into an if-then-else expression, maps FALSE and TRUE terminal nodes into true and false expressions, and maps {FALSE,TRUE} into a newly introduced variable to determinize the expression.</p>
<p>A new boolean variable can be declared within det_layer</p>
<dl class="section see"><dt>See also</dt><dd>bdd_enc_add2expr_recur </dd></dl>

</div>
</div>
<a id="a78af61afb5301b56875967c85530e28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78af61afb5301b56875967c85530e28b">&#9670;&nbsp;</a></span>BddEnc_add_to_scalar_expr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr BddEnc_add_to_scalar_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const add_ptr&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SymbLayer_8h.html#aefd4aad33d23e220d585b5736d6aaa90">SymbLayer_ptr</a>&#160;</td>
          <td class="paramname"><em>det_layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a ADD into the corresponding (possibly scalar) expression. </p>
<p>Takes an ADD and converts it to the corresponding scalar expression.</p>
<p>Non deterministic leaves will be determinized only if a valid layer is passed. Important: if a valid determinization layer is given, the layer cannot be alreay commited to the encoder, and will have to be possibly committed later if the returned expression is intended to be used by this encoder in terms of ADD or BDD.</p>
<p>Recurs down on the structure of the ADD, and maps each non terminal node into an if-then-else expression</p>
<p>A new scalar variable may be declared within det_layer</p>
<dl class="section see"><dt>See also</dt><dd>bdd_enc_add2expr_recur </dd></dl>

</div>
</div>
<a id="a1f7f5d0757ce55aabc0c94cda58302f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7f5d0757ce55aabc0c94cda58302f5">&#9670;&nbsp;</a></span>BddEnc_apply_input_vars_mask_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc_apply_input_vars_mask_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">add_ptr&#160;</td>
          <td class="paramname"><em>inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a mask to the given add which must contain only input variables. </p>
<p>Returned add is referenced. Calculated mask will be cached for future use. The mask will be applicable only to variable that occur within the layers committed to self </p>

</div>
</div>
<a id="a7f7fa43b37f79aa8e32633f027a03d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7fa43b37f79aa8e32633f027a03d76">&#9670;&nbsp;</a></span>BddEnc_apply_input_vars_mask_bdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#a27b39245a3288de2e162fdcf5f6edd54">BddInputs</a> BddEnc_apply_input_vars_mask_bdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#a27b39245a3288de2e162fdcf5f6edd54">BddInputs</a>&#160;</td>
          <td class="paramname"><em>inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a mask to the given BDD which must contain only input variables. </p>
<p>Returned bdd is referenced. Calculated mask will be cached for future use. The mask will be applicable only to variable that occur within the layers committed to self </p>

</div>
</div>
<a id="aa85cd57851c78906b9b9dc27cf5554ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85cd57851c78906b9b9dc27cf5554ef">&#9670;&nbsp;</a></span>BddEnc_apply_state_frozen_input_vars_mask_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc_apply_state_frozen_input_vars_mask_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">add_ptr&#160;</td>
          <td class="paramname"><em>states_inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a mask to the given add which must contain frozen, state and input variables. </p>
<p>Returned add is referenced. Calculated mask will be cached for future use. The mask will be applicable only to variable that occur within the layers committed to self </p>

</div>
</div>
<a id="a7f158312614edc1f66b935bd74de23cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f158312614edc1f66b935bd74de23cb">&#9670;&nbsp;</a></span>BddEnc_apply_state_frozen_input_vars_mask_bdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a> BddEnc_apply_state_frozen_input_vars_mask_bdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a>&#160;</td>
          <td class="paramname"><em>states_inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a mask to the given BDD which must contain frozen, state and input variables. </p>
<p>Returned bdd is referenced. Calculated mask will be cached for future use. The mask will be applicable only to variable that occur within the layers committed to self </p>

</div>
</div>
<a id="ab10cbe4f2c50eb1e1cfdafef11ef6e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10cbe4f2c50eb1e1cfdafef11ef6e86">&#9670;&nbsp;</a></span>BddEnc_apply_state_frozen_vars_mask_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc_apply_state_frozen_vars_mask_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">add_ptr&#160;</td>
          <td class="paramname"><em>states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a mask to the given add which must contain only frozen and state variables. </p>
<p>Returned add is referenced. Calculated mask will be cached for future use. The mask will be applicable only to variable that occur within the layers committed to self </p>

</div>
</div>
<a id="ac2da022883fe4e35e2508bbbb1c2ff41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2da022883fe4e35e2508bbbb1c2ff41">&#9670;&nbsp;</a></span>BddEnc_apply_state_frozen_vars_mask_bdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> BddEnc_apply_state_frozen_vars_mask_bdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td>
          <td class="paramname"><em>states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a mask to the given BDD which must contain only frozen and state variables. </p>
<p>Returned bdd is referenced. Calculated mask will be cached for future use. The mask will be applicable only to variable that occur within the layers committed to self </p>

</div>
</div>
<a id="aabb539a063b3a743a6618e0af0dd4dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb539a063b3a743a6618e0af0dd4dbb">&#9670;&nbsp;</a></span>BddEnc_assign_symbols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr BddEnc_assign_symbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>bdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>symbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>onlyRequiredSymbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr *&#160;</td>
          <td class="paramname"><em>resultBdd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is similar to BddEnc_print_set_of... functions except that instead of printing values of variables, this funtion creates a list of pairs var-itsValue. </p>
<p>This functions takes a BDD and a list of symbols (variables or defines, both can be wrapped in NEXT), and returns a list of (symb, symb_value) which makes BDD not false (input BDD) should not be false constant). Returned list is a list of AND nodes with Nil at the end. Every element is a EQUAL node with symbol on the left and its value on the right.</p>
<p>Order of symbols in the returned list is the same of provided symbols list. If parameter 'onlyRequiredSymbs' is true then symbols whose values are not constrained by provided BDD will be skipped. Otherwise, some legal arbitrary values for such symbols will be created and returned list will contain all the symbols from 'symbols'.</p>
<p>If parameter resultAssignment is not null pointer, then it returns the produced assignments in the form of BDD, i.e. a conjunct of all generated equations "symbol = itsValue".</p>
<p>The input BDD may or may not be a complete assignment. The invoker should free the returned list (with free_list) and returned BDD (if any). Note, that EQUAL nodes should not be freed/modified as created with find_node. </p>

</div>
</div>
<a id="a843ac1cf473530d988e8da05cf98da71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843ac1cf473530d988e8da05cf98da71">&#9670;&nbsp;</a></span>BddEnc_bdd_to_expr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr BddEnc_bdd_to_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_ptr&#160;</td>
          <td class="paramname"><em>bdd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a BDD into the corresponding (boolean) expression. </p>
<dl class="section see"><dt>See also</dt><dd>bdd_enc_add2expr_recur </dd></dl>

</div>
</div>
<a id="aa8a29732e6d2193423266107aa1fdf77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a29732e6d2193423266107aa1fdf77">&#9670;&nbsp;</a></span>BddEnc_bdd_to_wff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr BddEnc_bdd_to_wff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>bdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a bdd into a Well Formed Formula representing it. </p>
<p>A new expression is built, that represents the formula given as the input bdd.</p>
<p>The list of variables is used to compute the scalar essentials. Note that only the following kinds of variables are allowed in this list.</p>
<ol type="1">
<li>Pure booleans (i.e. not part of an encoding)</li>
<li>Finite scalars (both ranged and words).</li>
</ol>
<p>State, frozen and input variables are all allowed, no NEXT. (It will be part of this function's responsibility to add state variables' NEXTs as needed.</p>
<p>none</p>
<dl class="section see"><dt>See also</dt><dd>Bddenc_print_wff_bdd </dd></dl>

</div>
</div>
<a id="af6f1504c000a86ca7554d87a1a565852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f1504c000a86ca7554d87a1a565852">&#9670;&nbsp;</a></span>BddEnc_clean_evaluation_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddEnc_clean_evaluation_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean the internal cache which contains the results of evaluation of expressions to ADD or BDD form. </p>
<p>NB: NuSMV option "enable_sexp2bdd_caching" allows to disable the cache completely </p>

</div>
</div>
<a id="acc78d975072ae08f20cb6a5a7d7db0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc78d975072ae08f20cb6a5a7d7db0b8">&#9670;&nbsp;</a></span>BddEnc_ComputePrimeImplicants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray__t.html">array_t</a> * BddEnc_ComputePrimeImplicants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarray__t.html">array_t</a> *&#160;</td>
          <td class="paramname"><em>layer_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>formula</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a set of prime implicants for a formula represented as a BDD. </p>
<p>Finds the set of prime implicants of a BDD b. Each element of the resulting array is a prime implicant of the BDD b. The prime implicant is represented as a list of pairs</p>
<p>(: &lt;vname&gt; </p>
<p>)</p>
<p>The meaning is that the variable &lt;vname&gt; is equal to </p>
<p>, i.e. &lt;vname&gt; = </p>
<p>. A further post-process of the result can write it in a better way, expecially for non boolean variables, where several prime implicants can be combined by writing complex predicates instead of simple equalities.</p>
<p>The list of layers can be declared for instance as:</p>
<p>char ** layers = {MODEL_LAYER_NAME, "BA_ABSTRACTION", NULL};</p>
<p>Where MODEL_LAYER_NAME is the name of the model layer, "BA_ABSTRACTION" is the name of a new user created layer. Very inportant is the NULL at the end to terminate the list.</p>
<p>This function needs more comment</p>
<p>None </p>

</div>
</div>
<a id="a033b33f78929c4f75b3f067c5f89010d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033b33f78929c4f75b3f067c5f89010d">&#9670;&nbsp;</a></span>BddEnc_constant_to_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc_constant_to_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>constant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ADD leaf corresponding to the given atom. </p>
<p>Returns the ADD leaf corresponding to the given atom, if defined, NULL otherwise. The returned ADD - if any - is referenced. If the inner flag enforce_constant is set,</p>
<p>Suppose to have a declaration of this kind:<br />
 </p><pre>
 VAR
 condition : {idle, stopped}
 </pre><p> then in the constant hash for the atom <code>idle</code> there is the corresponding leaf ADD, i.e. the ADD whose value is the symbol <code>idle</code>. </p>

</div>
</div>
<a id="af5e74bd16b646121af5be9d17ac24b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e74bd16b646121af5be9d17ac24b77">&#9670;&nbsp;</a></span>BddEnc_count_inputs_of_bdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double BddEnc_count_inputs_of_bdd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>bdd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of inputs of a given BDD. </p>
<p>Return the number of inputs represented by a BDD. </p>

</div>
</div>
<a id="a6960fb5513c7dd4dc7bbcb7812b38f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6960fb5513c7dd4dc7bbcb7812b38f0c">&#9670;&nbsp;</a></span>BddEnc_count_states_inputs_of_bdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double BddEnc_count_states_inputs_of_bdd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>bdd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of states inputs of a given BDD. </p>
<p>Return the number of states inputs represented by a BDD. Note: states are represented by state and frozen variables </p>

</div>
</div>
<a id="a8b7ed2a9b3f7477379a1e964969469e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7ed2a9b3f7477379a1e964969469e9">&#9670;&nbsp;</a></span>BddEnc_count_states_of_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double BddEnc_count_states_of_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">add_ptr&#160;</td>
          <td class="paramname"><em>add</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of states of a given ADD. </p>
<p>Return the number of minterms (i.e. states) represented by an ADD. Note: states are represented by state and frozen variables </p>

</div>
</div>
<a id="aae5265c13b40cbb7e2225354653e9b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5265c13b40cbb7e2225354653e9b48">&#9670;&nbsp;</a></span>BddEnc_count_states_of_bdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double BddEnc_count_states_of_bdd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>bdd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of states of a given BDD. </p>
<p>Return the number of states represented by a BDD. Note: states are represented by state and frozen variables. </p>

</div>
</div>
<a id="a052105e4cf05127462ec8a05c289ed78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052105e4cf05127462ec8a05c289ed78">&#9670;&nbsp;</a></span>BddEnc_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> BddEnc_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a>&#160;</td>
          <td class="paramname"><em>symb_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoolEnc_8h.html#aa0e4c6a22ddb7ac20c5dc94254d859e9">BoolEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>bool_enc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="VarsHandler_8h.html#a7ec02b3199a5a626f08cf8edec989b7d">VarsHandler_ptr</a>&#160;</td>
          <td class="paramname"><em>dd_vars_hndr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="OrdGroups_8h.html#a2b5af2202934a3d350e4be0a09bf0a02">OrdGroups_ptr</a>&#160;</td>
          <td class="paramname"><em>ord_groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="structBddEnc.html" title="BddEnc class definition derived from class BoolEncClient. ">BddEnc</a> class constructor. </p>
<p>AutomaticStart</p>
<p>The <a class="el" href="structBddEnc.html" title="BddEnc class definition derived from class BoolEncClient. ">BddEnc</a> class constructor. ord_groups can be NULL if ordering is not used. self become the owner of the given ord_groups instance</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBddEnc.html#a3d7d6f019a0046e9d77c237fec1af092" title="The BddEnc class destructor. ">BddEnc_destroy</a> </dd></dl>

</div>
</div>
<a id="a3d7d6f019a0046e9d77c237fec1af092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7d6f019a0046e9d77c237fec1af092">&#9670;&nbsp;</a></span>BddEnc_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="object_8h.html#a6dd04ec3fff7c731cc71d6796699d902">VIRTUAL</a> void BddEnc_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="structBddEnc.html" title="BddEnc class definition derived from class BoolEncClient. ">BddEnc</a> class destructor. </p>
<p>The <a class="el" href="structBddEnc.html" title="BddEnc class definition derived from class BoolEncClient. ">BddEnc</a> class destructor</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBddEnc.html#a052105e4cf05127462ec8a05c289ed78" title="The BddEnc class constructor. ">BddEnc_create</a> </dd></dl>

</div>
</div>
<a id="a03de599446f6fc20066baca4b6829f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03de599446f6fc20066baca4b6829f2b">&#9670;&nbsp;</a></span>BddEnc_dump_addarray_davinci()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc_dump_addarray_davinci </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AddArray_8h.html#a8a16776941b1dcd3374e6868ede6df30">AddArray_ptr</a>&#160;</td>
          <td class="paramname"><em>addarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>outfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps the given <a class="el" href="structAddArray.html" title="The header file of AddArray class. ">AddArray</a> in DAVINCI format. </p>
<p>Labels is an array of strings to be used as roots labels. The size of the array must be equal to the size of the <a class="el" href="structAddArray.html" title="The header file of AddArray class. ">AddArray</a>. Returns 0 in case of success, 1 otherwise </p>

</div>
</div>
<a id="ab0f012ca17d75296f2e2674b35215738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f012ca17d75296f2e2674b35215738">&#9670;&nbsp;</a></span>BddEnc_dump_addarray_dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc_dump_addarray_dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AddArray_8h.html#a8a16776941b1dcd3374e6868ede6df30">AddArray_ptr</a>&#160;</td>
          <td class="paramname"><em>addarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>outfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps the given <a class="el" href="structAddArray.html" title="The header file of AddArray class. ">AddArray</a> in DOT format. </p>
<p>Labels is an array of strings to be used as roots labels. The size of the array must be equal to the size of the <a class="el" href="structAddArray.html" title="The header file of AddArray class. ">AddArray</a>. Returns 0 in case of success, 1 otherwise </p>

</div>
</div>
<a id="affb9c9a116f458bd8e7c0d20fe19cf6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb9c9a116f458bd8e7c0d20fe19cf6e">&#9670;&nbsp;</a></span>BddEnc_dump_expr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc_dump_expr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const node_ptr&#160;</td>
          <td class="paramname"><em>parsed_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str_constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a919a813398bf83941c5e49bd79c8de4a">t_format</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>outfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps an expression in the specified output format. </p>
<p>type check the expression, then convers to bdd and dumps </p>

</div>
</div>
<a id="a61d4a8b8b14abc613191c7b42ec5605b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d4a8b8b14abc613191c7b42ec5605b">&#9670;&nbsp;</a></span>BddEnc_eval_constant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc_eval_constant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates a constant expression. </p>
<p>Evaluate a constant expression. If the expression does not evaluate to a constant, then an internal error is generated. Returned add is referenced.</p>
<dl class="section see"><dt>See also</dt><dd>eval eval_num </dd></dl>

</div>
</div>
<a id="a7b58719af8e9801c3fbd1564b2c4b3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b58719af8e9801c3fbd1564b2c4b3a5">&#9670;&nbsp;</a></span>BddEnc_eval_num()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc_eval_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates a number in a context. </p>
<p>Evaluate the <em>NUMBER</em> represented by <code>e</code> in context <code>context</code>. <em>NUMBERS</em> can be encoded in different ways in different processes.</p>
<dl class="section see"><dt>See also</dt><dd>bdd_enc_eval </dd></dl>

</div>
</div>
<a id="a09bd182ebdb3c65efaaf91177a2cd5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09bd182ebdb3c65efaaf91177a2cd5f7">&#9670;&nbsp;</a></span>BddEnc_eval_sign_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc_eval_sign_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">add_ptr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complements an ADD according to a flag. </p>
<p>Given the ADD <code>a</code>, this function returns the negation of ADD <code>a</code> or <code>a</code> itself according the value of <code>flag</code>. If <code>flag = -1</code> then returns <code>not a</code>, else returns <code>a</code>. It is important that the ADD is a FALSE/TRUE ADD (i.e. it has only FALSE or TRUE as leaf).</p>
<dl class="section see"><dt>See also</dt><dd>bdd_enc_eval </dd></dl>

</div>
</div>
<a id="ae7ef7418fd7e9897383623150385cf65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ef7418fd7e9897383623150385cf65">&#9670;&nbsp;</a></span>BddEnc_eval_sign_bdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc_eval_sign_bdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complements a BDD according to a flag. </p>
<p>Given the BDD <code>a</code>, this function returns the negation of BDD <code>a</code> or <code>a</code> itself according the value of <code>flag</code>. If <code>flag = -1</code> then returns <code>not a</code>, else returns <code>a</code>. It is important that the BDD has only FALSE or TRUE as leaves. </p>

</div>
</div>
<a id="a24f790309c63957b4f385db93063dca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f790309c63957b4f385db93063dca5">&#9670;&nbsp;</a></span>BddEnc_expr_to_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc_expr_to_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const node_ptr&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ADD representing the expression expr, in the given context. </p>
<p>Returned add is referenced. A NULL value of the provided expression (expr) corresponds to a true ADD returned as result.</p>
<p>NOTE: Mostly expressions must be type checked before being evaluated. For example, use TypeChecker_is_expression_wellformed to type check generated expression. FSM should be checked with TypeCheckingPkg_check_constrains, and a property should be checked with TypeCheckingPkg_check_property </p>

</div>
</div>
<a id="abd21b1d7062274d3dc9d200518b00c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd21b1d7062274d3dc9d200518b00c46">&#9670;&nbsp;</a></span>BddEnc_expr_to_addarray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AddArray_8h.html#a8a16776941b1dcd3374e6868ede6df30">AddArray_ptr</a> BddEnc_expr_to_addarray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const node_ptr&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ADD array representing the expression expr, in the given context. </p>
<p>Each element of the returned add array is referenced. A NULL value of the provided expression (expr) corresponds to a true ADD array returned as result.</p>
<p>The returned array will belong to the invoker.</p>
<p>NOTE: Mostly expressions must be type checked before being evaluated. For example, use TypeChecker_is_expression_wellformed to type check generated expression. FSM should be checked with TypeCheckingPkg_check_constrains, and a property should be checked with TypeCheckingPkg_check_property </p>

</div>
</div>
<a id="a8acb9d83c2ad48204a98433e64df7840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8acb9d83c2ad48204a98433e64df7840">&#9670;&nbsp;</a></span>BddEnc_expr_to_bdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc_expr_to_bdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const node_ptr&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the BDD representing the expression expr, in the given contex. </p>
<p>Returned bdd is referenced.</p>
<p>NOTE: Mostly expressions must be type checked before being evaluated. For example, use TypeChecker_is_expression_wellformed to type check generated expression. FSM should be checked with TypeCheckingPkg_check_constrains, and a property should be checked with TypeCheckingPkg_check_property </p>

</div>
</div>
<a id="a2583907e1ab6429416051b2d8143e74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2583907e1ab6429416051b2d8143e74f">&#9670;&nbsp;</a></span>BddEnc_force_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddEnc_force_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="OrdGroups_8h.html#a2b5af2202934a3d350e4be0a09bf0a02">OrdGroups_ptr</a>&#160;</td>
          <td class="paramname"><em>new_po_grps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces a variable ordering in the BDD encoding. </p>
<p>It takes an <a class="el" href="structOrdGroups.html" title="Public interface of class OrdGroups. ">OrdGroups</a> structure representing the possibly partial ordering and the routine complete it with the possible missing variables. It is assumed all the variables in the given ordering group have been previously allocated within the BDD package. </p>

</div>
</div>
<a id="ae83e4db814cd61725a0cdda461347539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83e4db814cd61725a0cdda461347539">&#9670;&nbsp;</a></span>BddEnc_force_order_from_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddEnc_force_order_from_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>orderfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces a variable ordering in the BDD encoding reading it from a file. </p>
<p>It reads an order file and then forces it within the BDD package. The order file may be partial. Thanks to <code>BddEnc_force_order</code> the ordering is completed with the possible missing variables.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBddEnc.html#a2583907e1ab6429416051b2d8143e74f" title="Forces a variable ordering in the BDD encoding. ">BddEnc_force_order</a> </dd></dl>

</div>
</div>
<a id="a1d4e90958f6bf6fee2506041bafc5831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4e90958f6bf6fee2506041bafc5831">&#9670;&nbsp;</a></span>BddEnc_get_dd_manager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DDMgr_8h.html#aaf9e5f2c269dadf9fa0c1ccea1680d78">DDMgr_ptr</a> BddEnc_get_dd_manager </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the DD manager this encoding refers to. </p>
<p>Gets the DD manager this encoding refers to. </p>

</div>
</div>
<a id="ab21c1b8f6058d3c031d26325736735a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21c1b8f6058d3c031d26325736735a5">&#9670;&nbsp;</a></span>BddEnc_get_dd_vars_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="VarsHandler_8h.html#a7ec02b3199a5a626f08cf8edec989b7d">VarsHandler_ptr</a> BddEnc_get_dd_vars_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the DD vars handler this encoding refers to. </p>
<p>Gets the DD vars handler this encoding refers to. </p>

</div>
</div>
<a id="a1ad3a1528b84e89fe578dd4370617c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad3a1528b84e89fe578dd4370617c2a">&#9670;&nbsp;</a></span>BddEnc_get_frozen_vars_cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a> BddEnc_get_frozen_vars_cube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the support of the set of frozen variables. </p>
<p>Returned bdd is referenced, the caller must free it after it is no longer used. Result is cached if not previously converted from internal ADD representation. Returns NULL if an error occurred. </p>

</div>
</div>
<a id="ab9dd6aaa26b67105e8dee25087584139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dd6aaa26b67105e8dee25087584139">&#9670;&nbsp;</a></span>BddEnc_get_input_vars_cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a> BddEnc_get_input_vars_cube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the support of the set of input variables. </p>
<p>Returned bdd is referenced, the caller must free it after it is no longer used. Result is cached if not previously converted from internal ADD representation. Returns NULL if an error occurred. </p>

</div>
</div>
<a id="aedca97ff054c7d72c3dd53337b495bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedca97ff054c7d72c3dd53337b495bd8">&#9670;&nbsp;</a></span>BddEnc_get_input_vars_mask_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc_get_input_vars_mask_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mask (as an ADD) in terms of input variables. </p>
<p>Returned add is referenced. Calculated mask will be cached for future use. The mask will be applicable only to variable that occur within the layers committed to self </p>

</div>
</div>
<a id="a24387a26b01778cbe9126a48af39ff22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24387a26b01778cbe9126a48af39ff22">&#9670;&nbsp;</a></span>BddEnc_get_input_vars_mask_bdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc_get_input_vars_mask_bdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mask (as BDD) in terms of input variables. </p>
<p>Returned bdd is referenced. Calculated mask will be cached for future use. The mask will be applicable only to variable that occur within the layers committed to self </p>

</div>
</div>
<a id="a8c48eb3561aad7cd481d40ad2ac9a935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c48eb3561aad7cd481d40ad2ac9a935">&#9670;&nbsp;</a></span>BddEnc_get_layer_vars_cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a> BddEnc_get_layer_vars_cube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SymbLayer_8h.html#aefd4aad33d23e220d585b5736d6aaa90">SymbLayer_ptr</a>&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SymbTable_8h.html#ab6f355273dfb298df3028c23c146d372">SymbFilterType</a>&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a layer the function produces a cube of all layer's variables. </p>
<p>vt can be a combination of VFT_CURRENT, VFT_NEXT, VFT_FROZEN, VFT_INPUT (see SymbFilterType for combination shortcuts). Returned bdd is referenced, the caller must free it after it is no longer used. </p>

</div>
</div>
<a id="a54f1c03fb0a1eebc320596bd93497ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f1c03fb0a1eebc320596bd93497ffc">&#9670;&nbsp;</a></span>BddEnc_get_minterms_of_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double BddEnc_get_minterms_of_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">add_ptr&#160;</td>
          <td class="paramname"><em>add</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of minterms of a given ADD. </p>
<p>Return the number of minterms represented by a ADD. </p>

</div>
</div>
<a id="a204816fbe8a07bfbac53a42b28707ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204816fbe8a07bfbac53a42b28707ab7">&#9670;&nbsp;</a></span>BddEnc_get_minterms_of_bdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double BddEnc_get_minterms_of_bdd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>bdd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of minterms of a given BDD. </p>
<p>Return the number of minterms represented by a BDD. </p>

</div>
</div>
<a id="ae34dc08a3a0f7bde68c099a31b06570f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34dc08a3a0f7bde68c099a31b06570f">&#9670;&nbsp;</a></span>BddEnc_get_next_state_vars_cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a> BddEnc_get_next_state_vars_cube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the support of the set of next-state variables. </p>
<p>Returned bdd is referenced, the caller must free it after it is no longer used. Result is cached if not previously converted from internal ADD representation. Returns NULL if an error occurred. </p>

</div>
</div>
<a id="ab0fb4cd7fa7d0b9e9b6a0a1013a580bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0fb4cd7fa7d0b9e9b6a0a1013a580bc">&#9670;&nbsp;</a></span>BddEnc_get_ord_groups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="OrdGroups_8h.html#a2b5af2202934a3d350e4be0a09bf0a02">OrdGroups_ptr</a> BddEnc_get_ord_groups </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internally used order that was specified when creating the instance. Order is used when committing a layer and when forcing a reordering. </p>
<p>Can be NULL. The returned instance belongs to self. Do not change it if you do not know well what you are doing. </p>

</div>
</div>
<a id="a9383295a543ea442df1b6bb9b92ff5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9383295a543ea442df1b6bb9b92ff5ff">&#9670;&nbsp;</a></span>BddEnc_get_reordering_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc_get_reordering_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of reorderings that have been carried out since either the self construction or the last call to method reset_reordering_count. </p>
<p>Returns the number of reorderings performed by CUDD since the instance creation, or since the last call to method reset_reordering_count. Explicit and auto-triggered reorderings are counted. Notice that forced ordering due to layers commitment may increment the orderings count.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBddEnc.html#ae725276a2d468d3275436372704e2ae2" title="Resets the reordering count. The value returned by any following call to method get_reordering_count ...">BddEnc_reset_reordering_count</a> </dd></dl>

</div>
</div>
<a id="ac9ef4777ec170a976cb40515e2ed4ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ef4777ec170a976cb40515e2ed4ff7">&#9670;&nbsp;</a></span>BddEnc_get_state_frozen_input_vars_mask_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc_get_state_frozen_input_vars_mask_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mask (as ADD) in terms of state, frozen and input variables. </p>
<p>Returned add is referenced. Calculated mask will be cached for future use. The mask will be applicable only to variable that occur within the layers committed to self </p>

</div>
</div>
<a id="a264bc4f0ea44a7bbad43e4242d794f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264bc4f0ea44a7bbad43e4242d794f69">&#9670;&nbsp;</a></span>BddEnc_get_state_frozen_input_vars_mask_bdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc_get_state_frozen_input_vars_mask_bdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mask (as BDD) in terms of frozen, state and input variables. </p>
<p>Returned bdd is referenced. Calculated mask will be cached for future use. The mask will be applicable only to variable that occur within the layers committed to self </p>

</div>
</div>
<a id="a1f8f0afa3d56deaca40670bd023bf6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8f0afa3d56deaca40670bd023bf6f1">&#9670;&nbsp;</a></span>BddEnc_get_state_frozen_vars_cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a> BddEnc_get_state_frozen_vars_cube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the support of the set of state and frozen variables. </p>
<p>The result is a conjunct of BddEnc_get_state_vars_cube and BddEnc_get_frozen_vars_cube.</p>
<p>Returned bdd is referenced, the caller must free it after it is no longer used. Result is cached if not previously converted from internal ADD representation. Returns NULL if an error occurred. </p>

</div>
</div>
<a id="af903ee062365a11739e36dca2a376518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af903ee062365a11739e36dca2a376518">&#9670;&nbsp;</a></span>BddEnc_get_state_frozen_vars_mask_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc_get_state_frozen_vars_mask_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mask (as an ADD) in terms of frozen and state variables. </p>
<p>Returned add is referenced. Calculated mask will be cached for future use. The mask will be applicable only to variable that occur within the layers committed to self </p>

</div>
</div>
<a id="a4db3ca49d8a214a5b8bdb44e527dbd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db3ca49d8a214a5b8bdb44e527dbd7d">&#9670;&nbsp;</a></span>BddEnc_get_state_frozen_vars_mask_bdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc_get_state_frozen_vars_mask_bdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mask (as BDD) in terms of frozen and state variables. </p>
<p>Returned bdd is referenced. Calculated mask will be cached for future use. The mask will be applicable only to variable that occur within the layers committed to self </p>

</div>
</div>
<a id="a7c51795b6f7debae61fb85a2f5317dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c51795b6f7debae61fb85a2f5317dcd">&#9670;&nbsp;</a></span>BddEnc_get_state_next_state_frozen_vars_cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a> BddEnc_get_state_next_state_frozen_vars_cube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the support of the set of state, next state and frozen variables. </p>
<p>The result is a conjunction of BddEnc_get_state_frozen_vars_cube and BddEnc_get_next_state_vars_cube.</p>
<p>Returned bdd is referenced, the caller must free it after it is no longer used. Returns NULL if an error occurred. </p>

</div>
</div>
<a id="aa721e26ca641f3ee6baeace84dafb2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa721e26ca641f3ee6baeace84dafb2dc">&#9670;&nbsp;</a></span>BddEnc_get_state_vars_cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a> BddEnc_get_state_vars_cube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the support of the set of state variables. </p>
<p>Returned bdd is referenced, the caller must free it after it is no longer used. Result is cached if not previously converted from internal ADD representation. Returns NULL if an error occurred. </p>

</div>
</div>
<a id="acf9aa20627a19634040e416a3c148b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9aa20627a19634040e416a3c148b91">&#9670;&nbsp;</a></span>BddEnc_get_symbol_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AddArray_8h.html#a8a16776941b1dcd3374e6868ede6df30">AddArray_ptr</a> BddEnc_get_symbol_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a variable, define or process constant the corresponding ADD array is returned. </p>
<p>Given an identifier (as an expanded identifier <code>name</code>), this function returns the ADD array of its definition, or NULL if not defined. If the variable is of a Word type then the returned array may contain several elements (ADDs). For all other kinds of expressions only one element can be in the array. Errors occurs if the identifier is a define which is circularly declared. The returned array will belong to the invoker.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBddEnc.html#a24f790309c63957b4f385db93063dca5" title="Returns the ADD representing the expression expr, in the given context. ">BddEnc_expr_to_add</a> </dd></dl>

</div>
</div>
<a id="adc74045d241eba610406e3e7484a2864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc74045d241eba610406e3e7484a2864">&#9670;&nbsp;</a></span>BddEnc_get_unfiltered_vars_cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a> BddEnc_get_unfiltered_vars_cube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="set_8h.html#a0beb5bfe44c73e9239f023bde8a305b2">Set_t</a>&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a set of variables the function produces a cube of all of them. </p>
<p>this function is similar to BddEnc_get_vars_cube with 2 differences:</p><ol type="1">
<li>all variables in 'vars' are put into the result cube</li>
<li>in order to compute next-state variable bits of variable V 'vars' has to contain <a class="el" href="lsort_8h.html#a2be29dbf95b4a2c822f307a5b8141184">NEXT(V)</a>.</li>
</ol>
<p>Returned bdd is referenced, the caller must free it after it is no longer used. </p>

</div>
</div>
<a id="a2af227e42db5704349dfef5d2a729e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af227e42db5704349dfef5d2a729e70">&#9670;&nbsp;</a></span>BddEnc_get_var_index_from_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc_get_var_index_from_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the DD index of the given variable. </p>
<p>The input variable should be boolean</p>
<p>required</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBddEnc.html#a855c1816f33e8fd57ec1a74c0e9c3792" title="Given a variable index, this method return the symbolic name of the correpsonding variable...">BddEnc_get_var_name_from_index</a> </dd></dl>

</div>
</div>
<a id="ac41f3bae02783f5454905c086616c0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41f3bae02783f5454905c086616c0ff">&#9670;&nbsp;</a></span>BddEnc_get_var_mask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc_get_var_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>var_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a variable, it returns the mask of its encoding. </p>
<p>Returns the mask that removes repetitions of leaves in a variable encoding. Returned ADD is referenced. Automatic reordering, if enabled, is temporary disabled during this computation. </p>

</div>
</div>
<a id="a855c1816f33e8fd57ec1a74c0e9c3792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855c1816f33e8fd57ec1a74c0e9c3792">&#9670;&nbsp;</a></span>BddEnc_get_var_name_from_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr BddEnc_get_var_name_from_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a variable index, this method return the symbolic name of the correpsonding variable. </p>
<p>required</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBddEnc.html#a2af227e42db5704349dfef5d2a729e70" title="Returns the DD index of the given variable. ">BddEnc_get_var_index_from_name</a> </dd></dl>

</div>
</div>
<a id="a8ecaa54023ac95a0073c3772322b0722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecaa54023ac95a0073c3772322b0722">&#9670;&nbsp;</a></span>BddEnc_get_var_ordering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> BddEnc_get_var_ordering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#afb098ed39f292e2400784f450ec1a30c">VarOrderingType</a>&#160;</td>
          <td class="paramname"><em>ord_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000747">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="abffc61a970b6d11d2d0ff75577e01d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffc61a970b6d11d2d0ff75577e01d91">&#9670;&nbsp;</a></span>BddEnc_get_vars_cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="enc_2bdd_2bdd_8h.html#a2035c5ee38f991ee0a615c4ab530d321">BddVarSet_ptr</a> BddEnc_get_vars_cube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="set_8h.html#a0beb5bfe44c73e9239f023bde8a305b2">Set_t</a>&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SymbTable_8h.html#ab6f355273dfb298df3028c23c146d372">SymbFilterType</a>&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a set of variables the function produces a cube of them filtering out some of them. </p>
<p>vt is a filter and can be a combination of VFT_CURRENT, VFT_NEXT, VFT_FROZEN, VFT_INPUT (see SymbFilterType for combination shortcuts). vars has to contain variables only without NEXT or anything else. E.g. if vars contains state var V and vt includes VFT_CURRENT and VFT_NEXT then the result will contains both current and next bits of V.</p>
<p>Returned bdd is referenced, the caller must free it after it is no longer used. </p>

</div>
</div>
<a id="ad32c0065941fea32e683ddff51c786eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32c0065941fea32e683ddff51c786eb">&#9670;&nbsp;</a></span>BddEnc_get_vars_in_cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> BddEnc_get_vars_in_cube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>list_of_sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>include_next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the symbolic names of boolean variables stored in a cube. </p>
<p>Given a cube of boolean BDD variables, this function returns the list of symbolic names of the corresponding variables. If NEXT variables are also found in the cube, and include_next is true, NEXT variables will be also checked, even if not occurring explicitly in the input list.</p>
<p>Returned list must be disposed by the caller. </p>

</div>
</div>
<a id="a0bb5dfad3e717bb17f684ed3bd5a37a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb5dfad3e717bb17f684ed3bd5a37a7">&#9670;&nbsp;</a></span>BddEnc_has_var_at_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BddEnc_has_var_at_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a variable index, this method return true iff the given variable belongs to the encoder. </p>
<p>required</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBddEnc.html#a855c1816f33e8fd57ec1a74c0e9c3792" title="Given a variable index, this method return the symbolic name of the correpsonding variable...">BddEnc_get_var_name_from_index</a> </dd></dl>

</div>
</div>
<a id="aeea47276e86f8c187a9d7bd50150e0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea47276e86f8c187a9d7bd50150e0d8">&#9670;&nbsp;</a></span>BddEnc_is_var_in_cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BddEnc_is_var_in_cube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">add_ptr&#160;</td>
          <td class="paramname"><em>cube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the variable is in the cube and false otherwise. </p>
<p>Parameter name is a fully-resolved name of variable. The cube of this variable is subtracted from the cube given in 'cube' parameter, and the result is compared with the original 'cube'. If they are different then at least a part (one bit, for example) of the variable is in the input cube. Therefore true is returned. </p>

</div>
</div>
<a id="a09a7524c2d02660a2e28cc7c699b0ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a7524c2d02660a2e28cc7c699b0ea6">&#9670;&nbsp;</a></span>BddEnc_next_state_var_to_state_var()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc_next_state_var_to_state_var </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>bdd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchange state variables for next state variables. </p>
<p>Given a BDD whose variables are NEXT-STATE variables, returns an isomorphic BDD where STATE variables have been substituted for the corrisponding STATE variables </p>

</div>
</div>
<a id="a3422726b5778e4ded7e8ee07e9e83bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3422726b5778e4ded7e8ee07e9e83bad">&#9670;&nbsp;</a></span>BddEnc_next_state_var_to_state_var_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc_next_state_var_to_state_var_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">add_ptr&#160;</td>
          <td class="paramname"><em>add</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchange state variables for next state variables in terms of ADD. </p>
<p>Given an ADD whose variables are NEXT-STATE variables, returns an isomorphic ADD where STATE variables have been substituted for the corrisponding STATE variables </p>

</div>
</div>
<a id="a4f2c44c8941d8e4078ab6884d10eeafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2c44c8941d8e4078ab6884d10eeafd">&#9670;&nbsp;</a></span>BddEnc_pick_all_terms_inputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BddEnc_pick_all_terms_inputs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>bdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr *&#160;</td>
          <td class="paramname"><em>result_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>array_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the array of All Possible Minterms. </p>
<p>Takes a minterm and returns an array of all its terms, according to internally kept vars. Notice that the array of the result has to be previously allocated, and its size must be greater or equal the number of the minterms. The returned array contains referenced BDD so it is necessary to dereference them after their use. Returns true if an error occurred</p>
<p>result_array will change</p>
<dl class="section see"><dt>See also</dt><dd>bdd_pick_all_terms </dd></dl>

</div>
</div>
<a id="a3382f091bb950b1c60d0f404a294a54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3382f091bb950b1c60d0f404a294a54c">&#9670;&nbsp;</a></span>BddEnc_pick_all_terms_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BddEnc_pick_all_terms_states </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>bdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr *&#160;</td>
          <td class="paramname"><em>result_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>array_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the array of All Possible Minterms. </p>
<p>Takes a minterm and returns an array of all its terms, according to internally kept vars. Notice that the array of the result has to be previously allocated, and its size must be greater or equal the number of the minterms. The returned array contains referenced BDD so it is necessary to dereference them after their use. Returns true if an error occurred.</p>
<p>Note: states are represented by state and frozen variables.</p>
<p>result_array will change</p>
<dl class="section see"><dt>See also</dt><dd>bdd_pick_all_terms </dd></dl>

</div>
</div>
<a id="a6b4cbd8e1a9dd1c1d7b9c7011ffbefee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4cbd8e1a9dd1c1d7b9c7011ffbefee">&#9670;&nbsp;</a></span>BddEnc_pick_all_terms_states_inputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BddEnc_pick_all_terms_states_inputs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>bdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr *&#160;</td>
          <td class="paramname"><em>result_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>array_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the array of All Possible Minterms. </p>
<p>Takes a minterm and returns an array of all its terms, according to internally kept vars. Notice that the array of the result has to be previously allocated, and its size must be greater or equal the number of the minterms. The returned array contains referenced BDDs so it is necessary to dereference them after their use. Returns true if an error occurred.</p>
<p>Note: states are represented by state and frozen variables.</p>
<p>result_array will change</p>
<dl class="section see"><dt>See also</dt><dd>bdd_pick_all_terms </dd></dl>

</div>
</div>
<a id="aad34a5db9b23b3010c5c8bce5d0d0546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad34a5db9b23b3010c5c8bce5d0d0546">&#9670;&nbsp;</a></span>BddEnc_pick_one_input()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc_pick_one_input </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a minterm from a given BDD. </p>
<p>Extracts a minterm from a given BDD. Returned bdd is referenced</p>
<dl class="section see"><dt>See also</dt><dd>bdd_pick_one_minterm </dd></dl>

</div>
</div>
<a id="a30ac29320b15f542fb5cd5aa5d24367f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ac29320b15f542fb5cd5aa5d24367f">&#9670;&nbsp;</a></span>BddEnc_pick_one_input_rand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc_pick_one_input_rand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a random minterm from a given BDD. </p>
<p>Extracts a random minterm from a given BDD. Returned bdd is referenced</p>
<dl class="section see"><dt>See also</dt><dd>bdd_pick_one_minterm_rand </dd></dl>

</div>
</div>
<a id="a8c0f03cec1d2378bb69b3f602b5d84e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0f03cec1d2378bb69b3f602b5d84e3">&#9670;&nbsp;</a></span>BddEnc_pick_one_input_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc_pick_one_input_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>inputs_states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a minterm over input/state variables from a given BDD. </p>
<p>Extracts a minterm from a given BDD. Returned bdd is referenced. Note: input-states are represented by input, state and frozen variables.</p>
<dl class="section see"><dt>See also</dt><dd>bdd_pick_one_minterm, <a class="el" href="structBddEnc.html#a3e1f8f95d3a377cd52f4b770ccae6796" title="Extracts a minterm from a given BDD. ">BddEnc_pick_one_state</a>, <a class="el" href="structBddEnc.html#aad34a5db9b23b3010c5c8bce5d0d0546" title="Extracts a minterm from a given BDD. ">BddEnc_pick_one_input</a> </dd></dl>

</div>
</div>
<a id="ab1e7dee89ed1bc2bf62a67269b65776d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e7dee89ed1bc2bf62a67269b65776d">&#9670;&nbsp;</a></span>BddEnc_pick_one_input_state_rand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc_pick_one_input_state_rand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>inputs_states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a random minterm from a given BDD. </p>
<p>Extracts a random minterm from a given BDD. Returned bdd is referenced.</p>
<p>Note: input-states are represented by input, state and frozen variables.</p>
<dl class="section see"><dt>See also</dt><dd>bdd_pick_one_minterm_rand, <a class="el" href="structBddEnc.html#a30ac29320b15f542fb5cd5aa5d24367f" title="Extracts a random minterm from a given BDD. ">BddEnc_pick_one_input_rand</a>, <a class="el" href="structBddEnc.html#ae171530fd5116e43af5c91b25ce1181d" title="Extracts a random minterm from a given BDD. ">BddEnc_pick_one_state_rand</a> </dd></dl>

</div>
</div>
<a id="a3e1f8f95d3a377cd52f4b770ccae6796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1f8f95d3a377cd52f4b770ccae6796">&#9670;&nbsp;</a></span>BddEnc_pick_one_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc_pick_one_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a minterm from a given BDD. </p>
<p>Extracts a minterm from a given BDD. Returned bdd is referenced. Note: states are represented by state and frozen variables.</p>
<dl class="section see"><dt>See also</dt><dd>bdd_pick_one_minterm </dd></dl>

</div>
</div>
<a id="ae171530fd5116e43af5c91b25ce1181d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae171530fd5116e43af5c91b25ce1181d">&#9670;&nbsp;</a></span>BddEnc_pick_one_state_rand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc_pick_one_state_rand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a random minterm from a given BDD. </p>
<p>Extracts a random minterm from a given BDD. Returned bdd is referenced.</p>
<p>Note: states are represented by state and frozen variables.</p>
<dl class="section see"><dt>See also</dt><dd>bdd_pick_one_minterm_rand </dd></dl>

</div>
</div>
<a id="ae8ea6e6ad6d16663a80041cedabc98ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ea6e6ad6d16663a80041cedabc98ab">&#9670;&nbsp;</a></span>BddEnc_print_bdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc_print_bdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>bdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#ac90aff45aec92ff20e75f82312622fb4">VPFBEFNNV</a>&#160;</td>
          <td class="paramname"><em>p_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a>&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the given bdd. In particular prints only the symbols occuring in the symbols list passed to print_bdd_begin. Individual assignments may be printed using a user-defined function, passed as a parameter. </p>
<p>Before calling this method, you must call print_bdd_begin. Then you can call this method once or more, but eventually you will have to call print_bdd_end to commit. Returns the number of symbols actually printed </p>

</div>
</div>
<a id="a568122bc13bd27462f44056253fa2a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568122bc13bd27462f44056253fa2a31">&#9670;&nbsp;</a></span>BddEnc_print_bdd_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddEnc_print_bdd_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>symbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>changes_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call before a group of BddEnc_print_bdd calls. </p>
<p>This sets some fileds used by BddEnc_print_bdd. Also clears the table used when printing only changed states. After having called BddEnc_print_bdd, call BddEnc_print_bdd_end. If <code>changes_only</code> is true, than only state and frozen variables which assume a different value from the previous printed one are printed out. </p>

</div>
</div>
<a id="a5373027239419c78e21ff28c0d0f525a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5373027239419c78e21ff28c0d0f525a">&#9670;&nbsp;</a></span>BddEnc_print_bdd_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddEnc_print_bdd_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must be called after each call to BddEnc_print_bdd_begin. </p>
<p>Must be called after each call to BddEnc_print_bdd_begin, in order to clean up some internal structure </p>

</div>
</div>
<a id="a2260240da06d255923d05313ec610dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2260240da06d255923d05313ec610dca">&#9670;&nbsp;</a></span>BddEnc_print_bdd_wff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddEnc_print_bdd_wff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>bdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>do_sharing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>do_indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_at_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a>&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a BDD as a Well Formed Formula using optional sharing. </p>
<p>The bdd representing the formula to be printed is first converted to a wff.</p>
<p>If sharing is required optimizations are performed on the printout.</p>
<p>If indentation is required, the start_at_column integer offset is used to determine the starting indenting offset to print the expression.</p>
<p>prints the expression on the given stream.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBddEnc.html#aa8a29732e6d2193423266107aa1fdf77" title="Converts a bdd into a Well Formed Formula representing it. ">BddEnc_bdd_to_wff</a> </dd></dl>

</div>
</div>
<a id="a71a38861e56f851d41c14ba5ef63a3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a38861e56f851d41c14ba5ef63a3d1">&#9670;&nbsp;</a></span>BddEnc_print_formula_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddEnc_print_formula_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a>&#160;</td>
          <td class="paramname"><em>formula</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>print_models</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>print_formula</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a>&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints statistical information of a formula. </p>
<p>Prints statistical information about a given formula. It is computed taking care of the encoding and of the indifferent variables in the encoding. </p>

</div>
</div>
<a id="ab74b52ee32796eb0ba33784718f37038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74b52ee32796eb0ba33784718f37038">&#9670;&nbsp;</a></span>BddEnc_print_set_of_inputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddEnc_print_set_of_inputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>changes_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#ac90aff45aec92ff20e75f82312622fb4">VPFBEFNNV</a>&#160;</td>
          <td class="paramname"><em>p_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a>&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a set of input pairs. Individual assignments may be printed using a user-defined function, passed as a parameter. </p>

</div>
</div>
<a id="ad07bc5539ce7d89b130ea149a9246d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07bc5539ce7d89b130ea149a9246d44">&#9670;&nbsp;</a></span>BddEnc_print_set_of_state_input_pairs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddEnc_print_set_of_state_input_pairs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>state_input_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>changes_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#ac90aff45aec92ff20e75f82312622fb4">VPFBEFNNV</a>&#160;</td>
          <td class="paramname"><em>p_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a>&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a set of state-input pairs. Individual assignments may be printed using a user-defined function, passed as a parameter. </p>
<p>Note: states are represented by state and frozen variables </p>

</div>
</div>
<a id="a2548dcc8f8a4e83033145ad3dee88ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2548dcc8f8a4e83033145ad3dee88ed5">&#9670;&nbsp;</a></span>BddEnc_print_set_of_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddEnc_print_set_of_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>changes_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>print_defines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#ac90aff45aec92ff20e75f82312622fb4">VPFBEFNNV</a>&#160;</td>
          <td class="paramname"><em>p_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a>&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a set of states. Individual assignments may be printed using a user-defined function, passed as a parameter. </p>
<p>Note: states are represented by state and frozen variables </p>

</div>
</div>
<a id="aa342aab1e97ae72374b9f4ce599be1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa342aab1e97ae72374b9f4ce599be1ef">&#9670;&nbsp;</a></span>BddEnc_print_set_of_trans_models()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddEnc_print_set_of_trans_models </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>state_input_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a>&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a set of models for given trans. </p>
<p>none </p>

</div>
</div>
<a id="abcf0aaca7197e340dd1cb119a32e7eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf0aaca7197e340dd1cb119a32e7eeb">&#9670;&nbsp;</a></span>BddEnc_print_vars_in_cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddEnc_print_vars_in_cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>list_of_sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a>&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints out the symbolic names of boolean variables stored in a cube. </p>
<p>Given a cube of boolean BDD variables, this function prints out the symbolic names of the corresponding variables. The symbolic name of the variables to be printed out are listed in <code>list_of_sym</code>.</p>
<p>None </p>

</div>
</div>
<a id="ae725276a2d468d3275436372704e2ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae725276a2d468d3275436372704e2ae2">&#9670;&nbsp;</a></span>BddEnc_reset_reordering_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddEnc_reset_reordering_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the reordering count. The value returned by any following call to method get_reordering_count will be relative to the moment this method had been called. </p>
<p>Resets the reordering count. The value returned by any following call to method get_reordering_count will be relative to the moment this method had been called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBddEnc.html#a9383295a543ea442df1b6bb9b92ff5ff" title="Returns the number of reorderings that have been carried out since either the self construction or th...">BddEnc_get_reordering_count</a> </dd></dl>

</div>
</div>
<a id="a13243721b673d51b30d6e57bcc443ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13243721b673d51b30d6e57bcc443ea0">&#9670;&nbsp;</a></span>BddEnc_state_var_to_next_state_var()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc_state_var_to_next_state_var </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>bdd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchange next state variables for state variables. </p>
<p>Given a BDD whose variables are STATE variables, returns an isomorphic BDD where NEXT-STATE variables have been substituted for the corrisponding STATE variables </p>

</div>
</div>
<a id="a63ecde8eb69ad1b1707d36f304dcc875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ecde8eb69ad1b1707d36f304dcc875">&#9670;&nbsp;</a></span>BddEnc_state_var_to_next_state_var_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc_state_var_to_next_state_var_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">add_ptr&#160;</td>
          <td class="paramname"><em>add</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchange next state variables for state variables, in terms of ADD. </p>
<p>Given an ADD whose variables are STATE variables, returns an isomorphic ADD where NEXT-STATE variables have been substituted for the corrisponding STATE variables </p>

</div>
</div>
<a id="ad7260ed890fcf49fc77b6c7a18b2a40f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7260ed890fcf49fc77b6c7a18b2a40f">&#9670;&nbsp;</a></span>BddEnc_write_var_ordering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc_write_var_ordering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>oo_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="BddEnc_8h.html#afb098ed39f292e2400784f450ec1a30c">VarOrderingType</a>&#160;</td>
          <td class="paramname"><em>dump_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes on a file the variable order. </p>
<p>This function writes the variable order currently in use in the system in the specified output file. The file generated as output can be used as input order file for next computations. If the specified output file is an empty string ("" or NULL, see util_is_string_null) output is redirected to stdout. The output content depends on the value of dump_type, and can be either pure scalar (for backward compatibility) or single bits</p>
<p>Ownership of "output_order_file_name" is taken, unless it is the value returned by get_output_order_file</p>
<dl class="section see"><dt>See also</dt><dd>Compile_ReadOrder </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a313a05867430cf470bf006c951ba621b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313a05867430cf470bf006c951ba621b">&#9670;&nbsp;</a></span>cache</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BddEncCache_8h.html#a6a2ed2878c6a7d38974ec6e634471c8a">BddEncCache_ptr</a> BddEnc::cache</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e331225af4a6cc7157a1414d44c7bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e331225af4a6cc7157a1414d44c7bf0">&#9670;&nbsp;</a></span>curr_reord_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dd_8h.html#ac6ffa51d43f9f83f2507504d56d24d4c">dd_reorderingtype</a> BddEnc::curr_reord_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad461e29954fb1ffd9d19199b77c63c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad461e29954fb1ffd9d19199b77c63c4b">&#9670;&nbsp;</a></span>curr_reorderings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc::curr_reorderings</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17acf7ecb9633eacfaf490998c990c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17acf7ecb9633eacfaf490998c990c6d">&#9670;&nbsp;</a></span>current2next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray__t.html">array_t</a>* BddEnc::current2next</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b8fa268a3b7e10509f90aec7b897b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8fa268a3b7e10509f90aec7b897b2e">&#9670;&nbsp;</a></span>dd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DDMgr_8h.html#aaf9e5f2c269dadf9fa0c1ccea1680d78">DDMgr_ptr</a> BddEnc::dd</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af82969ed73b3725761fc3d8af413f048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82969ed73b3725761fc3d8af413f048">&#9670;&nbsp;</a></span>dd_vars_hndr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="VarsHandler_8h.html#a7ec02b3199a5a626f08cf8edec989b7d">VarsHandler_ptr</a> BddEnc::dd_vars_hndr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a895d4b3ceb0b23b9b7825d24761f6f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895d4b3ceb0b23b9b7825d24761f6f82">&#9670;&nbsp;</a></span>enforce_constant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BddEnc::enforce_constant</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59d6d6aafa843ac3489362fccda10674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d6d6aafa843ac3489362fccda10674">&#9670;&nbsp;</a></span>failures_hash</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash_ptr BddEnc::failures_hash</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5a7ebafc8385dfd898e859ac79ddf51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a7ebafc8385dfd898e859ac79ddf51">&#9670;&nbsp;</a></span>frozen_vars_add</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc::frozen_vars_add</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7280952ce253ee54cc99a8cf104fa33b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7280952ce253ee54cc99a8cf104fa33b">&#9670;&nbsp;</a></span>frozen_vars_bdd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc::frozen_vars_bdd</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a919f31681f1779c51b4f63bd8e4f98ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919f31681f1779c51b4f63bd8e4f98ff">&#9670;&nbsp;</a></span>frozen_vars_num</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc::frozen_vars_num</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5545f11447fa011393e0d9004614a4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5545f11447fa011393e0d9004614a4ad">&#9670;&nbsp;</a></span>index2name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray__t.html">array_t</a>* BddEnc::index2name</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a29d158061646f6aad64dc9c9bcb4b464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d158061646f6aad64dc9c9bcb4b464">&#9670;&nbsp;</a></span>index_gaps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> BddEnc::index_gaps</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65d9a3adaa3facc9ba2cc890a40e114a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d9a3adaa3facc9ba2cc890a40e114a">&#9670;&nbsp;</a></span>input_vars_add</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc::input_vars_add</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acee26275e9de3d61f871ed953b1ce2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee26275e9de3d61f871ed953b1ce2cb">&#9670;&nbsp;</a></span>input_vars_bdd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc::input_vars_bdd</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a457423fd0f11bfd2c3abc1313947c255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457423fd0f11bfd2c3abc1313947c255">&#9670;&nbsp;</a></span>input_vars_mask_add</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc::input_vars_mask_add</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac42b857c552009b3a0ae8e93f90db833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42b857c552009b3a0ae8e93f90db833">&#9670;&nbsp;</a></span>input_vars_mask_bdd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc::input_vars_mask_bdd</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbc72e38d7539cdbf89c52e20d5f2f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc72e38d7539cdbf89c52e20d5f2f17">&#9670;&nbsp;</a></span>input_vars_num</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc::input_vars_num</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2115dda0c8e8289f8cdaf008691136df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2115dda0c8e8289f8cdaf008691136df">&#9670;&nbsp;</a></span>layer2groups</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash_ptr BddEnc::layer2groups</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea6b90098abe79f68dc7286dfe11edfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6b90098abe79f68dc7286dfe11edfd">&#9670;&nbsp;</a></span>level2index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray__t.html">array_t</a>* BddEnc::level2index</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5283f92b78d25c9c5f9a28b05c81946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5283f92b78d25c9c5f9a28b05c81946">&#9670;&nbsp;</a></span>minterm_frozen_vars</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray__t.html">array_t</a>* BddEnc::minterm_frozen_vars</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d25ba354540cb8c6e8ef256167f8611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d25ba354540cb8c6e8ef256167f8611">&#9670;&nbsp;</a></span>minterm_frozen_vars_dim</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc::minterm_frozen_vars_dim</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaac10dd42dca378678c8c166d4358419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac10dd42dca378678c8c166d4358419">&#9670;&nbsp;</a></span>minterm_input_vars</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray__t.html">array_t</a>* BddEnc::minterm_input_vars</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b42be60e837ec24c026b35ab1749e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b42be60e837ec24c026b35ab1749e50">&#9670;&nbsp;</a></span>minterm_input_vars_dim</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc::minterm_input_vars_dim</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37b5f85734c08ec4d9edd42bdd592a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b5f85734c08ec4d9edd42bdd592a50">&#9670;&nbsp;</a></span>minterm_next_state_vars</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray__t.html">array_t</a>* BddEnc::minterm_next_state_vars</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56e8afa1dce163f4df42b4ec53d9e135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e8afa1dce163f4df42b4ec53d9e135">&#9670;&nbsp;</a></span>minterm_next_state_vars_dim</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc::minterm_next_state_vars_dim</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02199bebb0a74af217fdae4a70b0b78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02199bebb0a74af217fdae4a70b0b78a">&#9670;&nbsp;</a></span>minterm_state_frozen_input_vars</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray__t.html">array_t</a>* BddEnc::minterm_state_frozen_input_vars</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d25a5630e38b591ef923f5c35f1c121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d25a5630e38b591ef923f5c35f1c121">&#9670;&nbsp;</a></span>minterm_state_frozen_input_vars_dim</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc::minterm_state_frozen_input_vars_dim</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5a551deee94c8ab8fe7ca24154c5ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a551deee94c8ab8fe7ca24154c5ea8">&#9670;&nbsp;</a></span>minterm_state_frozen_vars</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray__t.html">array_t</a>* BddEnc::minterm_state_frozen_vars</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac106b19e8be1402454d17c7af73c1b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac106b19e8be1402454d17c7af73c1b56">&#9670;&nbsp;</a></span>minterm_state_frozen_vars_dim</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc::minterm_state_frozen_vars_dim</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1989afd79a4649cfb5ff6b30b4e941bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1989afd79a4649cfb5ff6b30b4e941bd">&#9670;&nbsp;</a></span>minterm_state_vars</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray__t.html">array_t</a>* BddEnc::minterm_state_vars</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a867c249a1d1b7fd7fef24bb4576d1eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867c249a1d1b7fd7fef24bb4576d1eca">&#9670;&nbsp;</a></span>minterm_state_vars_dim</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc::minterm_state_vars_dim</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a80aff137ea64e89c50e45ac5ee76a316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80aff137ea64e89c50e45ac5ee76a316">&#9670;&nbsp;</a></span>name2index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash_ptr BddEnc::name2index</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a027a9bea4538fd156e0f6cad80b69afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027a9bea4538fd156e0f6cad80b69afc">&#9670;&nbsp;</a></span>next2current</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray__t.html">array_t</a>* BddEnc::next2current</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2fd8b6ca28934242feb5fb61ec49c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fd8b6ca28934242feb5fb61ec49c23">&#9670;&nbsp;</a></span>next_state_vars_add</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc::next_state_vars_add</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c08e863d81adebc68f38f9b88326b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c08e863d81adebc68f38f9b88326b32">&#9670;&nbsp;</a></span>next_state_vars_bdd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc::next_state_vars_bdd</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a2daa270d377b5c26569bffb4e5aa6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2daa270d377b5c26569bffb4e5aa6b">&#9670;&nbsp;</a></span>ord_groups</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="OrdGroups_8h.html#a2b5af2202934a3d350e4be0a09bf0a02">OrdGroups_ptr</a> BddEnc::ord_groups</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adaecaf57f040e8c907d30dbc66d376d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaecaf57f040e8c907d30dbc66d376d8">&#9670;&nbsp;</a></span>print_stack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr BddEnc::print_stack</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab89df8bcf4d233590332641a09a71358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89df8bcf4d233590332641a09a71358">&#9670;&nbsp;</a></span>reord_locked_num</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc::reord_locked_num</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af93ef6475a9a40a808cd3b5383510318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93ef6475a9a40a808cd3b5383510318">&#9670;&nbsp;</a></span>reord_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc::reord_status</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96ff531a64b53413dda853a56bf51b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ff531a64b53413dda853a56bf51b6c">&#9670;&nbsp;</a></span>state_frozen_input_vars_mask_add</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc::state_frozen_input_vars_mask_add</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf7077615733bd43d6c507120bcef7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7077615733bd43d6c507120bcef7c9">&#9670;&nbsp;</a></span>state_frozen_input_vars_mask_bdd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc::state_frozen_input_vars_mask_bdd</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adedee83a117bc6612ee64defba6f99d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adedee83a117bc6612ee64defba6f99d9">&#9670;&nbsp;</a></span>state_frozen_vars_bdd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc::state_frozen_vars_bdd</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8967d46a12227a4f070691685e003f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8967d46a12227a4f070691685e003f7d">&#9670;&nbsp;</a></span>state_frozen_vars_mask_add</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc::state_frozen_vars_mask_add</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a9c10d8d82fd4121c9eb43627904982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9c10d8d82fd4121c9eb43627904982">&#9670;&nbsp;</a></span>state_frozen_vars_mask_bdd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc::state_frozen_vars_mask_bdd</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31e6e472dd7ee6f647ac7e00fe662cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e6e472dd7ee6f647ac7e00fe662cac">&#9670;&nbsp;</a></span>state_vars_add</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">add_ptr BddEnc::state_vars_add</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9adf0b32a8b156ca43bc6c6e230cbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9adf0b32a8b156ca43bc6c6e230cbec">&#9670;&nbsp;</a></span>state_vars_bdd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddEnc::state_vars_bdd</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84a91c45110b686c7c0543265a2ced2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a91c45110b686c7c0543265a2ced2e">&#9670;&nbsp;</a></span>state_vars_num</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc::state_vars_num</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a549685e9470a559111f71007fab70e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549685e9470a559111f71007fab70e8b">&#9670;&nbsp;</a></span>type_checker</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> BddEnc::type_checker</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a022d4d99f5a5c31e393b465cf192f473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022d4d99f5a5c31e393b465cf192f473">&#9670;&nbsp;</a></span>used_indices_frontier</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BddEnc::used_indices_frontier</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>/root/research/NuSMV-2.6.0/NuSMV/code/nusmv/core/enc/bdd/<a class="el" href="BddEnc__private_8h_source.html">BddEnc_private.h</a></li>
<li>/root/research/NuSMV-2.6.0/NuSMV/code/nusmv/core/enc/bdd/<a class="el" href="BddEnc_8h_source.html">BddEnc.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 18 2022 22:26:36 for NuSMV Developers Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
