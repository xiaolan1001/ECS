<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NuSMV Developers Manual: SymbType Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NuSMV Developers Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">SymbType Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An interface to deal with the types of variables (during compilation and type checking.  
 <a href="structSymbType.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SymbType_8h_source.html">SymbType.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:afed09cd235d4186d4e07915f88c86420"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#afed09cd235d4186d4e07915f88c86420">SymbType_calculate_type_size</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:afed09cd235d4186d4e07915f88c86420"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function calculate how many bits is required to store a value of a given type.  <a href="#afed09cd235d4186d4e07915f88c86420">More...</a><br /></td></tr>
<tr class="separator:afed09cd235d4186d4e07915f88c86420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d81221e8e74bbc67cfbe7035902a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#ac5d81221e8e74bbc67cfbe7035902a6b">SymbType_copy</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:ac5d81221e8e74bbc67cfbe7035902a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="structSymbType.html" title="An interface to deal with the types of variables (during compilation and type checking. ">SymbType</a> copy-constructor.  <a href="#ac5d81221e8e74bbc67cfbe7035902a6b">More...</a><br /></td></tr>
<tr class="separator:ac5d81221e8e74bbc67cfbe7035902a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af113ecf6b22aaf868a5f3f9a46842840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840">SymbType_create</a> (const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a> env, <a class="el" href="SymbType_8h.html#adaf8202d5694b0f9a242fa7f81add90a">SymbTypeTag</a> tag, node_ptr body)</td></tr>
<tr class="memdesc:af113ecf6b22aaf868a5f3f9a46842840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="structSymbType.html" title="An interface to deal with the types of variables (during compilation and type checking. ">SymbType</a> constructor.  <a href="#af113ecf6b22aaf868a5f3f9a46842840">More...</a><br /></td></tr>
<tr class="separator:af113ecf6b22aaf868a5f3f9a46842840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b9cb75730c9c5278dbaff061055342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#ab4b9cb75730c9c5278dbaff061055342">SymbType_create_array</a> (<a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> subtype, int lower_bound, int upper_bound)</td></tr>
<tr class="memdesc:ab4b9cb75730c9c5278dbaff061055342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="structSymbType.html" title="An interface to deal with the types of variables (during compilation and type checking. ">SymbType</a> constructor for array types only.  <a href="#ab4b9cb75730c9c5278dbaff061055342">More...</a><br /></td></tr>
<tr class="separator:ab4b9cb75730c9c5278dbaff061055342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccc27784ee27ffa19b2ee80d95a25c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#abccc27784ee27ffa19b2ee80d95a25c3">SymbType_create_memory_sharing_array_type</a> (<a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> subtype, int lower_bound, int higher_bound)</td></tr>
<tr class="memdesc:abccc27784ee27ffa19b2ee80d95a25c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private class <a class="el" href="structSymbType.html" title="An interface to deal with the types of variables (during compilation and type checking. ">SymbType</a> constructor for memory sharing array type instances.  <a href="#abccc27784ee27ffa19b2ee80d95a25c3">More...</a><br /></td></tr>
<tr class="separator:abccc27784ee27ffa19b2ee80d95a25c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd49c930957bf3282f01436f3cca5eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a0dd49c930957bf3282f01436f3cca5eb">SymbType_create_memory_sharing_type</a> (const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a> env, <a class="el" href="SymbType_8h.html#adaf8202d5694b0f9a242fa7f81add90a">SymbTypeTag</a> tag, node_ptr body)</td></tr>
<tr class="memdesc:a0dd49c930957bf3282f01436f3cca5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private interface accessed by class <a class="el" href="structSymbTable.html" title="The system wide symbol table interface. ">SymbTable</a>.  <a href="#a0dd49c930957bf3282f01436f3cca5eb">More...</a><br /></td></tr>
<tr class="separator:a0dd49c930957bf3282f01436f3cca5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfde8f1ac1c2ef0575806d56db0c58e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#abfde8f1ac1c2ef0575806d56db0c58e3">SymbType_create_nfunction</a> (const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a> env, <a class="el" href="NFunction_8h.html#afb16a75c5ac381374d42968419203c35">NFunction_ptr</a> nfunction)</td></tr>
<tr class="memdesc:abfde8f1ac1c2ef0575806d56db0c58e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="structSymbType.html" title="An interface to deal with the types of variables (during compilation and type checking. ">SymbType</a> constructor for uninterpreted functions only.  <a href="#abfde8f1ac1c2ef0575806d56db0c58e3">More...</a><br /></td></tr>
<tr class="separator:abfde8f1ac1c2ef0575806d56db0c58e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3346c41706bd972c126756d71ab904"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#ade3346c41706bd972c126756d71ab904">SymbType_destroy</a> (<a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:ade3346c41706bd972c126756d71ab904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="structSymbType.html" title="An interface to deal with the types of variables (during compilation and type checking. ">SymbType</a> destructor.  <a href="#ade3346c41706bd972c126756d71ab904">More...</a><br /></td></tr>
<tr class="separator:ade3346c41706bd972c126756d71ab904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e90f68eb79eb8d215ff57e9dfd125a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a9e90f68eb79eb8d215ff57e9dfd125a0">SymbType_destroy_memory_sharing_type</a> (<a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a9e90f68eb79eb8d215ff57e9dfd125a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private Class <a class="el" href="structSymbType.html" title="An interface to deal with the types of variables (during compilation and type checking. ">SymbType</a> destructor for memory sharing instances of types.  <a href="#a9e90f68eb79eb8d215ff57e9dfd125a0">More...</a><br /></td></tr>
<tr class="separator:a9e90f68eb79eb8d215ff57e9dfd125a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b29fd74a2f041768e8fffd3da2ed9bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a5b29fd74a2f041768e8fffd3da2ed9bc">SymbType_equals</a> (<a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self, <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> oth)</td></tr>
<tr class="memdesc:a5b29fd74a2f041768e8fffd3da2ed9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if and only if the given types are equal, the given types can be memory-sharing or not.  <a href="#a5b29fd74a2f041768e8fffd3da2ed9bc">More...</a><br /></td></tr>
<tr class="separator:a5b29fd74a2f041768e8fffd3da2ed9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae122cf59609f7e8a06bb54f8318fcb0b"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#ae122cf59609f7e8a06bb54f8318fcb0b">SymbType_generate_all_word_values</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:ae122cf59609f7e8a06bb54f8318fcb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a list of all possible values of a particular Unsigned Word type.  <a href="#ae122cf59609f7e8a06bb54f8318fcb0b">More...</a><br /></td></tr>
<tr class="separator:ae122cf59609f7e8a06bb54f8318fcb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b8fc67b0696ed9d68442ef552a003b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a09b8fc67b0696ed9d68442ef552a003b">SymbType_get_array_lower_bound</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a09b8fc67b0696ed9d68442ef552a003b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get array lower bound.  <a href="#a09b8fc67b0696ed9d68442ef552a003b">More...</a><br /></td></tr>
<tr class="separator:a09b8fc67b0696ed9d68442ef552a003b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31f5f7303c83cdf2c36c1ef892639f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#ad31f5f7303c83cdf2c36c1ef892639f1">SymbType_get_array_subtype</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:ad31f5f7303c83cdf2c36c1ef892639f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get inner type of an array.  <a href="#ad31f5f7303c83cdf2c36c1ef892639f1">More...</a><br /></td></tr>
<tr class="separator:ad31f5f7303c83cdf2c36c1ef892639f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb3d24a11fd8bd0ec489f14860fa816"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#aecb3d24a11fd8bd0ec489f14860fa816">SymbType_get_array_upper_bound</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:aecb3d24a11fd8bd0ec489f14860fa816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get array upper bound.  <a href="#aecb3d24a11fd8bd0ec489f14860fa816">More...</a><br /></td></tr>
<tr class="separator:aecb3d24a11fd8bd0ec489f14860fa816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05955b2f4074020658ace8c522614bec"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a05955b2f4074020658ace8c522614bec">SymbType_get_enum_type_values</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a05955b2f4074020658ace8c522614bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of values of an enum type.  <a href="#a05955b2f4074020658ace8c522614bec">More...</a><br /></td></tr>
<tr class="separator:a05955b2f4074020658ace8c522614bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86631ffd888cb9dae694ffe5ab34ffdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a86631ffd888cb9dae694ffe5ab34ffdd">SymbType_get_intarray_subtype</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a86631ffd888cb9dae694ffe5ab34ffdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get inner type of an array.  <a href="#a86631ffd888cb9dae694ffe5ab34ffdd">More...</a><br /></td></tr>
<tr class="separator:a86631ffd888cb9dae694ffe5ab34ffdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c7fa84f47152a14e3834f70c1e5d29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="NFunction_8h.html#afb16a75c5ac381374d42968419203c35">NFunction_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#ac4c7fa84f47152a14e3834f70c1e5d29">SymbType_get_nfunction_type</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:ac4c7fa84f47152a14e3834f70c1e5d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of an <a class="el" href="structNFunction.html" title="Public interface of class &#39;NFunction&#39;. ">NFunction</a>.  <a href="#ac4c7fa84f47152a14e3834f70c1e5d29">More...</a><br /></td></tr>
<tr class="separator:ac4c7fa84f47152a14e3834f70c1e5d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30107daf1b66d13e8905418dbf8be6ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SymbType_8h.html#adaf8202d5694b0f9a242fa7f81add90a">SymbTypeTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a30107daf1b66d13e8905418dbf8be6ce">SymbType_get_tag</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a30107daf1b66d13e8905418dbf8be6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tag (the kind) of the type.  <a href="#a30107daf1b66d13e8905418dbf8be6ce">More...</a><br /></td></tr>
<tr class="separator:a30107daf1b66d13e8905418dbf8be6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0ba3c88fd4989194ce7e6559415aa0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a6a0ba3c88fd4989194ce7e6559415aa0">SymbType_get_word_line_number</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a6a0ba3c88fd4989194ce7e6559415aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the line number where the type was declared.  <a href="#a6a0ba3c88fd4989194ce7e6559415aa0">More...</a><br /></td></tr>
<tr class="separator:a6a0ba3c88fd4989194ce7e6559415aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b76d53e4e93a5edd9371f55a9fa285"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#ae1b76d53e4e93a5edd9371f55a9fa285">SymbType_get_word_width</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:ae1b76d53e4e93a5edd9371f55a9fa285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width of a Word type.  <a href="#ae1b76d53e4e93a5edd9371f55a9fa285">More...</a><br /></td></tr>
<tr class="separator:ae1b76d53e4e93a5edd9371f55a9fa285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f79fc1d359dd1ea0ba64c4dfcc7859"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a39f79fc1d359dd1ea0ba64c4dfcc7859">SymbType_get_wordarray_awidth</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a39f79fc1d359dd1ea0ba64c4dfcc7859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width of the address in a WordArray type.  <a href="#a39f79fc1d359dd1ea0ba64c4dfcc7859">More...</a><br /></td></tr>
<tr class="separator:a39f79fc1d359dd1ea0ba64c4dfcc7859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff9ca74cef23f2017a80475a6956d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a8ff9ca74cef23f2017a80475a6956d9c">SymbType_get_wordarray_subtype</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a8ff9ca74cef23f2017a80475a6956d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the subtype of wordarray.  <a href="#a8ff9ca74cef23f2017a80475a6956d9c">More...</a><br /></td></tr>
<tr class="separator:a8ff9ca74cef23f2017a80475a6956d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae761c10889d2cf6277d616ba6cb1ebe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#ae761c10889d2cf6277d616ba6cb1ebe8">SymbType_is_array</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:ae761c10889d2cf6277d616ba6cb1ebe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the type is an array-type, or else returns false.  <a href="#ae761c10889d2cf6277d616ba6cb1ebe8">More...</a><br /></td></tr>
<tr class="separator:ae761c10889d2cf6277d616ba6cb1ebe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d37b81549c5598bd0d7f54e6608282"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a21d37b81549c5598bd0d7f54e6608282">SymbType_is_boolean</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a21d37b81549c5598bd0d7f54e6608282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the type is boolean. Otherwise - returns false.  <a href="#a21d37b81549c5598bd0d7f54e6608282">More...</a><br /></td></tr>
<tr class="separator:a21d37b81549c5598bd0d7f54e6608282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad011fda6eacffa8960dd9e79e2764bf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#ad011fda6eacffa8960dd9e79e2764bf1">SymbType_is_continuous</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:ad011fda6eacffa8960dd9e79e2764bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the type is a continuous type, or else returns false.  <a href="#ad011fda6eacffa8960dd9e79e2764bf1">More...</a><br /></td></tr>
<tr class="separator:ad011fda6eacffa8960dd9e79e2764bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e23b36cb8ec64eaaaefb38e130a6a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#ae0e23b36cb8ec64eaaaefb38e130a6a4">SymbType_is_enum</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:ae0e23b36cb8ec64eaaaefb38e130a6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the type is a enum-type, or else returns false.  <a href="#ae0e23b36cb8ec64eaaaefb38e130a6a4">More...</a><br /></td></tr>
<tr class="separator:ae0e23b36cb8ec64eaaaefb38e130a6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad537b377ad24a1ffb66a81ed7f67b827"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#ad537b377ad24a1ffb66a81ed7f67b827">SymbType_is_error</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:ad537b377ad24a1ffb66a81ed7f67b827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the type is a error-type, and false otherwise.  <a href="#ad537b377ad24a1ffb66a81ed7f67b827">More...</a><br /></td></tr>
<tr class="separator:ad537b377ad24a1ffb66a81ed7f67b827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc2de1400ddb8e31bb37d093c5c7a8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a7fc2de1400ddb8e31bb37d093c5c7a8e">SymbType_is_function</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a7fc2de1400ddb8e31bb37d093c5c7a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the type is an uninterpreted function type.  <a href="#a7fc2de1400ddb8e31bb37d093c5c7a8e">More...</a><br /></td></tr>
<tr class="separator:a7fc2de1400ddb8e31bb37d093c5c7a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61d3f1e2811bb7cbe847d3468209303"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#af61d3f1e2811bb7cbe847d3468209303">SymbType_is_infinite_precision</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:af61d3f1e2811bb7cbe847d3468209303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the type is one of infinite-precision types.  <a href="#af61d3f1e2811bb7cbe847d3468209303">More...</a><br /></td></tr>
<tr class="separator:af61d3f1e2811bb7cbe847d3468209303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2834f3052ffed41a0f77e8025a486c92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a2834f3052ffed41a0f77e8025a486c92">SymbType_is_int_symbolic_enum</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a2834f3052ffed41a0f77e8025a486c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the type is a enum-type and its value are symbolic AND integer constants. Otherwise - returns false.  <a href="#a2834f3052ffed41a0f77e8025a486c92">More...</a><br /></td></tr>
<tr class="separator:a2834f3052ffed41a0f77e8025a486c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4759c817447425ca592d41749727f94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#ab4759c817447425ca592d41749727f94">SymbType_is_intarray</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:ab4759c817447425ca592d41749727f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the type is intarray, or else returns false.  <a href="#ab4759c817447425ca592d41749727f94">More...</a><br /></td></tr>
<tr class="separator:ab4759c817447425ca592d41749727f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeda085c043506fa2365ae89f713e6e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#aeeda085c043506fa2365ae89f713e6e5">SymbType_is_integer</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:aeeda085c043506fa2365ae89f713e6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the type is a integer-type, or else returns false.  <a href="#aeeda085c043506fa2365ae89f713e6e5">More...</a><br /></td></tr>
<tr class="separator:aeeda085c043506fa2365ae89f713e6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac986bd4dea4ddfe1d74192b89ea7fa92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#ac986bd4dea4ddfe1d74192b89ea7fa92">SymbType_is_memory_shared</a> (<a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:ac986bd4dea4ddfe1d74192b89ea7fa92"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if and only if the given type is memory shared.  <a href="#ac986bd4dea4ddfe1d74192b89ea7fa92">More...</a><br /></td></tr>
<tr class="separator:ac986bd4dea4ddfe1d74192b89ea7fa92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d8be43d19a0272033f98741efb71b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a33d8be43d19a0272033f98741efb71b9">SymbType_is_pure_int_enum</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a33d8be43d19a0272033f98741efb71b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the type is a enum-type and its value are integers only. Otherwise - returns false.  <a href="#a33d8be43d19a0272033f98741efb71b9">More...</a><br /></td></tr>
<tr class="separator:a33d8be43d19a0272033f98741efb71b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf887daca0522f8fe29ac3f34efffad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#aaf887daca0522f8fe29ac3f34efffad3">SymbType_is_pure_symbolic_enum</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:aaf887daca0522f8fe29ac3f34efffad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the type is a enum-type and its value are symbolic constants only. Otherwise - returns false.  <a href="#aaf887daca0522f8fe29ac3f34efffad3">More...</a><br /></td></tr>
<tr class="separator:aaf887daca0522f8fe29ac3f34efffad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872921ea90ef19798f7b62e83729c699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a872921ea90ef19798f7b62e83729c699">SymbType_is_real</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a872921ea90ef19798f7b62e83729c699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the type is a real-type, or else returns false.  <a href="#a872921ea90ef19798f7b62e83729c699">More...</a><br /></td></tr>
<tr class="separator:a872921ea90ef19798f7b62e83729c699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6766289626e2752cf0fcc7c91467e0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#ad6766289626e2752cf0fcc7c91467e0c">SymbType_is_set</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:ad6766289626e2752cf0fcc7c91467e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the type is one of the set-types, i.e. boolean-set, integer-set, symbolic-set, integer-symbolic-set, and false otherwise.  <a href="#ad6766289626e2752cf0fcc7c91467e0c">More...</a><br /></td></tr>
<tr class="separator:ad6766289626e2752cf0fcc7c91467e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45af09319a7008cb5ee947267e9e32d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a45af09319a7008cb5ee947267e9e32d5">SymbType_is_signed_word</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a45af09319a7008cb5ee947267e9e32d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the type is a signed Word type.  <a href="#a45af09319a7008cb5ee947267e9e32d5">More...</a><br /></td></tr>
<tr class="separator:a45af09319a7008cb5ee947267e9e32d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfbfd850e6c6ef8573fb03e65168f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#aacfbfd850e6c6ef8573fb03e65168f70">SymbType_is_single_value_enum</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:aacfbfd850e6c6ef8573fb03e65168f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if it is enum and with just one value.  <a href="#aacfbfd850e6c6ef8573fb03e65168f70">More...</a><br /></td></tr>
<tr class="separator:aacfbfd850e6c6ef8573fb03e65168f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b90f10705dcebbc607f1c26ed81180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a60b90f10705dcebbc607f1c26ed81180">SymbType_is_statement</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a60b90f10705dcebbc607f1c26ed81180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the type is a statement-type, and false otherwise.  <a href="#a60b90f10705dcebbc607f1c26ed81180">More...</a><br /></td></tr>
<tr class="separator:a60b90f10705dcebbc607f1c26ed81180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9d3ec42249fb45cce192e1b39a50ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a7a9d3ec42249fb45cce192e1b39a50ad">SymbType_is_unsigned_word</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a7a9d3ec42249fb45cce192e1b39a50ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the type is an unsigned Word type.  <a href="#a7a9d3ec42249fb45cce192e1b39a50ad">More...</a><br /></td></tr>
<tr class="separator:a7a9d3ec42249fb45cce192e1b39a50ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e2aec84dd6322667e9a8c6f96aea5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a39e2aec84dd6322667e9a8c6f96aea5c">SymbType_is_word</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a39e2aec84dd6322667e9a8c6f96aea5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the type is a Word type (signed or unsigned)  <a href="#a39e2aec84dd6322667e9a8c6f96aea5c">More...</a><br /></td></tr>
<tr class="separator:a39e2aec84dd6322667e9a8c6f96aea5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda34c5f36433ad5bdc0846a83a1ad9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#afda34c5f36433ad5bdc0846a83a1ad9e">SymbType_is_word_1</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:afda34c5f36433ad5bdc0846a83a1ad9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the type is a Unsigned Word type and the width of the word is 1. Otherwise - returns false.  <a href="#afda34c5f36433ad5bdc0846a83a1ad9e">More...</a><br /></td></tr>
<tr class="separator:afda34c5f36433ad5bdc0846a83a1ad9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a24e446d4723692fd45c8482a9be1f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a8a24e446d4723692fd45c8482a9be1f1">SymbType_is_wordarray</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a8a24e446d4723692fd45c8482a9be1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given type is a wordarray.  <a href="#a8a24e446d4723692fd45c8482a9be1f1">More...</a><br /></td></tr>
<tr class="separator:a8a24e446d4723692fd45c8482a9be1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960e008b1974f7c80243de4f4b4f7d40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a960e008b1974f7c80243de4f4b4f7d40">SymbType_make_from_set_type</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a960e008b1974f7c80243de4f4b4f7d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is opposite to SymbType_make_set_type, i.e. if the given type is one of the set-types, then the type without "set" suffix is returned. Otherwise the type is returned without change.  <a href="#a960e008b1974f7c80243de4f4b4f7d40">More...</a><br /></td></tr>
<tr class="separator:a960e008b1974f7c80243de4f4b4f7d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752b9604559ddc098ae67a7f2a98a9f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a752b9604559ddc098ae67a7f2a98a9f7">SymbType_make_memory_shared</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a752b9604559ddc098ae67a7f2a98a9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a NOT memory shared type and returns a memory shared one.  <a href="#a752b9604559ddc098ae67a7f2a98a9f7">More...</a><br /></td></tr>
<tr class="separator:a752b9604559ddc098ae67a7f2a98a9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2f4cfba1f2d3ae4057be9e7ceafab2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a3b2f4cfba1f2d3ae4057be9e7ceafab2">SymbType_make_set_type</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self)</td></tr>
<tr class="memdesc:a3b2f4cfba1f2d3ae4057be9e7ceafab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a minimal set-type which the given type can be implicitly converted to, or NULL if this is impossible.  <a href="#a3b2f4cfba1f2d3ae4057be9e7ceafab2">More...</a><br /></td></tr>
<tr class="separator:a3b2f4cfba1f2d3ae4057be9e7ceafab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa008effa8935971b6949c7dfd9c95b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#a2aa008effa8935971b6949c7dfd9c95b">SymbType_print</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self, <a class="el" href="MasterPrinter_8h.html#adefcbfb8d647308a7dfd66842759df62">MasterPrinter_ptr</a> printer, FILE *output_stream)</td></tr>
<tr class="memdesc:a2aa008effa8935971b6949c7dfd9c95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the type structure to the output stream.  <a href="#a2aa008effa8935971b6949c7dfd9c95b">More...</a><br /></td></tr>
<tr class="separator:a2aa008effa8935971b6949c7dfd9c95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5834716de187ca5a5c63f234f4f2f1c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#aa5834716de187ca5a5c63f234f4f2f1c">SymbType_sprint</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self, <a class="el" href="MasterPrinter_8h.html#adefcbfb8d647308a7dfd66842759df62">MasterPrinter_ptr</a> printer)</td></tr>
<tr class="memdesc:aa5834716de187ca5a5c63f234f4f2f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string representation of the given type.  <a href="#aa5834716de187ca5a5c63f234f4f2f1c">More...</a><br /></td></tr>
<tr class="separator:aa5834716de187ca5a5c63f234f4f2f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab237b0d5c1efc033c43d03d2a33a2362"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSymbType.html#ab237b0d5c1efc033c43d03d2a33a2362">SymbType_to_node</a> (const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> self, <a class="el" href="NodeMgr_8h.html#a7f6ea9987bf1e8bb6897e86cb4b5c1a0">NodeMgr_ptr</a> nodemgr)</td></tr>
<tr class="memdesc:ab237b0d5c1efc033c43d03d2a33a2362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a node representing a type.  <a href="#ab237b0d5c1efc033c43d03d2a33a2362">More...</a><br /></td></tr>
<tr class="separator:ab237b0d5c1efc033c43d03d2a33a2362"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An interface to deal with the types of variables (during compilation and type checking. </p>
<dl class="section author"><dt>Author</dt><dd>Andrei Tchaltsev This class represent the types of the NuSMV type system.</dd></dl>
<p>NOTE: In the following description "integer" is used everywhere to refer to the set of natural numbers, EXCEPT for the type specified in c), that has a special meaning.</p>
<p>The types can be: a) boolean (TRUE, FALSE) b) enum (enumeration), that represents a set of particular values, e.g. . a pure symbolic enumeration type: {A, OK, CORRECT, FAIL} . a pure integer enumeration type: {1,2,3,4,5, 10, -1, 0} . an integer and symbolic enumeration type: {0, 2, 4, OK, FAIL} . a range of integer values: 1 .. 10; c) integer, that represents the infinite-precision integer arithmetic. d) real, that represents the infinite-precision rational arithmetic. e) continuous, that represents infinite-precision real variables with continuous behavior (they can be derivated); f) word of width N (N is an integer positive number), that represents bit vectors of N bits. g) WordArray of address word of width M and value word of width N (with M and N integer positive numbers), that represents a memory array of 2^M locations, each of which contains a word of M bits. WARNING: Traces assumes only array defines to have type array h) Array represents array of fixed lower and upper bounds and elements of a particular type. i) <a class="el" href="structSet.html" title="Generic Set Data Structure. ">Set</a> types created by "union" expressions and used in "in", "case" and ":=" expressions: . a set of boolean values : 0 union 1 . a set of integer values : 0 union -1 union 10 . a set of symbolic values : OK union FAIL . a set of integer and symbolic values: OK union 1 Note that only expressions (not declared variables) can have these types. j) No-type is an artificial type to represent expressions which usually do not have any type (for example, assignments). k) Error type is an artificial type to represent erroneous situations.</p>
<p>A type can be created with the class' constructor. In the case of a enum type, during construction it is necessary to specify explicitly the list of values this type consists of.</p>
<p>The constructor is typically used in a symbol table.</p>
<p>Another possibility is to obtain the types with SymbTablePkg_..._type functions. In this case, the enum types will be "abstract", i.e. they will consist of some artificial (not existing) values. The important feature is that the memory is shared by these functions, i.e. you can compare pointers to types, instead of the types' contents. These functions are mostly used in type checking (since the particular values of enum types are of no importance).</p>
<p>Generic and symbolic encoding </p>
</div><h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="afed09cd235d4186d4e07915f88c86420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed09cd235d4186d4e07915f88c86420">&#9670;&nbsp;</a></span>SymbType_calculate_type_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SymbType_calculate_type_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function calculate how many bits is required to store a value of a given type. </p>
<p>This function can be invoked only on finite-precision valid type of variables. This means that such types as no-type or error-type or real or any memory-shared ones should not be given to this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a> </dd></dl>

</div>
</div>
<a id="ac5d81221e8e74bbc67cfbe7035902a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d81221e8e74bbc67cfbe7035902a6b">&#9670;&nbsp;</a></span>SymbType_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> SymbType_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class <a class="el" href="structSymbType.html" title="An interface to deal with the types of variables (during compilation and type checking. ">SymbType</a> copy-constructor. </p>
<p>This function takes one type and returns its copy.</p>
<p>Note: the body of the type is not copied, i.e. just pointer is remembered. See SymbType_create for more info about body.</p>
<p>Note: the input type should not be a memory-shared type (since there is no meaning in coping a memory sharing type).</p>
<p>allocate memory</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#ade3346c41706bd972c126756d71ab904" title="Class SymbType destructor. ">SymbType_destroy</a> </dd></dl>

</div>
</div>
<a id="af113ecf6b22aaf868a5f3f9a46842840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af113ecf6b22aaf868a5f3f9a46842840">&#9670;&nbsp;</a></span>SymbType_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> SymbType_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SymbType_8h.html#adaf8202d5694b0f9a242fa7f81add90a">SymbTypeTag</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>body</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class <a class="el" href="structSymbType.html" title="An interface to deal with the types of variables (during compilation and type checking. ">SymbType</a> constructor. </p>
<p>The tag must be a correct tag. The 'body' is the additional info corresponding to a particular kind of the type: for a enum type the body is the list of values; for "BOOL", "INT" or "REAL" the body is unused, and set to Nil; for signed and unsigned "WORD" it is the NUMBER node defining the width of the type; for "WORDARRAY", the body is a pair of NUMBER nodes, defining the width of the address, and the width of the value. for everything else body is Nil;</p>
<p>Note that array types have to be created with SymbType_create_array, not with this constructor.</p>
<p>Set-types are used with expressions which represent a set values. "NO-TYPE" is used with expressions which normally do not have any type such as assignments. "ERROR" type indicates an error (not an actual type).</p>
<p>No-type, error-type and all set-types (boolean-set, integer-set, symbolic-set, symbolic-integer-set) should not be created with this constructor, but only with memory-shared function SymbTablePkg_..._type. The reason behind this constrain is that only expressions (not variables) can have these types, therefore only memory-shared versions of these types are required.</p>
<p>The constructor does not create a copy of the body, but just remember the pointer.</p>
<p>NB: system "reset" command destroys all node_ptr objects, including those used in SymbType_ptr. So destroy all symbolic types before the destruction of node_ptr objects, i.e. before or during "reset"</p>
<p>allocate memory</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#ab4b9cb75730c9c5278dbaff061055342" title="Class SymbType constructor for array types only. ">SymbType_create_array</a>, <a class="el" href="structSymbType.html#ade3346c41706bd972c126756d71ab904" title="Class SymbType destructor. ">SymbType_destroy</a> </dd></dl>

</div>
</div>
<a id="ab4b9cb75730c9c5278dbaff061055342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b9cb75730c9c5278dbaff061055342">&#9670;&nbsp;</a></span>SymbType_create_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> SymbType_create_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>subtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class <a class="el" href="structSymbType.html" title="An interface to deal with the types of variables (during compilation and type checking. ">SymbType</a> constructor for array types only. </p>
<p>WARNING: Traces assumes only array defines to have type ARRAY This is specialized version of SymbType_create which is designed for array types only. It is implemented as a special construtor because array types are quite different from all the others.</p>
<p>Parameter subtype is the subtype of the array type. This type has to be not-memory-shared and its ownership is passed to created type. I.e. subtype will be destroyed when returned type is destroyed.</p>
<p>lower_bound, upper-bound are the lower and upper bounds,resp, of the array.</p>
<p>All the constrains about memory, lifetype, etc are the same as for SymbType_create.</p>
<p>allocate memory</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#ade3346c41706bd972c126756d71ab904" title="Class SymbType destructor. ">SymbType_destroy</a> </dd></dl>

</div>
</div>
<a id="abccc27784ee27ffa19b2ee80d95a25c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abccc27784ee27ffa19b2ee80d95a25c3">&#9670;&nbsp;</a></span>SymbType_create_memory_sharing_array_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> SymbType_create_memory_sharing_array_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>subtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>higher_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private class <a class="el" href="structSymbType.html" title="An interface to deal with the types of variables (during compilation and type checking. ">SymbType</a> constructor for memory sharing array type instances. </p>
<p>The same as SymbType_create_memory_sharing_type but can be used to create array types. subtype has to be memory shared.</p>
<p>allocate memory</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a>, <a class="el" href="structSymbType.html#a9e90f68eb79eb8d215ff57e9dfd125a0" title="Private Class SymbType destructor for memory sharing instances of types. ">SymbType_destroy_memory_sharing_type</a> </dd></dl>

</div>
</div>
<a id="a0dd49c930957bf3282f01436f3cca5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd49c930957bf3282f01436f3cca5eb">&#9670;&nbsp;</a></span>SymbType_create_memory_sharing_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> SymbType_create_memory_sharing_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SymbType_8h.html#adaf8202d5694b0f9a242fa7f81add90a">SymbTypeTag</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>body</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private interface accessed by class <a class="el" href="structSymbTable.html" title="The system wide symbol table interface. ">SymbTable</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Andrei Tchaltsev </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000609">Todo:</a></b></dt><dd>: Missing description</dd></dl>
<p>Private class <a class="el" href="structSymbType.html" title="An interface to deal with the types of variables (during compilation and type checking. ">SymbType</a> constructor for memory sharing type instances</p>
<p>The difference from the public constructor is that this constructor marks the created type as a memory sharing type. As result the public constructor will not be able to destroy memory sharing instance of a type. Use the private constructor SymbType_destroy_memory_sharing_type to destroy such instances.</p>
<p>allocate memory</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a>, <a class="el" href="structSymbType.html#a9e90f68eb79eb8d215ff57e9dfd125a0" title="Private Class SymbType destructor for memory sharing instances of types. ">SymbType_destroy_memory_sharing_type</a> </dd></dl>

</div>
</div>
<a id="abfde8f1ac1c2ef0575806d56db0c58e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfde8f1ac1c2ef0575806d56db0c58e3">&#9670;&nbsp;</a></span>SymbType_create_nfunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> SymbType_create_nfunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NFunction_8h.html#afb16a75c5ac381374d42968419203c35">NFunction_ptr</a>&#160;</td>
          <td class="paramname"><em>nfunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class <a class="el" href="structSymbType.html" title="An interface to deal with the types of variables (during compilation and type checking. ">SymbType</a> constructor for uninterpreted functions only. </p>
<p>This is specialized version of SymbType_create which is designed for uninterpreted functions only. It is implemented as a special construtor because functions types are quite different from all the others.</p>
<p>allocate memory</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#ade3346c41706bd972c126756d71ab904" title="Class SymbType destructor. ">SymbType_destroy</a> </dd></dl>

</div>
</div>
<a id="ade3346c41706bd972c126756d71ab904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3346c41706bd972c126756d71ab904">&#9670;&nbsp;</a></span>SymbType_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SymbType_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class <a class="el" href="structSymbType.html" title="An interface to deal with the types of variables (during compilation and type checking. ">SymbType</a> destructor. </p>
<p>Deallocate the memory. The destructor does not deallocate memory from the type's body (since the constructor did not created the body).</p>
<p>NOTE: If self is a memory sharing type instance, i.e. a type returned by SymbTablePkg_..._type functions then the destructor will not delete the type.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a> </dd></dl>

</div>
</div>
<a id="a9e90f68eb79eb8d215ff57e9dfd125a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e90f68eb79eb8d215ff57e9dfd125a0">&#9670;&nbsp;</a></span>SymbType_destroy_memory_sharing_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SymbType_destroy_memory_sharing_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private Class <a class="el" href="structSymbType.html" title="An interface to deal with the types of variables (during compilation and type checking. ">SymbType</a> destructor for memory sharing instances of types. </p>
<p>The same as the public destructor SymbType_destroy but 'self' has to be created by private constructor SymbType_create_memory_sharing_type only.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#a0dd49c930957bf3282f01436f3cca5eb" title="Private interface accessed by class SymbTable. ">SymbType_create_memory_sharing_type</a>, <a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a> </dd></dl>

</div>
</div>
<a id="a5b29fd74a2f041768e8fffd3da2ed9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b29fd74a2f041768e8fffd3da2ed9bc">&#9670;&nbsp;</a></span>SymbType_equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_equals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>oth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if and only if the given types are equal, the given types can be memory-sharing or not. </p>

</div>
</div>
<a id="ae122cf59609f7e8a06bb54f8318fcb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae122cf59609f7e8a06bb54f8318fcb0b">&#9670;&nbsp;</a></span>SymbType_generate_all_word_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr SymbType_generate_all_word_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates and returns a list of all possible values of a particular Unsigned Word type. </p>

</div>
</div>
<a id="a09b8fc67b0696ed9d68442ef552a003b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b8fc67b0696ed9d68442ef552a003b">&#9670;&nbsp;</a></span>SymbType_get_array_lower_bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SymbType_get_array_lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get array lower bound. </p>

</div>
</div>
<a id="ad31f5f7303c83cdf2c36c1ef892639f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31f5f7303c83cdf2c36c1ef892639f1">&#9670;&nbsp;</a></span>SymbType_get_array_subtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> SymbType_get_array_subtype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get inner type of an array. </p>
<p>The returned pointer belongs to the ginven SymbType_ptr and must not be freed </p>

</div>
</div>
<a id="aecb3d24a11fd8bd0ec489f14860fa816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb3d24a11fd8bd0ec489f14860fa816">&#9670;&nbsp;</a></span>SymbType_get_array_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SymbType_get_array_upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get array upper bound. </p>

</div>
</div>
<a id="a05955b2f4074020658ace8c522614bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05955b2f4074020658ace8c522614bec">&#9670;&nbsp;</a></span>SymbType_get_enum_type_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr SymbType_get_enum_type_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the list of values of an enum type. </p>
<p>The given type has to be a ENUM type. The return list is a list of all possible values of a enum type. This list was provided during construction.</p>
<p>NB: Memory sharing types do not have particular values, since they are "simplified". </p>

</div>
</div>
<a id="a86631ffd888cb9dae694ffe5ab34ffdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86631ffd888cb9dae694ffe5ab34ffdd">&#9670;&nbsp;</a></span>SymbType_get_intarray_subtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> SymbType_get_intarray_subtype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get inner type of an array. </p>
<p>The returned pointer belongs to the ginven SymbType_ptr and must not be freed </p>

</div>
</div>
<a id="ac4c7fa84f47152a14e3834f70c1e5d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c7fa84f47152a14e3834f70c1e5d29">&#9670;&nbsp;</a></span>SymbType_get_nfunction_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="NFunction_8h.html#afb16a75c5ac381374d42968419203c35">NFunction_ptr</a> SymbType_get_nfunction_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of an <a class="el" href="structNFunction.html" title="Public interface of class &#39;NFunction&#39;. ">NFunction</a>. </p>
<p>The given type has to be an <a class="el" href="structNFunction.html" title="Public interface of class &#39;NFunction&#39;. ">NFunction</a> type. The return value contains the function definiction. </p>

</div>
</div>
<a id="a30107daf1b66d13e8905418dbf8be6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30107daf1b66d13e8905418dbf8be6ce">&#9670;&nbsp;</a></span>SymbType_get_tag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SymbType_8h.html#adaf8202d5694b0f9a242fa7f81add90a">SymbTypeTag</a> SymbType_get_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tag (the kind) of the type. </p>

</div>
</div>
<a id="a6a0ba3c88fd4989194ce7e6559415aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0ba3c88fd4989194ce7e6559415aa0">&#9670;&nbsp;</a></span>SymbType_get_word_line_number()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SymbType_get_word_line_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the line number where the type was declared. </p>
<p>The body of the type, provided during construction, is a node NUMBER specifying the width of the Word or a node CONS specifying the address-value widths or WordArray. This node was create during parsing and contains the line number of the type declaration. NB: The type should not be memory-sharing. NB: Virtually this function is used only in TypeChecker_is_type_wellformed</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a> </dd></dl>

</div>
</div>
<a id="ae1b76d53e4e93a5edd9371f55a9fa285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b76d53e4e93a5edd9371f55a9fa285">&#9670;&nbsp;</a></span>SymbType_get_word_width()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SymbType_get_word_width </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the width of a Word type. </p>
<p>The given type should be Word and the body of the type (given to the constructor) should be NUMBER node. </p>

</div>
</div>
<a id="a39f79fc1d359dd1ea0ba64c4dfcc7859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f79fc1d359dd1ea0ba64c4dfcc7859">&#9670;&nbsp;</a></span>SymbType_get_wordarray_awidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SymbType_get_wordarray_awidth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the width of the address in a WordArray type. </p>

</div>
</div>
<a id="a8ff9ca74cef23f2017a80475a6956d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff9ca74cef23f2017a80475a6956d9c">&#9670;&nbsp;</a></span>SymbType_get_wordarray_subtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> SymbType_get_wordarray_subtype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the subtype of wordarray. </p>

</div>
</div>
<a id="ae761c10889d2cf6277d616ba6cb1ebe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae761c10889d2cf6277d616ba6cb1ebe8">&#9670;&nbsp;</a></span>SymbType_is_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the type is an array-type, or else returns false. </p>
<p>WARNING: Traces assumes this function returns true only for array defines </p>

</div>
</div>
<a id="a21d37b81549c5598bd0d7f54e6608282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d37b81549c5598bd0d7f54e6608282">&#9670;&nbsp;</a></span>SymbType_is_boolean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_boolean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the type is boolean. Otherwise - returns false. </p>
<p>The kind of enum-type is analysed in the constructor.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a> </dd></dl>

</div>
</div>
<a id="ad011fda6eacffa8960dd9e79e2764bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad011fda6eacffa8960dd9e79e2764bf1">&#9670;&nbsp;</a></span>SymbType_is_continuous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_continuous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the type is a continuous type, or else returns false. </p>

</div>
</div>
<a id="ae0e23b36cb8ec64eaaaefb38e130a6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e23b36cb8ec64eaaaefb38e130a6a4">&#9670;&nbsp;</a></span>SymbType_is_enum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_enum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the type is a enum-type, or else returns false. </p>

</div>
</div>
<a id="ad537b377ad24a1ffb66a81ed7f67b827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad537b377ad24a1ffb66a81ed7f67b827">&#9670;&nbsp;</a></span>SymbType_is_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the type is a error-type, and false otherwise. </p>
<p>Error type is used to indicate an error</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a> </dd></dl>

</div>
</div>
<a id="a7fc2de1400ddb8e31bb37d093c5c7a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc2de1400ddb8e31bb37d093c5c7a8e">&#9670;&nbsp;</a></span>SymbType_is_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the type is an uninterpreted function type. </p>

</div>
</div>
<a id="af61d3f1e2811bb7cbe847d3468209303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61d3f1e2811bb7cbe847d3468209303">&#9670;&nbsp;</a></span>SymbType_is_infinite_precision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_infinite_precision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the type is one of infinite-precision types. </p>
<p>Infinite-precision types are such as integer and real.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a> </dd></dl>

</div>
</div>
<a id="a2834f3052ffed41a0f77e8025a486c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2834f3052ffed41a0f77e8025a486c92">&#9670;&nbsp;</a></span>SymbType_is_int_symbolic_enum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_int_symbolic_enum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the type is a enum-type and its value are symbolic AND integer constants. Otherwise - returns false. </p>
<p>The kind of enum-type is analysed in the constructor.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a> </dd></dl>

</div>
</div>
<a id="ab4759c817447425ca592d41749727f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4759c817447425ca592d41749727f94">&#9670;&nbsp;</a></span>SymbType_is_intarray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_intarray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the type is intarray, or else returns false. </p>

</div>
</div>
<a id="aeeda085c043506fa2365ae89f713e6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeda085c043506fa2365ae89f713e6e5">&#9670;&nbsp;</a></span>SymbType_is_integer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the type is a integer-type, or else returns false. </p>

</div>
</div>
<a id="ac986bd4dea4ddfe1d74192b89ea7fa92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac986bd4dea4ddfe1d74192b89ea7fa92">&#9670;&nbsp;</a></span>SymbType_is_memory_shared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_memory_shared </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if and only if the given type is memory shared. </p>

</div>
</div>
<a id="a33d8be43d19a0272033f98741efb71b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d8be43d19a0272033f98741efb71b9">&#9670;&nbsp;</a></span>SymbType_is_pure_int_enum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_pure_int_enum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the type is a enum-type and its value are integers only. Otherwise - returns false. </p>
<p>The kind of enum-type is analysed in the constructor.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a> </dd></dl>

</div>
</div>
<a id="aaf887daca0522f8fe29ac3f34efffad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf887daca0522f8fe29ac3f34efffad3">&#9670;&nbsp;</a></span>SymbType_is_pure_symbolic_enum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_pure_symbolic_enum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the type is a enum-type and its value are symbolic constants only. Otherwise - returns false. </p>
<p>The kind of enum-type is analysed in the constructor.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a> </dd></dl>

</div>
</div>
<a id="a872921ea90ef19798f7b62e83729c699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872921ea90ef19798f7b62e83729c699">&#9670;&nbsp;</a></span>SymbType_is_real()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_real </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the type is a real-type, or else returns false. </p>

</div>
</div>
<a id="ad6766289626e2752cf0fcc7c91467e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6766289626e2752cf0fcc7c91467e0c">&#9670;&nbsp;</a></span>SymbType_is_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the type is one of the set-types, i.e. boolean-set, integer-set, symbolic-set, integer-symbolic-set, and false otherwise. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a> </dd></dl>

</div>
</div>
<a id="a45af09319a7008cb5ee947267e9e32d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45af09319a7008cb5ee947267e9e32d5">&#9670;&nbsp;</a></span>SymbType_is_signed_word()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_signed_word </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the type is a signed Word type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a> </dd></dl>

</div>
</div>
<a id="aacfbfd850e6c6ef8573fb03e65168f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfbfd850e6c6ef8573fb03e65168f70">&#9670;&nbsp;</a></span>SymbType_is_single_value_enum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_single_value_enum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if it is enum and with just one value. </p>

</div>
</div>
<a id="a60b90f10705dcebbc607f1c26ed81180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b90f10705dcebbc607f1c26ed81180">&#9670;&nbsp;</a></span>SymbType_is_statement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_statement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the type is a statement-type, and false otherwise. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a> </dd></dl>

</div>
</div>
<a id="a7a9d3ec42249fb45cce192e1b39a50ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9d3ec42249fb45cce192e1b39a50ad">&#9670;&nbsp;</a></span>SymbType_is_unsigned_word()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_unsigned_word </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the type is an unsigned Word type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a> </dd></dl>

</div>
</div>
<a id="a39e2aec84dd6322667e9a8c6f96aea5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e2aec84dd6322667e9a8c6f96aea5c">&#9670;&nbsp;</a></span>SymbType_is_word()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_word </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the type is a Word type (signed or unsigned) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a> </dd></dl>

</div>
</div>
<a id="afda34c5f36433ad5bdc0846a83a1ad9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda34c5f36433ad5bdc0846a83a1ad9e">&#9670;&nbsp;</a></span>SymbType_is_word_1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_word_1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the type is a Unsigned Word type and the width of the word is 1. Otherwise - returns false. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#af113ecf6b22aaf868a5f3f9a46842840" title="Class SymbType constructor. ">SymbType_create</a> </dd></dl>

</div>
</div>
<a id="a8a24e446d4723692fd45c8482a9be1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a24e446d4723692fd45c8482a9be1f1">&#9670;&nbsp;</a></span>SymbType_is_wordarray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SymbType_is_wordarray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given type is a wordarray. </p>

</div>
</div>
<a id="a960e008b1974f7c80243de4f4b4f7d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960e008b1974f7c80243de4f4b4f7d40">&#9670;&nbsp;</a></span>SymbType_make_from_set_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> SymbType_make_from_set_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is opposite to SymbType_make_set_type, i.e. if the given type is one of the set-types, then the type without "set" suffix is returned. Otherwise the type is returned without change. </p>
<p>More precisely the following conversion takes place: boolean-set -&gt; boolean integer-set -&gt;integer symbolic-set -&gt; symbolic-enum integer-symbolic-set -&gt; integer-symbolic-set another type -&gt; the same type</p>
<p>The implicit conversion is performed in accordance to the type order. NOTE: only memory-shared types can be given to this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#a3b2f4cfba1f2d3ae4057be9e7ceafab2" title="Returns a minimal set-type which the given type can be implicitly converted to, or NULL if this is im...">SymbType_make_set_type</a> </dd></dl>

</div>
</div>
<a id="a752b9604559ddc098ae67a7f2a98a9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752b9604559ddc098ae67a7f2a98a9f7">&#9670;&nbsp;</a></span>SymbType_make_memory_shared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> SymbType_make_memory_shared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function takes a NOT memory shared type and returns a memory shared one. </p>
<p>The input type should have a corresponding memory shared type. For example, function type and error type do not have memory shared instances. </p>

</div>
</div>
<a id="a3b2f4cfba1f2d3ae4057be9e7ceafab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2f4cfba1f2d3ae4057be9e7ceafab2">&#9670;&nbsp;</a></span>SymbType_make_set_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> SymbType_make_set_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a minimal set-type which the given type can be implicitly converted to, or NULL if this is impossible. </p>
<p>The implicit conversion is performed in accordance to the type order. NOTE: only memory-shared types can be given to this function.</p>
<dl class="section see"><dt>See also</dt><dd>SymbType_make_type_from_set_type </dd></dl>

</div>
</div>
<a id="a2aa008effa8935971b6949c7dfd9c95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa008effa8935971b6949c7dfd9c95b">&#9670;&nbsp;</a></span>SymbType_print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SymbType_print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MasterPrinter_8h.html#adefcbfb8d647308a7dfd66842759df62">MasterPrinter_ptr</a>&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>output_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the type structure to the output stream. </p>
<p>This function is made very similar to print_node. If a Enum type was created with SymbType_create then all its values will be printed, otherwise the type was created with SymbTablePkg_..._type and simplified type name (instead of actual type values) is printed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#aa5834716de187ca5a5c63f234f4f2f1c" title="Return a string representation of the given type. ">SymbType_sprint</a> </dd></dl>

</div>
</div>
<a id="aa5834716de187ca5a5c63f234f4f2f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5834716de187ca5a5c63f234f4f2f1c">&#9670;&nbsp;</a></span>SymbType_sprint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SymbType_sprint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MasterPrinter_8h.html#adefcbfb8d647308a7dfd66842759df62">MasterPrinter_ptr</a>&#160;</td>
          <td class="paramname"><em>printer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a string representation of the given type. </p>
<p>This function is made very similar to sprint_node. If an Enum type was created with SymbType_create then all its values will be printed, otherwise the type was created with SymbTablePkg_..._type and simplified type name (instead of actual type values) is printed.</p>
<p>The returned string must be released by the caller.</p>
<p>The returned string is allocated and has to be released by the caller</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSymbType.html#a2aa008effa8935971b6949c7dfd9c95b" title="Prints the type structure to the output stream. ">SymbType_print</a> </dd></dl>

</div>
</div>
<a id="ab237b0d5c1efc033c43d03d2a33a2362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab237b0d5c1efc033c43d03d2a33a2362">&#9670;&nbsp;</a></span>SymbType_to_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr SymbType_to_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NodeMgr_8h.html#a7f6ea9987bf1e8bb6897e86cb4b5c1a0">NodeMgr_ptr</a>&#160;</td>
          <td class="paramname"><em>nodemgr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a node representing a type. </p>
<p>The node returned is what is expected by the <a class="el" href="structHrcNode.html" title="Private and protected interface of class &#39;HrcNode&#39;. ">HrcNode</a> and other data structures. Currently, only types that can be assigned to variables are supported. Hence, it is an error to call this function with the following SymbTypes: Statement <a class="el" href="structSet.html" title="Generic Set Data Structure. ">Set</a> String </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>/root/research/NuSMV-2.6.0/NuSMV/code/nusmv/core/compile/symb_table/<a class="el" href="SymbType_8h_source.html">SymbType.h</a></li>
<li>/root/research/NuSMV-2.6.0/NuSMV/code/nusmv/core/compile/symb_table/<a class="el" href="SymbType__private_8h_source.html">SymbType_private.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 18 2022 22:26:37 for NuSMV Developers Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
