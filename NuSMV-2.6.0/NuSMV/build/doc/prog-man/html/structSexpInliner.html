<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NuSMV Developers Manual: SexpInliner Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NuSMV Developers Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">SexpInliner Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="structSexpInliner.html" title="The SexpInliner API. ">SexpInliner</a> API.  
 <a href="structSexpInliner.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SexpInliner_8h_source.html">SexpInliner.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a34b19f4e1824a9ad45fee5faf9f01e98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSexpInliner.html#a34b19f4e1824a9ad45fee5faf9f01e98">SexpInliner_blacklist_name</a> (<a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a> self, node_ptr var)</td></tr>
<tr class="memdesc:a34b19f4e1824a9ad45fee5faf9f01e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds to the blacklist the given name.  <a href="#a34b19f4e1824a9ad45fee5faf9f01e98">More...</a><br /></td></tr>
<tr class="separator:a34b19f4e1824a9ad45fee5faf9f01e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1a395f64e83229830a45bb7e80a627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSexpInliner.html#a9a1a395f64e83229830a45bb7e80a627">SexpInliner_clear_blacklist</a> (<a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a> self)</td></tr>
<tr class="memdesc:a9a1a395f64e83229830a45bb7e80a627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the internal set of blacklisted names.  <a href="#a9a1a395f64e83229830a45bb7e80a627">More...</a><br /></td></tr>
<tr class="separator:a9a1a395f64e83229830a45bb7e80a627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f77c6528cc7e96f1c3f4747473e5f95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSexpInliner.html#a2f77c6528cc7e96f1c3f4747473e5f95">SexpInliner_clear_equivalences</a> (<a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a> self)</td></tr>
<tr class="memdesc:a2f77c6528cc7e96f1c3f4747473e5f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the internal cache of forced equivalences.  <a href="#a2f77c6528cc7e96f1c3f4747473e5f95">More...</a><br /></td></tr>
<tr class="separator:a2f77c6528cc7e96f1c3f4747473e5f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ef7f7de27a6bfe13d4be4f882ab9ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSexpInliner.html#a10ef7f7de27a6bfe13d4be4f882ab9ee">SexpInliner_clear_invariants</a> (<a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a> self)</td></tr>
<tr class="memdesc:a10ef7f7de27a6bfe13d4be4f882ab9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the internal cache of forced invariants.  <a href="#a10ef7f7de27a6bfe13d4be4f882ab9ee">More...</a><br /></td></tr>
<tr class="separator:a10ef7f7de27a6bfe13d4be4f882ab9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be957e11b5fa509a39be1f7372e1bfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSexpInliner.html#a7be957e11b5fa509a39be1f7372e1bfe">SexpInliner_copy</a> (const <a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a> self)</td></tr>
<tr class="memdesc:a7be957e11b5fa509a39be1f7372e1bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy costructor.  <a href="#a7be957e11b5fa509a39be1f7372e1bfe">More...</a><br /></td></tr>
<tr class="separator:a7be957e11b5fa509a39be1f7372e1bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a4ea64520e9cde3401d8bba76f0aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSexpInliner.html#a94a4ea64520e9cde3401d8bba76f0aa9">SexpInliner_create</a> (<a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a> st, const size_t fixpoint_limit)</td></tr>
<tr class="memdesc:a94a4ea64520e9cde3401d8bba76f0aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sexp Inliner constructor.  <a href="#a94a4ea64520e9cde3401d8bba76f0aa9">More...</a><br /></td></tr>
<tr class="separator:a94a4ea64520e9cde3401d8bba76f0aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534a281c16615e060147b0a2cd7ab208"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSexpInliner.html#a534a281c16615e060147b0a2cd7ab208">SexpInliner_destroy</a> (<a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a> self)</td></tr>
<tr class="memdesc:a534a281c16615e060147b0a2cd7ab208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a534a281c16615e060147b0a2cd7ab208">More...</a><br /></td></tr>
<tr class="separator:a534a281c16615e060147b0a2cd7ab208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b02482a4f55a8f1cc201eeea3a33a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSexpInliner.html#a50b02482a4f55a8f1cc201eeea3a33a0">SexpInliner_force_equivalence</a> (<a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a> self, node_ptr var, <a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a> expr)</td></tr>
<tr class="memdesc:a50b02482a4f55a8f1cc201eeea3a33a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces to learn that var (can be timed) and expr are equivalent. The expression is assumed to be already flattened, and defines expanded.  <a href="#a50b02482a4f55a8f1cc201eeea3a33a0">More...</a><br /></td></tr>
<tr class="separator:a50b02482a4f55a8f1cc201eeea3a33a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e81f9ceec1f0c84640f06b5dbcd967a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSexpInliner.html#a8e81f9ceec1f0c84640f06b5dbcd967a">SexpInliner_force_equivalences</a> (<a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a> self, <a class="el" href="set_8h.html#a0beb5bfe44c73e9239f023bde8a305b2">Set_t</a> equivs)</td></tr>
<tr class="memdesc:a8e81f9ceec1f0c84640f06b5dbcd967a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces to learn all equivalences in given set.  <a href="#a8e81f9ceec1f0c84640f06b5dbcd967a">More...</a><br /></td></tr>
<tr class="separator:a8e81f9ceec1f0c84640f06b5dbcd967a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bba7fae5453dc669cac53ee67d2eb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSexpInliner.html#a58bba7fae5453dc669cac53ee67d2eb1">SexpInliner_force_invariant</a> (<a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a> self, node_ptr var, <a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a> expr)</td></tr>
<tr class="memdesc:a58bba7fae5453dc669cac53ee67d2eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces to learn that var and expr are invariantly equivalent.  <a href="#a58bba7fae5453dc669cac53ee67d2eb1">More...</a><br /></td></tr>
<tr class="separator:a58bba7fae5453dc669cac53ee67d2eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd46a81636ec4895f8aeac8a4eaa563"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSexpInliner.html#affd46a81636ec4895f8aeac8a4eaa563">SexpInliner_force_invariants</a> (<a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a> self, <a class="el" href="set_8h.html#a0beb5bfe44c73e9239f023bde8a305b2">Set_t</a> invars)</td></tr>
<tr class="memdesc:affd46a81636ec4895f8aeac8a4eaa563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces to learn all invariants in given set.  <a href="#affd46a81636ec4895f8aeac8a4eaa563">More...</a><br /></td></tr>
<tr class="separator:affd46a81636ec4895f8aeac8a4eaa563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88054c71d9e8f1f4af1c30403b146d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSexpInliner.html#ac88054c71d9e8f1f4af1c30403b146d0">SexpInliner_get_symb_table</a> (const <a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a> self)</td></tr>
<tr class="memdesc:ac88054c71d9e8f1f4af1c30403b146d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the symbol table that is connected to the <a class="el" href="structBoolEnc.html" title="Private and protected interface of class &#39;BoolEnc&#39;. ">BoolEnc</a> instance connected to self.  <a href="#ac88054c71d9e8f1f4af1c30403b146d0">More...</a><br /></td></tr>
<tr class="separator:ac88054c71d9e8f1f4af1c30403b146d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822a41c370c0daa5beb9df5a19de7c8d"><td class="memItemLeft" align="right" valign="top">hash_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSexpInliner.html#a822a41c370c0daa5beb9df5a19de7c8d">SexpInliner_get_var2expr_hash</a> (<a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a> self)</td></tr>
<tr class="memdesc:a822a41c370c0daa5beb9df5a19de7c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal var2expr hash.  <a href="#a822a41c370c0daa5beb9df5a19de7c8d">More...</a><br /></td></tr>
<tr class="separator:a822a41c370c0daa5beb9df5a19de7c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d014dbe9c2769d5763a85b43334552"><td class="memItemLeft" align="right" valign="top">hash_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSexpInliner.html#a21d014dbe9c2769d5763a85b43334552">SexpInliner_get_var2invar_hash</a> (<a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a> self)</td></tr>
<tr class="memdesc:a21d014dbe9c2769d5763a85b43334552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal var2invar hash.  <a href="#a21d014dbe9c2769d5763a85b43334552">More...</a><br /></td></tr>
<tr class="separator:a21d014dbe9c2769d5763a85b43334552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c8116b9ff200b8ff27776707905cda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SexpInliner_8h.html#a41efe0072cb4be62ef5968288ff83175">InlineRes_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSexpInliner.html#ac4c8116b9ff200b8ff27776707905cda">SexpInliner_inline</a> (<a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a> self, <a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a> expr, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> *changed)</td></tr>
<tr class="memdesc:ac4c8116b9ff200b8ff27776707905cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs inlining of given expression.  <a href="#ac4c8116b9ff200b8ff27776707905cda">More...</a><br /></td></tr>
<tr class="separator:ac4c8116b9ff200b8ff27776707905cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773593743515c52c0b982d52a20e43db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSexpInliner.html#a773593743515c52c0b982d52a20e43db">SexpInliner_inline_no_learning</a> (<a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a> self, <a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a> expr, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> *changed)</td></tr>
<tr class="memdesc:a773593743515c52c0b982d52a20e43db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs inlining of given expression.  <a href="#a773593743515c52c0b982d52a20e43db">More...</a><br /></td></tr>
<tr class="separator:a773593743515c52c0b982d52a20e43db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="structSexpInliner.html" title="The SexpInliner API. ">SexpInliner</a> API. </p>
<dl class="section author"><dt>Author</dt><dd>Roberto Cavada Class <a class="el" href="structSexpInliner.html" title="The SexpInliner API. ">SexpInliner</a> declaration</dd></dl>
<p>The <a class="el" href="structSexpInliner.html" title="The SexpInliner API. ">SexpInliner</a> type</p>
<p>The <a class="el" href="structSexpInliner.html" title="The SexpInliner API. ">SexpInliner</a> type </p>
</div><h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a34b19f4e1824a9ad45fee5faf9f01e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b19f4e1824a9ad45fee5faf9f01e98">&#9670;&nbsp;</a></span>SexpInliner_blacklist_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SexpInliner_blacklist_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds to the blacklist the given name. </p>
<p>Any name occurring in the blacklist will be not substituted. Use to avoid inlining a set of variables. </p>

</div>
</div>
<a id="a9a1a395f64e83229830a45bb7e80a627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1a395f64e83229830a45bb7e80a627">&#9670;&nbsp;</a></span>SexpInliner_clear_blacklist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SexpInliner_clear_blacklist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the internal set of blacklisted names. </p>

</div>
</div>
<a id="a2f77c6528cc7e96f1c3f4747473e5f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f77c6528cc7e96f1c3f4747473e5f95">&#9670;&nbsp;</a></span>SexpInliner_clear_equivalences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SexpInliner_clear_equivalences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the internal cache of forced equivalences. </p>

</div>
</div>
<a id="a10ef7f7de27a6bfe13d4be4f882ab9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ef7f7de27a6bfe13d4be4f882ab9ee">&#9670;&nbsp;</a></span>SexpInliner_clear_invariants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SexpInliner_clear_invariants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the internal cache of forced invariants. </p>

</div>
</div>
<a id="a7be957e11b5fa509a39be1f7372e1bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be957e11b5fa509a39be1f7372e1bfe">&#9670;&nbsp;</a></span>SexpInliner_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a> SexpInliner_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy costructor. </p>

</div>
</div>
<a id="a94a4ea64520e9cde3401d8bba76f0aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a4ea64520e9cde3401d8bba76f0aa9">&#9670;&nbsp;</a></span>SexpInliner_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a> SexpInliner_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a>&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>fixpoint_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sexp Inliner constructor. </p>
<p>fixpoint_limit is a integer bound controlling the maximum number of iteration to be carried out when inlining an expression. Use 0 (zero) for no limit. </p>

</div>
</div>
<a id="a534a281c16615e060147b0a2cd7ab208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534a281c16615e060147b0a2cd7ab208">&#9670;&nbsp;</a></span>SexpInliner_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SexpInliner_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a id="a50b02482a4f55a8f1cc201eeea3a33a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b02482a4f55a8f1cc201eeea3a33a0">&#9670;&nbsp;</a></span>SexpInliner_force_equivalence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SexpInliner_force_equivalence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces to learn that var (can be timed) and expr are equivalent. The expression is assumed to be already flattened, and defines expanded. </p>
<p>The equivalence is learnt even if given name is blacklisted. The equivalence substitutes any previously forced equivalence about the same variable. Returns true if the equivalence was accepted, or false otherwise. </p>

</div>
</div>
<a id="a8e81f9ceec1f0c84640f06b5dbcd967a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e81f9ceec1f0c84640f06b5dbcd967a">&#9670;&nbsp;</a></span>SexpInliner_force_equivalences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SexpInliner_force_equivalences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="set_8h.html#a0beb5bfe44c73e9239f023bde8a305b2">Set_t</a>&#160;</td>
          <td class="paramname"><em>equivs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces to learn all equivalences in given set. </p>
<p>There is an implicit assumption about the format of each element in the set. It must be either a EQUAL, a EQDEF or a IFF node where left operand is a variable. This method may be useful to force equivalences previously returned by a <a class="el" href="structInlineRes.html" title="Inliner result type. ">InlineRes</a> instance.</p>
<p>Returns true if any equivalence was accepted, false if all were rejected </p>

</div>
</div>
<a id="a58bba7fae5453dc669cac53ee67d2eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58bba7fae5453dc669cac53ee67d2eb1">&#9670;&nbsp;</a></span>SexpInliner_force_invariant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SexpInliner_force_invariant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces to learn that var and expr are invariantly equivalent. </p>
<p>var must be a flat variable name (not nexted not timed). The expression is assumed to be already flattened. The invariant is learnt even if given name is blacklisted. The invariant substitutes any previously forced invariant about the same variable.</p>
<p>Returns true if the invariant was successfully forced, or false otherwise. </p>

</div>
</div>
<a id="affd46a81636ec4895f8aeac8a4eaa563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd46a81636ec4895f8aeac8a4eaa563">&#9670;&nbsp;</a></span>SexpInliner_force_invariants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> SexpInliner_force_invariants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="set_8h.html#a0beb5bfe44c73e9239f023bde8a305b2">Set_t</a>&#160;</td>
          <td class="paramname"><em>invars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces to learn all invariants in given set. </p>
<p>There is an implicit assumption about the format of each element in the set. It must be either a EQUAL, a EQDEF, or a IFF node where left operand is a variable. This method may be useful to force invariants previously returned by a <a class="el" href="structInlineRes.html" title="Inliner result type. ">InlineRes</a> instance.</p>
<p>Returns true if any invariant was accepted, false if all were rejected </p>

</div>
</div>
<a id="ac88054c71d9e8f1f4af1c30403b146d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88054c71d9e8f1f4af1c30403b146d0">&#9670;&nbsp;</a></span>SexpInliner_get_symb_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a> SexpInliner_get_symb_table </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the symbol table that is connected to the <a class="el" href="structBoolEnc.html" title="Private and protected interface of class &#39;BoolEnc&#39;. ">BoolEnc</a> instance connected to self. </p>

</div>
</div>
<a id="a822a41c370c0daa5beb9df5a19de7c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822a41c370c0daa5beb9df5a19de7c8d">&#9670;&nbsp;</a></span>SexpInliner_get_var2expr_hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hash_ptr SexpInliner_get_var2expr_hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the internal var2expr hash. </p>
<p>Get the internal var2expr hash. Do not perform any side-effects on this hash </p>

</div>
</div>
<a id="a21d014dbe9c2769d5763a85b43334552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d014dbe9c2769d5763a85b43334552">&#9670;&nbsp;</a></span>SexpInliner_get_var2invar_hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hash_ptr SexpInliner_get_var2invar_hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the internal var2invar hash. </p>
<p>Get the internal var2invar hash. Do not perform any side-effects on this hash </p>

</div>
</div>
<a id="ac4c8116b9ff200b8ff27776707905cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c8116b9ff200b8ff27776707905cda">&#9670;&nbsp;</a></span>SexpInliner_inline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SexpInliner_8h.html#a41efe0072cb4be62ef5968288ff83175">InlineRes_ptr</a> SexpInliner_inline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> *&#160;</td>
          <td class="paramname"><em>changed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs inlining of given expression. </p>
<p>Applies inlining to the given expression, with fixpoint. </p><pre class="fragment">           Returned InlineRes object contains the
           result. Returned instance must be destroyed by the
           caller. If given variable changed is not NULL, it
           will be set to true if any inlining has been
           applied, or will be set to false if no inlining
           has been applied.

           Before carrying out the actual inlining, this
           method learn automatically equivalences out of the
           given formula.

           WARNING: The expression is assumed to be already
           flattened, and normalized (all nodes created with
           find_node)</pre> 
</div>
</div>
<a id="a773593743515c52c0b982d52a20e43db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773593743515c52c0b982d52a20e43db">&#9670;&nbsp;</a></span>SexpInliner_inline_no_learning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a> SexpInliner_inline_no_learning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SexpInliner_8h.html#a720f3f169126a175bcff2f783b61b255">SexpInliner_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ExprMgr_8h.html#aca18dbbe4788d6b630562ac63b3510e0">Expr_ptr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> *&#160;</td>
          <td class="paramname"><em>changed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs inlining of given expression. </p>
<p>Applies inlining to the given expression, with fixpoint, and returns the result expression.</p>
<p>If given variable changed is not NULL, it will be set to true if any inlining has been applied, or will be set to false if no inlining has been applied.</p>
<p>Before carrying out the actual inlining, this method learn automatically equivalences out of the given formula. [MD] Is this comment wrong? Simply cut and paste from the method [MD] SexpInliner_inline?</p>
<p>WARNING: The expression is assumed to be already flattened, and normalized (all nodes created with find_node)</p>
<p>SexpInliner_inline </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/root/research/NuSMV-2.6.0/NuSMV/code/nusmv/core/sexp/<a class="el" href="SexpInliner_8h_source.html">SexpInliner.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 18 2022 22:26:36 for NuSMV Developers Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
