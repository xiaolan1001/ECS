<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NuSMV Developers Manual: Set Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NuSMV Developers Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Set Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic <a class="el" href="structSet.html" title="Generic Set Data Structure. ">Set</a> Data Structure.  
 <a href="structSet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="set_8h_source.html">set.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic <a class="el" href="structSet.html" title="Generic Set Data Structure. ">Set</a> Data Structure. </p>
<dl class="section author"><dt>Author</dt><dd>Marco Roveri This package provides an implementation of sets. It is possible to perform the test of equality among two sets in constant time by simply comparing the two sets. Thus it is possible to check if a union has increased the cardinality of a set inserting elements in one of the two operands by simply comparing the result of the union among the operands.</dd></dl>
<p>Structure for ordered sets</p>
<p>Sets are containers for elements that cannot occur into them more then once. Sets can be travered through iterators, and chronological ordering which elements are inserted into them is preserved when travered. A set can be frozen at time t, meaning that that the set cannot be later changed until the set is destroyed. Freezing a set make that set unchangeble in time, and allows for more efficient operations like set copy. Copying a frozen set has the only effect of incrementing a reference counting for that set, without any need for actually copying the set content. Freezing a set whose content does not need to be changed later on is therefore always a good idea to make set operations and memory usage more efficient.</p>
<p>It is also important to mark that when storing a set in memory (e.g. in memoized operations, like in dependencies hashes) it is needed to freeze the set, otherwise external code might change the set content with side-effect with weird results, as explained below..</p>
<p>Operations like AddMember, RemoveMember, Union, Difference, etc. do not create a new set, instead they modify the set they are applied to. For example given two sets S1 and S2, S1 U S2 (set union) can be obtained by calling</p>
<p>Set_Union(S1, S2)</p>
<p>If S1 is not a frozen set, the result goes to S1 (with side-effect), and no copy is performed. If S1 is frozen, S1 is copied to a new set S1' and then side effect is performed on S1' to add members in S2. All this operation is carried out automatically in a transparent manner, but it is required that operations that modify sets all returns a set that can be different from the set they are applied to. The returned value has to be assigned to a variable. The right set protocol then requires an explicit assignment:</p>
<p>S1 = Set_Union(S1, S2)</p>
<p>To save memory the empty set is represented with a NULL pointer, that is another reason why an explicit assigment is required, and that justify the fact that in general S1 and S1' may be different.</p>
<p>When a set is no longer used, it has to be freed with method ReleaseSet. This either frees the set and the memory it uses, or decreases the set's reference counting.</p>
<p>Reference counting is applied only for frozen sets. When a frozen set is copied its reference counting is incremented. When a frozen set is released, the reference counting is decremented and the set is freed only if its reference counting reaches the value of 0, meaning that there are no longer users of that set.</p>
<p>Notice that in previous operation:</p>
<p>S1 = Set_Union(S1, S2)</p>
<p>If S1 is a frozen set, this is the sequence of actions that are involved:</p>
<ol type="1">
<li>S1 is copied into a temporary set S1'</li>
<li>S1' is unioned with S2 (with side-effect on S1')</li>
<li>S1 is released (and possibly freed if needed)</li>
<li>S1' is returned as a new non-frozen set and assigned to S1.</li>
</ol>
<p>Pass 3 is remarkable here. Suppose that a set is stored into a permanent memory area (like a cache, a hash, etc.). When storing the set, it has to be frozen and a carefully reference counting has to be takein into account. When looking up previously stored set and returning that set (e.g. in memoizing) is is important to return a copy of the (frozen) set, and explicitly ask the user to release the returned set when no longer used. This prevents previous step 3 to release sets that are still in usage for example inside the cache. For example:</p>
<p>Set_t s1 = some_memoizing_function(); Set_t s2 = Set_AddMember(s1, element); ... Set_ReleaseSet(s2);</p>
<p>Here s2 is different from s1 (as s1 is frozen and AddMember would change it otherwise). Even if function some_memoizing_function requires the user to release returned set, there is no need to release s1 (and in fact you do not have to, or you have a bug). This allows to write second line Set_t s2 = ... as:</p>
<p>s1 = Set_AddMember(s1, element);</p>
<p>At the end you will have only to release s1 (as prescribed by function some_memoizing_function) </p>
</div><hr/>The documentation for this struct was generated from the following file:<ul>
<li>/root/research/NuSMV-2.6.0/NuSMV/code/nusmv/core/set/<a class="el" href="set_8h_source.html">set.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 18 2022 22:26:36 for NuSMV Developers Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
