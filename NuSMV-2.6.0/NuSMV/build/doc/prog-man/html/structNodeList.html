<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NuSMV Developers Manual: NodeList Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NuSMV Developers Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">NodeList Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The header file of <a class="el" href="structNodeList.html" title="The header file of NodeList class. ">NodeList</a> class.  
 <a href="structNodeList.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="NodeList_8h_source.html">NodeList.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a9a0822beeeefdd9d029257cbfd57ede5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#a9a0822beeeefdd9d029257cbfd57ede5">NodeList_append</a> (<a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self, node_ptr elem)</td></tr>
<tr class="memdesc:a9a0822beeeefdd9d029257cbfd57ede5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new node at the end of the list.  <a href="#a9a0822beeeefdd9d029257cbfd57ede5">More...</a><br /></td></tr>
<tr class="separator:a9a0822beeeefdd9d029257cbfd57ede5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00daaa2c57a7bc81123d4e217e3035b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#a00daaa2c57a7bc81123d4e217e3035b4">NodeList_belongs_to</a> (const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self, node_ptr elem)</td></tr>
<tr class="memdesc:a00daaa2c57a7bc81123d4e217e3035b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given element belongs to self.  <a href="#a00daaa2c57a7bc81123d4e217e3035b4">More...</a><br /></td></tr>
<tr class="separator:a00daaa2c57a7bc81123d4e217e3035b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d900bc58575b94f404131c81708e72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#a06d900bc58575b94f404131c81708e72">NodeList_concat</a> (<a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self, const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> src)</td></tr>
<tr class="memdesc:a06d900bc58575b94f404131c81708e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append all the elements in src to self.  <a href="#a06d900bc58575b94f404131c81708e72">More...</a><br /></td></tr>
<tr class="separator:a06d900bc58575b94f404131c81708e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e7fd25a3fbca6a9eb41a85ecb33d23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#a53e7fd25a3fbca6a9eb41a85ecb33d23">NodeList_concat_unique</a> (<a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self, const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> src)</td></tr>
<tr class="memdesc:a53e7fd25a3fbca6a9eb41a85ecb33d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append all the elements in src to self, but only if each element does not occur in self already.  <a href="#a53e7fd25a3fbca6a9eb41a85ecb33d23">More...</a><br /></td></tr>
<tr class="separator:a53e7fd25a3fbca6a9eb41a85ecb33d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33e6ec2d98343df86d1c258338b1993"><td class="memItemLeft" align="right" valign="top"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#af33e6ec2d98343df86d1c258338b1993">NodeList_copy</a> (<a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self)</td></tr>
<tr class="memdesc:af33e6ec2d98343df86d1c258338b1993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies self and returns a new independent instance.  <a href="#af33e6ec2d98343df86d1c258338b1993">More...</a><br /></td></tr>
<tr class="separator:af33e6ec2d98343df86d1c258338b1993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18885711b485e8bb2244159659493716"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#a18885711b485e8bb2244159659493716">NodeList_count_elem</a> (const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self, node_ptr elem)</td></tr>
<tr class="memdesc:a18885711b485e8bb2244159659493716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of occurrences of the given element.  <a href="#a18885711b485e8bb2244159659493716">More...</a><br /></td></tr>
<tr class="separator:a18885711b485e8bb2244159659493716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef41ba3789c250b4dc75a81ced372a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#abef41ba3789c250b4dc75a81ced372a9">NodeList_create</a> (void)</td></tr>
<tr class="memdesc:abef41ba3789c250b4dc75a81ced372a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new list.  <a href="#abef41ba3789c250b4dc75a81ced372a9">More...</a><br /></td></tr>
<tr class="separator:abef41ba3789c250b4dc75a81ced372a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b08ab7372329f61ff0344914ab44cd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#a1b08ab7372329f61ff0344914ab44cd6">NodeList_create_from_element</a> (node_ptr <a class="el" href="structnode.html">node</a>)</td></tr>
<tr class="memdesc:a1b08ab7372329f61ff0344914ab44cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a singleton nodelist.  <a href="#a1b08ab7372329f61ff0344914ab44cd6">More...</a><br /></td></tr>
<tr class="separator:a1b08ab7372329f61ff0344914ab44cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad453123b657e91cb13cd6b532e4cda19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#ad453123b657e91cb13cd6b532e4cda19">NodeList_create_from_list</a> (node_ptr list)</td></tr>
<tr class="memdesc:ad453123b657e91cb13cd6b532e4cda19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that creates a new <a class="el" href="structNodeList.html" title="The header file of NodeList class. ">NodeList</a> that is a wrapper of the given list.  <a href="#ad453123b657e91cb13cd6b532e4cda19">More...</a><br /></td></tr>
<tr class="separator:ad453123b657e91cb13cd6b532e4cda19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cd4e7a697127b4a1f1fd9bb9b488ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#ab9cd4e7a697127b4a1f1fd9bb9b488ad">NodeList_destroy</a> (<a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self)</td></tr>
<tr class="memdesc:ab9cd4e7a697127b4a1f1fd9bb9b488ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class destroyer.  <a href="#ab9cd4e7a697127b4a1f1fd9bb9b488ad">More...</a><br /></td></tr>
<tr class="separator:ab9cd4e7a697127b4a1f1fd9bb9b488ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fafa333c547808f4750365e9c4f945a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#a0fafa333c547808f4750365e9c4f945a">NodeList_filter</a> (const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self, <a class="el" href="NodeMgr_8h.html#a1bd310ecf7cc131e91db3f9bc71fce53">BPFN</a> foo)</td></tr>
<tr class="memdesc:a0fafa333c547808f4750365e9c4f945a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new list that contains all elements of self for which function foo returned true.  <a href="#a0fafa333c547808f4750365e9c4f945a">More...</a><br /></td></tr>
<tr class="separator:a0fafa333c547808f4750365e9c4f945a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4340bbac403b2abd5cc47346b9b78cef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#a4340bbac403b2abd5cc47346b9b78cef">NodeList_foreach</a> (<a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self, <a class="el" href="NodeList_8h.html#a353599f773119b73b9c2285f0e04b073">NODE_LIST_FOREACH_FUN_P</a> foo, void *user_data)</td></tr>
<tr class="memdesc:a4340bbac403b2abd5cc47346b9b78cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walks through the list, calling given funtion for each element.  <a href="#a4340bbac403b2abd5cc47346b9b78cef">More...</a><br /></td></tr>
<tr class="separator:a4340bbac403b2abd5cc47346b9b78cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b06a03834a0e53cc4f01b7b81b5212"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#ab6b06a03834a0e53cc4f01b7b81b5212">NodeList_get_elem_at</a> (const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self, const <a class="el" href="NodeList_8h.html#adc0e6ba89379ed636eadc5e6fa0b52b8">ListIter_ptr</a> iter)</td></tr>
<tr class="memdesc:ab6b06a03834a0e53cc4f01b7b81b5212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element at the position pointed by iter.  <a href="#ab6b06a03834a0e53cc4f01b7b81b5212">More...</a><br /></td></tr>
<tr class="separator:ab6b06a03834a0e53cc4f01b7b81b5212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee44b160d372c655b3ab4869e99aedf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="NodeList_8h.html#adc0e6ba89379ed636eadc5e6fa0b52b8">ListIter_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#adee44b160d372c655b3ab4869e99aedf">NodeList_get_first_iter</a> (const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self)</td></tr>
<tr class="memdesc:adee44b160d372c655b3ab4869e99aedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator pointing to the first element.  <a href="#adee44b160d372c655b3ab4869e99aedf">More...</a><br /></td></tr>
<tr class="separator:adee44b160d372c655b3ab4869e99aedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4cfa04632c977571cdbd1cc0a9bcd93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#af4cfa04632c977571cdbd1cc0a9bcd93">NodeList_get_length</a> (const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self)</td></tr>
<tr class="memdesc:af4cfa04632c977571cdbd1cc0a9bcd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the list.  <a href="#af4cfa04632c977571cdbd1cc0a9bcd93">More...</a><br /></td></tr>
<tr class="separator:af4cfa04632c977571cdbd1cc0a9bcd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dbed3812c77858d8f814abb76c9059"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#a24dbed3812c77858d8f814abb76c9059">NodeList_insert_after</a> (<a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self, <a class="el" href="NodeList_8h.html#adc0e6ba89379ed636eadc5e6fa0b52b8">ListIter_ptr</a> iter, node_ptr elem)</td></tr>
<tr class="memdesc:a24dbed3812c77858d8f814abb76c9059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given element after the node pointed by the given iterator.  <a href="#a24dbed3812c77858d8f814abb76c9059">More...</a><br /></td></tr>
<tr class="separator:a24dbed3812c77858d8f814abb76c9059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae379fdc2828a71df004762645c92621b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#ae379fdc2828a71df004762645c92621b">NodeList_insert_before</a> (<a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self, <a class="el" href="NodeList_8h.html#adc0e6ba89379ed636eadc5e6fa0b52b8">ListIter_ptr</a> iter, node_ptr elem)</td></tr>
<tr class="memdesc:ae379fdc2828a71df004762645c92621b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given element before the node pointed by the given iterator.  <a href="#ae379fdc2828a71df004762645c92621b">More...</a><br /></td></tr>
<tr class="separator:ae379fdc2828a71df004762645c92621b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef77eae5473dcfee98a447d6875ace0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#aef77eae5473dcfee98a447d6875ace0d">NodeList_is_empty</a> (const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self)</td></tr>
<tr class="memdesc:aef77eae5473dcfee98a447d6875ace0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the size of the list is 0.  <a href="#aef77eae5473dcfee98a447d6875ace0d">More...</a><br /></td></tr>
<tr class="separator:aef77eae5473dcfee98a447d6875ace0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb53d706da1ccddd02ccc09c42c6679"><td class="memItemLeft" align="right" valign="top"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#acdb53d706da1ccddd02ccc09c42c6679">NodeList_map</a> (const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self, <a class="el" href="NodeMgr_8h.html#a257a87e77d0b3f0885550f1318731736">NPFN</a> foo)</td></tr>
<tr class="memdesc:acdb53d706da1ccddd02ccc09c42c6679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new list that contains all elements of self, after applying function foo to each element.  <a href="#acdb53d706da1ccddd02ccc09c42c6679">More...</a><br /></td></tr>
<tr class="separator:acdb53d706da1ccddd02ccc09c42c6679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbc96b7d22ca021eeca1ccce2c24184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#a3bbc96b7d22ca021eeca1ccce2c24184">NodeList_prepend</a> (<a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self, node_ptr elem)</td></tr>
<tr class="memdesc:a3bbc96b7d22ca021eeca1ccce2c24184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends a new node at the beginning of the list.  <a href="#a3bbc96b7d22ca021eeca1ccce2c24184">More...</a><br /></td></tr>
<tr class="separator:a3bbc96b7d22ca021eeca1ccce2c24184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49bcfeb602ecc1b600dee0051d09e72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#af49bcfeb602ecc1b600dee0051d09e72">NodeList_print_nodes</a> (const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self, <a class="el" href="MasterPrinter_8h.html#adefcbfb8d647308a7dfd66842759df62">MasterPrinter_ptr</a> printer, FILE *out)</td></tr>
<tr class="memdesc:af49bcfeb602ecc1b600dee0051d09e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the nodes in the list, separated by spaces.  <a href="#af49bcfeb602ecc1b600dee0051d09e72">More...</a><br /></td></tr>
<tr class="separator:af49bcfeb602ecc1b600dee0051d09e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a28620e2103a5205886e14871d7cdb"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#a15a28620e2103a5205886e14871d7cdb">NodeList_remove_elem_at</a> (<a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self, <a class="el" href="NodeList_8h.html#adc0e6ba89379ed636eadc5e6fa0b52b8">ListIter_ptr</a> iter)</td></tr>
<tr class="memdesc:a15a28620e2103a5205886e14871d7cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element pointed by the given iterator.  <a href="#a15a28620e2103a5205886e14871d7cdb">More...</a><br /></td></tr>
<tr class="separator:a15a28620e2103a5205886e14871d7cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4ea33e2136883bd865f6f77928f18c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#a2f4ea33e2136883bd865f6f77928f18c">NodeList_remove_elems</a> (<a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self, const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> other, <a class="el" href="NodeList_8h.html#a5974d9a128228327a020b305a24e927f">NodeListPred</a> disposer, void *disposer_arg)</td></tr>
<tr class="memdesc:a2f4ea33e2136883bd865f6f77928f18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements that are found in other list.  <a href="#a2f4ea33e2136883bd865f6f77928f18c">More...</a><br /></td></tr>
<tr class="separator:a2f4ea33e2136883bd865f6f77928f18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8328dfbe2e9ada5c581c2e848354cf03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#a8328dfbe2e9ada5c581c2e848354cf03">NodeList_reverse</a> (<a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self)</td></tr>
<tr class="memdesc:a8328dfbe2e9ada5c581c2e848354cf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the list.  <a href="#a8328dfbe2e9ada5c581c2e848354cf03">More...</a><br /></td></tr>
<tr class="separator:a8328dfbe2e9ada5c581c2e848354cf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363cbf9d51924671c5d9368531cef1ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="NodeList_8h.html#adc0e6ba89379ed636eadc5e6fa0b52b8">ListIter_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#a363cbf9d51924671c5d9368531cef1ff">NodeList_search</a> (const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self, <a class="el" href="NodeList_8h.html#a5974d9a128228327a020b305a24e927f">NodeListPred</a> pred, void *arg)</td></tr>
<tr class="memdesc:a363cbf9d51924671c5d9368531cef1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element in a list such that 'pred'(element, 'arg') returns true.  <a href="#a363cbf9d51924671c5d9368531cef1ff">More...</a><br /></td></tr>
<tr class="separator:a363cbf9d51924671c5d9368531cef1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb44706259cfa8855cd02ebcf732de2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeList.html#a9fb44706259cfa8855cd02ebcf732de2">NodeList_sort</a> (<a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> self, int(*cmp)(const void *el1, const void *el2))</td></tr>
<tr class="memdesc:a9fb44706259cfa8855cd02ebcf732de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts self, using a support array.  <a href="#a9fb44706259cfa8855cd02ebcf732de2">More...</a><br /></td></tr>
<tr class="separator:a9fb44706259cfa8855cd02ebcf732de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The header file of <a class="el" href="structNodeList.html" title="The header file of NodeList class. ">NodeList</a> class. </p>
<dl class="section author"><dt>Author</dt><dd>Roberto Cavada </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002930">Todo:</a></b></dt><dd>: Missing description</dd></dl>
<p>A list based on (and compatible with) node_ptr lists </p>
</div><h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a9a0822beeeefdd9d029257cbfd57ede5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0822beeeefdd9d029257cbfd57ede5">&#9670;&nbsp;</a></span>NodeList_append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NodeList_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new node at the end of the list. </p>
<p>Constant time </p>

</div>
</div>
<a id="a00daaa2c57a7bc81123d4e217e3035b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00daaa2c57a7bc81123d4e217e3035b4">&#9670;&nbsp;</a></span>NodeList_belongs_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> NodeList_belongs_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given element belongs to self. </p>
<p>Constant time (cost may depend on the internal hash status) </p>

</div>
</div>
<a id="a06d900bc58575b94f404131c81708e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d900bc58575b94f404131c81708e72">&#9670;&nbsp;</a></span>NodeList_concat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NodeList_concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append all the elements in src to self. </p>
<p>Cost is linear in the size of src</p>
<p>Content of self will change is src is not empty </p>

</div>
</div>
<a id="a53e7fd25a3fbca6a9eb41a85ecb33d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e7fd25a3fbca6a9eb41a85ecb33d23">&#9670;&nbsp;</a></span>NodeList_concat_unique()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NodeList_concat_unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append all the elements in src to self, but only if each element does not occur in self already. </p>
<p>Cost is linear in the size of src</p>
<p>Content of self may change is src is not empty </p>

</div>
</div>
<a id="af33e6ec2d98343df86d1c258338b1993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33e6ec2d98343df86d1c258338b1993">&#9670;&nbsp;</a></span>NodeList_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> NodeList_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies self and returns a new independent instance. </p>
<p>Linear time </p>

</div>
</div>
<a id="a18885711b485e8bb2244159659493716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18885711b485e8bb2244159659493716">&#9670;&nbsp;</a></span>NodeList_count_elem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int NodeList_count_elem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of occurrences of the given element. </p>
<p>Constant time (cost may depend on the internal hash status) </p>

</div>
</div>
<a id="abef41ba3789c250b4dc75a81ced372a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef41ba3789c250b4dc75a81ced372a9">&#9670;&nbsp;</a></span>NodeList_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> NodeList_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new list. </p>

</div>
</div>
<a id="a1b08ab7372329f61ff0344914ab44cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b08ab7372329f61ff0344914ab44cd6">&#9670;&nbsp;</a></span>NodeList_create_from_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> NodeList_create_from_element </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a singleton nodelist. </p>
<p>Must be freed by the caller </p>

</div>
</div>
<a id="ad453123b657e91cb13cd6b532e4cda19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad453123b657e91cb13cd6b532e4cda19">&#9670;&nbsp;</a></span>NodeList_create_from_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> NodeList_create_from_list </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that creates a new <a class="el" href="structNodeList.html" title="The header file of NodeList class. ">NodeList</a> that is a wrapper of the given list. </p>
<p>self becomes a user of the given list, meaning that when self will be destroyed, it will not free the given list. It is a caller responsability of freeing the passed list when possible. </p>

</div>
</div>
<a id="ab9cd4e7a697127b4a1f1fd9bb9b488ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cd4e7a697127b4a1f1fd9bb9b488ad">&#9670;&nbsp;</a></span>NodeList_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NodeList_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class destroyer. </p>

</div>
</div>
<a id="a0fafa333c547808f4750365e9c4f945a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fafa333c547808f4750365e9c4f945a">&#9670;&nbsp;</a></span>NodeList_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> NodeList_filter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NodeMgr_8h.html#a1bd310ecf7cc131e91db3f9bc71fce53">BPFN</a>&#160;</td>
          <td class="paramname"><em>foo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new list that contains all elements of self for which function foo returned true. </p>
<p>Elements are not copied. Returned list must be freed by the caller </p>

</div>
</div>
<a id="a4340bbac403b2abd5cc47346b9b78cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4340bbac403b2abd5cc47346b9b78cef">&#9670;&nbsp;</a></span>NodeList_foreach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int NodeList_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a353599f773119b73b9c2285f0e04b073">NODE_LIST_FOREACH_FUN_P</a>&#160;</td>
          <td class="paramname"><em>foo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walks through the list, calling given funtion for each element. </p>
<p>Returns the number of visited nodes, which can be less than the total number of elements since foo can decide to interrupt the walking </p>

</div>
</div>
<a id="ab6b06a03834a0e53cc4f01b7b81b5212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b06a03834a0e53cc4f01b7b81b5212">&#9670;&nbsp;</a></span>NodeList_get_elem_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr NodeList_get_elem_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="NodeList_8h.html#adc0e6ba89379ed636eadc5e6fa0b52b8">ListIter_ptr</a>&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element at the position pointed by iter. </p>

</div>
</div>
<a id="adee44b160d372c655b3ab4869e99aedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee44b160d372c655b3ab4869e99aedf">&#9670;&nbsp;</a></span>NodeList_get_first_iter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="NodeList_8h.html#adc0e6ba89379ed636eadc5e6fa0b52b8">ListIter_ptr</a> NodeList_get_first_iter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the iterator pointing to the first element. </p>

</div>
</div>
<a id="af4cfa04632c977571cdbd1cc0a9bcd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4cfa04632c977571cdbd1cc0a9bcd93">&#9670;&nbsp;</a></span>NodeList_get_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int NodeList_get_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the list. </p>
<p>Constant time </p>

</div>
</div>
<a id="a24dbed3812c77858d8f814abb76c9059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24dbed3812c77858d8f814abb76c9059">&#9670;&nbsp;</a></span>NodeList_insert_after()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NodeList_insert_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#adc0e6ba89379ed636eadc5e6fa0b52b8">ListIter_ptr</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given element after the node pointed by the given iterator. </p>
<p>Constant time. iter must be a valid iterator, and cannot point at the end of the list</p>
<dl class="section see"><dt>See also</dt><dd>insert_before </dd></dl>

</div>
</div>
<a id="ae379fdc2828a71df004762645c92621b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae379fdc2828a71df004762645c92621b">&#9670;&nbsp;</a></span>NodeList_insert_before()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NodeList_insert_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#adc0e6ba89379ed636eadc5e6fa0b52b8">ListIter_ptr</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given element before the node pointed by the given iterator. </p>
<p>Constant time</p>
<dl class="section see"><dt>See also</dt><dd>insert_after </dd></dl>

</div>
</div>
<a id="aef77eae5473dcfee98a447d6875ace0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef77eae5473dcfee98a447d6875ace0d">&#9670;&nbsp;</a></span>NodeList_is_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> NodeList_is_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff the size of the list is 0. </p>

</div>
</div>
<a id="acdb53d706da1ccddd02ccc09c42c6679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb53d706da1ccddd02ccc09c42c6679">&#9670;&nbsp;</a></span>NodeList_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> NodeList_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NodeMgr_8h.html#a257a87e77d0b3f0885550f1318731736">NPFN</a>&#160;</td>
          <td class="paramname"><em>foo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new list that contains all elements of self, after applying function foo to each element. </p>
<p>Elements are not copied. Returned list must be freed by the caller </p>

</div>
</div>
<a id="a3bbc96b7d22ca021eeca1ccce2c24184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbc96b7d22ca021eeca1ccce2c24184">&#9670;&nbsp;</a></span>NodeList_prepend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NodeList_prepend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepends a new node at the beginning of the list. </p>
<p>Constant time </p>

</div>
</div>
<a id="af49bcfeb602ecc1b600dee0051d09e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af49bcfeb602ecc1b600dee0051d09e72">&#9670;&nbsp;</a></span>NodeList_print_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NodeList_print_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MasterPrinter_8h.html#adefcbfb8d647308a7dfd66842759df62">MasterPrinter_ptr</a>&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the nodes in the list, separated by spaces. </p>
<p>The list must be a list of actual node_ptr </p>

</div>
</div>
<a id="a15a28620e2103a5205886e14871d7cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a28620e2103a5205886e14871d7cdb">&#9670;&nbsp;</a></span>NodeList_remove_elem_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr NodeList_remove_elem_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#adc0e6ba89379ed636eadc5e6fa0b52b8">ListIter_ptr</a>&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element pointed by the given iterator. </p>
<p>The removed element is returned. The given iterator won't be usable anymore. Constant time. </p>

</div>
</div>
<a id="a2f4ea33e2136883bd865f6f77928f18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4ea33e2136883bd865f6f77928f18c">&#9670;&nbsp;</a></span>NodeList_remove_elems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int NodeList_remove_elems </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a5974d9a128228327a020b305a24e927f">NodeListPred</a>&#160;</td>
          <td class="paramname"><em>disposer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>disposer_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements that are found in other list. </p>
<p>Linear time on the size of self. No iteration is done if other is empty. If not NULL, disposer is called on the removed element, passing disposer_arg. If the disposer returns true, the removal continues, otherwise it aborts and returns with the list as it is at that time. Returns the number of removed elements </p>

</div>
</div>
<a id="a8328dfbe2e9ada5c581c2e848354cf03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8328dfbe2e9ada5c581c2e848354cf03">&#9670;&nbsp;</a></span>NodeList_reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NodeList_reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the list. </p>
<p>Linear time </p>

</div>
</div>
<a id="a363cbf9d51924671c5d9368531cef1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363cbf9d51924671c5d9368531cef1ff">&#9670;&nbsp;</a></span>NodeList_search()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="NodeList_8h.html#adc0e6ba89379ed636eadc5e6fa0b52b8">ListIter_ptr</a> NodeList_search </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a5974d9a128228327a020b305a24e927f">NodeListPred</a>&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element in a list such that 'pred'(element, 'arg') returns true. </p>
<p>Linear time search is used to find an element 'elem' such that function pred(elem, arg) returns true. An iterator pointing to the found element is returned. If the element is not found then ListIter_is_end will be true on the returned iterator.</p>
<p>If pred is NULL then a search for an element equal to arg will be done (as if pred was a pointer-equality predicate). If pred is NULL and the searched element does not occur in the list, the function returns in constant time.</p>
<dl class="section see"><dt>See also</dt><dd>ListIter_is_end, <a class="el" href="structNodeList.html#a00daaa2c57a7bc81123d4e217e3035b4" title="Returns true if given element belongs to self. ">NodeList_belongs_to</a> </dd></dl>

</div>
</div>
<a id="a9fb44706259cfa8855cd02ebcf732de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb44706259cfa8855cd02ebcf732de2">&#9670;&nbsp;</a></span>NodeList_sort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NodeList_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *el1, const void *el2)&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts self, using a support array. </p>
<p>qsort is used </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/root/research/NuSMV-2.6.0/NuSMV/code/nusmv/core/utils/<a class="el" href="NodeList_8h_source.html">NodeList.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 18 2022 22:26:36 for NuSMV Developers Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
