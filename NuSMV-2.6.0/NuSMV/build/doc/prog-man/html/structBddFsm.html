<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NuSMV Developers Manual: BddFsm Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NuSMV Developers Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">BddFsm Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Declares the interface of the class <a class="el" href="structBddFsm.html" title="Declares the interface of the class BddFsm. ">BddFsm</a>.  
 <a href="structBddFsm.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BddFsm__private_8h_source.html">BddFsm_private.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a1c9f8fd60066af3b240757c50accbd78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bddInt_8h.html#a3bd4a6732ac78aa993281e9337e48e19">BddFsmCache_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a1c9f8fd60066af3b240757c50accbd78">cache</a></td></tr>
<tr class="separator:a1c9f8fd60066af3b240757c50accbd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18334518bdc49b913e81891b9de51c16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="FairnessList_8h.html#abf4781d2a08952f7dd1b33fd3a8eda0f">CompassionList_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a18334518bdc49b913e81891b9de51c16">compassion</a></td></tr>
<tr class="separator:a18334518bdc49b913e81891b9de51c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4971c26c2719990774e506bec9a2bb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DDMgr_8h.html#aaf9e5f2c269dadf9fa0c1ccea1680d78">DDMgr_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#ab4971c26c2719990774e506bec9a2bb5">dd</a></td></tr>
<tr class="separator:ab4971c26c2719990774e506bec9a2bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b24b6fe9652973abe3d94f1700cdee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a95b24b6fe9652973abe3d94f1700cdee">enc</a></td></tr>
<tr class="separator:a95b24b6fe9652973abe3d94f1700cdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4da8cffa21955afb0a93deec515c1f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#aa4da8cffa21955afb0a93deec515c1f3">init</a></td></tr>
<tr class="separator:aa4da8cffa21955afb0a93deec515c1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe674c1fe1444e4ac3583362ded92e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#a61d0a1624260be81cdde5bdaf8779dd0">BddInvarInputs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a4fe674c1fe1444e4ac3583362ded92e4">invar_inputs</a></td></tr>
<tr class="separator:a4fe674c1fe1444e4ac3583362ded92e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9726d5d65f17ba012b6c67d9a7e8cbc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#adea97bb228341054ded7d02900d5a6ed">BddInvarStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a9726d5d65f17ba012b6c67d9a7e8cbc6">invar_states</a></td></tr>
<tr class="separator:a9726d5d65f17ba012b6c67d9a7e8cbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3bff8de94b701e072cfd99180acfa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="FairnessList_8h.html#a3361a7e562235ba6d8a772fde5250d36">JusticeList_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a0c3bff8de94b701e072cfd99180acfa6">justice</a></td></tr>
<tr class="separator:a0c3bff8de94b701e072cfd99180acfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453066a6ca86f76ee52a8decc61509a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a453066a6ca86f76ee52a8decc61509a2">symb_table</a></td></tr>
<tr class="separator:a453066a6ca86f76ee52a8decc61509a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae1186caf8392efb3d944a6c7aef0df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BddTrans_8h.html#ab0405396941d16ea98b03cd30ca3afa1">BddTrans_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#abae1186caf8392efb3d944a6c7aef0df">trans</a></td></tr>
<tr class="separator:abae1186caf8392efb3d944a6c7aef0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a40d73cde2ca8c8573ca4a1507611340c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a40d73cde2ca8c8573ca4a1507611340c">BddFsm_apply_synchronous_product</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> other)</td></tr>
<tr class="memdesc:a40d73cde2ca8c8573ca4a1507611340c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of BddFsm_apply_synchronous_product_custom_varsets that simply takes all variables in the encoding into account.  <a href="#a40d73cde2ca8c8573ca4a1507611340c">More...</a><br /></td></tr>
<tr class="separator:a40d73cde2ca8c8573ca4a1507611340c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2451e83d56b383ae2f966a0dee0d66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a3b2451e83d56b383ae2f966a0dee0d66">BddFsm_apply_synchronous_product_custom_varsets</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> other, bdd_ptr state_vars_cube, bdd_ptr input_vars_cube, bdd_ptr next_vars_cube)</td></tr>
<tr class="memdesc:a3b2451e83d56b383ae2f966a0dee0d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the synchronous product of two fsm.  <a href="#a3b2451e83d56b383ae2f966a0dee0d66">More...</a><br /></td></tr>
<tr class="separator:a3b2451e83d56b383ae2f966a0dee0d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8f5a1a217339d7f627cbd8fb1cfdcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a0b8f5a1a217339d7f627cbd8fb1cfdcc">BddFsm_check_machine</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:a0b8f5a1a217339d7f627cbd8fb1cfdcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the transition relation is total.  <a href="#a0b8f5a1a217339d7f627cbd8fb1cfdcc">More...</a><br /></td></tr>
<tr class="separator:a0b8f5a1a217339d7f627cbd8fb1cfdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ab6caad83512601f58ab88e48477f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#af5ab6caad83512601f58ab88e48477f6">BddFsm_compute_reachable</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, int k, int t, int *diameter)</td></tr>
<tr class="memdesc:af5ab6caad83512601f58ab88e48477f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the set of reachable states.  <a href="#af5ab6caad83512601f58ab88e48477f6">More...</a><br /></td></tr>
<tr class="separator:af5ab6caad83512601f58ab88e48477f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb825e6d1bbc276708567c0fe82e3e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a9bb825e6d1bbc276708567c0fe82e3e8">BddFsm_copy</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:a9bb825e6d1bbc276708567c0fe82e3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for <a class="el" href="structBddFsm.html" title="Declares the interface of the class BddFsm. ">BddFsm</a>.  <a href="#a9bb825e6d1bbc276708567c0fe82e3e8">More...</a><br /></td></tr>
<tr class="separator:a9bb825e6d1bbc276708567c0fe82e3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d2b63c541778d5853de668a6742594"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a01d2b63c541778d5853de668a6742594">BddFsm_copy_cache</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> other, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> keep_family)</td></tr>
<tr class="memdesc:a01d2b63c541778d5853de668a6742594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies cached information of 'other' into self.  <a href="#a01d2b63c541778d5853de668a6742594">More...</a><br /></td></tr>
<tr class="separator:a01d2b63c541778d5853de668a6742594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbf9c77b136fa1fd9051c3b7d7ec874"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a6fbf9c77b136fa1fd9051c3b7d7ec874">BddFsm_copy_reachable_states</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> other, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> keep_family, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> force_calculation)</td></tr>
<tr class="memdesc:a6fbf9c77b136fa1fd9051c3b7d7ec874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies reachable states of 'other' into 'self'.  <a href="#a6fbf9c77b136fa1fd9051c3b7d7ec874">More...</a><br /></td></tr>
<tr class="separator:a6fbf9c77b136fa1fd9051c3b7d7ec874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e77f2e51d2e78015f232ca2c7ff4e3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a96e77f2e51d2e78015f232ca2c7ff4e3">BddFsm_count_transitions</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a> bdd)</td></tr>
<tr class="memdesc:a96e77f2e51d2e78015f232ca2c7ff4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of transitions exiting given set of states/inputs.  <a href="#a96e77f2e51d2e78015f232ca2c7ff4e3">More...</a><br /></td></tr>
<tr class="separator:a96e77f2e51d2e78015f232ca2c7ff4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0368a474a7c3822ca322794aef30e587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a0368a474a7c3822ca322794aef30e587">BddFsm_create</a> (<a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> encoding, <a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> <a class="el" href="structBddFsm.html#aa4da8cffa21955afb0a93deec515c1f3">init</a>, <a class="el" href="fsm_2bdd_2bdd_8h.html#adea97bb228341054ded7d02900d5a6ed">BddInvarStates</a> <a class="el" href="structBddFsm.html#a9726d5d65f17ba012b6c67d9a7e8cbc6">invar_states</a>, <a class="el" href="fsm_2bdd_2bdd_8h.html#a61d0a1624260be81cdde5bdaf8779dd0">BddInvarInputs</a> <a class="el" href="structBddFsm.html#a4fe674c1fe1444e4ac3583362ded92e4">invar_inputs</a>, <a class="el" href="BddTrans_8h.html#ab0405396941d16ea98b03cd30ca3afa1">BddTrans_ptr</a> <a class="el" href="structBddFsm.html#abae1186caf8392efb3d944a6c7aef0df">trans</a>, <a class="el" href="FairnessList_8h.html#a3361a7e562235ba6d8a772fde5250d36">JusticeList_ptr</a> <a class="el" href="structBddFsm.html#a0c3bff8de94b701e072cfd99180acfa6">justice</a>, <a class="el" href="FairnessList_8h.html#abf4781d2a08952f7dd1b33fd3a8eda0f">CompassionList_ptr</a> <a class="el" href="structBddFsm.html#a18334518bdc49b913e81891b9de51c16">compassion</a>)</td></tr>
<tr class="memdesc:a0368a474a7c3822ca322794aef30e587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <a class="el" href="structBddFsm.html" title="Declares the interface of the class BddFsm. ">BddFsm</a>.  <a href="#a0368a474a7c3822ca322794aef30e587">More...</a><br /></td></tr>
<tr class="separator:a0368a474a7c3822ca322794aef30e587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f3a11f903aa6054d2cafd17338d6c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#ab6f3a11f903aa6054d2cafd17338d6c4">BddFsm_destroy</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:ab6f3a11f903aa6054d2cafd17338d6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of class <a class="el" href="structBddFsm.html" title="Declares the interface of the class BddFsm. ">BddFsm</a>.  <a href="#ab6f3a11f903aa6054d2cafd17338d6c4">More...</a><br /></td></tr>
<tr class="separator:ab6f3a11f903aa6054d2cafd17338d6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f187dc71f0eb48acc3971e43f358c37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a9f187dc71f0eb48acc3971e43f358c37">BddFsm_dump_fsm</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a> env, node_ptr node_expr, char *str_constr, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="structBddFsm.html#aa4da8cffa21955afb0a93deec515c1f3">init</a>, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> invar, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="structBddFsm.html#abae1186caf8392efb3d944a6c7aef0df">trans</a>, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> fair, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> reachable, FILE *outfile)</td></tr>
<tr class="separator:a9f187dc71f0eb48acc3971e43f358c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff19d7e90b00df0210e7a10331d49aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#abff19d7e90b00df0210e7a10331d49aa">BddFsm_expand_cached_reachable_states</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, int k, int max_seconds)</td></tr>
<tr class="memdesc:abff19d7e90b00df0210e7a10331d49aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes k steps of expansion of the set of reachable states of this machine but limit the computation to terminate in the number of seconds specified (even if this limit can be exceeded for the termination of the last cycle)  <a href="#abff19d7e90b00df0210e7a10331d49aa">More...</a><br /></td></tr>
<tr class="separator:abff19d7e90b00df0210e7a10331d49aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a74d399cd28c3d8293b7b6ec3df1bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#ac0a74d399cd28c3d8293b7b6ec3df1bf">BddFsm_get_backward_image</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> states)</td></tr>
<tr class="memdesc:ac0a74d399cd28c3d8293b7b6ec3df1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the backward image of a set of states.  <a href="#ac0a74d399cd28c3d8293b7b6ec3df1bf">More...</a><br /></td></tr>
<tr class="separator:ac0a74d399cd28c3d8293b7b6ec3df1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3578abb0da3719348f39d921d6633f9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a3578abb0da3719348f39d921d6633f9c">BddFsm_get_bdd_encoding</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:a3578abb0da3719348f39d921d6633f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the be encoding associated with the given fsm instance.  <a href="#a3578abb0da3719348f39d921d6633f9c">More...</a><br /></td></tr>
<tr class="separator:a3578abb0da3719348f39d921d6633f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1329050df06adbc7d3d9509cd1dc3b93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a1329050df06adbc7d3d9509cd1dc3b93">BddFsm_get_cached_reachable_states</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> **layers, int *size)</td></tr>
<tr class="memdesc:a1329050df06adbc7d3d9509cd1dc3b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cached reachable states.  <a href="#a1329050df06adbc7d3d9509cd1dc3b93">More...</a><br /></td></tr>
<tr class="separator:a1329050df06adbc7d3d9509cd1dc3b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297eb23b3fad65120c97529f007de5af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="FairnessList_8h.html#abf4781d2a08952f7dd1b33fd3a8eda0f">CompassionList_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a297eb23b3fad65120c97529f007de5af">BddFsm_get_compassion</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:a297eb23b3fad65120c97529f007de5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for compassion list.  <a href="#a297eb23b3fad65120c97529f007de5af">More...</a><br /></td></tr>
<tr class="separator:a297eb23b3fad65120c97529f007de5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e372cd7594250181f77d855577e4ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#ae2e372cd7594250181f77d855577e4ea">BddFsm_get_constrained_backward_image</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> states, <a class="el" href="fsm_2bdd_2bdd_8h.html#a93b5059a938eaae2147930868ddab394">BddStatesInputsNexts</a> constraints)</td></tr>
<tr class="memdesc:ae2e372cd7594250181f77d855577e4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constrained backward image of a set of states.  <a href="#ae2e372cd7594250181f77d855577e4ea">More...</a><br /></td></tr>
<tr class="separator:ae2e372cd7594250181f77d855577e4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae451db7925360b51b90ac38a10381b56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#ae451db7925360b51b90ac38a10381b56">BddFsm_get_constrained_forward_image</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> states, <a class="el" href="fsm_2bdd_2bdd_8h.html#a93b5059a938eaae2147930868ddab394">BddStatesInputsNexts</a> constraints)</td></tr>
<tr class="memdesc:ae451db7925360b51b90ac38a10381b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constrained forward image of a set of states.  <a href="#ae451db7925360b51b90ac38a10381b56">More...</a><br /></td></tr>
<tr class="separator:ae451db7925360b51b90ac38a10381b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e516fcf472094d7db012521e392a85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#ae3e516fcf472094d7db012521e392a85">BddFsm_get_constrained_forward_image_states_inputs</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a> si, <a class="el" href="fsm_2bdd_2bdd_8h.html#a93b5059a938eaae2147930868ddab394">BddStatesInputsNexts</a> constraints)</td></tr>
<tr class="memdesc:ae3e516fcf472094d7db012521e392a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constrained forward image of a set of state-input pairs.  <a href="#ae3e516fcf472094d7db012521e392a85">More...</a><br /></td></tr>
<tr class="separator:ae3e516fcf472094d7db012521e392a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97483f941c6a28e95928c9e2ea7f511"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#ad97483f941c6a28e95928c9e2ea7f511">BddFsm_get_deadlock_states</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:ad97483f941c6a28e95928c9e2ea7f511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of deadlock states.  <a href="#ad97483f941c6a28e95928c9e2ea7f511">More...</a><br /></td></tr>
<tr class="separator:ad97483f941c6a28e95928c9e2ea7f511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a5e97f1f45a95b741a1d72e88263fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a12a5e97f1f45a95b741a1d72e88263fc">BddFsm_get_diameter</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:a12a5e97f1f45a95b741a1d72e88263fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the diameter of the machine from the inital state.  <a href="#a12a5e97f1f45a95b741a1d72e88263fc">More...</a><br /></td></tr>
<tr class="separator:a12a5e97f1f45a95b741a1d72e88263fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7a99ac6b06997320b8a91974040f08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a4f7a99ac6b06997320b8a91974040f08">BddFsm_get_distance_of_states</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> states)</td></tr>
<tr class="memdesc:a4f7a99ac6b06997320b8a91974040f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance of a given set of states from initial states.  <a href="#a4f7a99ac6b06997320b8a91974040f08">More...</a><br /></td></tr>
<tr class="separator:a4f7a99ac6b06997320b8a91974040f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80521795fde4d949d0aa94fc0611bfa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a80521795fde4d949d0aa94fc0611bfa4">BddFsm_get_fair_states</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:a80521795fde4d949d0aa94fc0611bfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of fair states of a fsm.  <a href="#a80521795fde4d949d0aa94fc0611bfa4">More...</a><br /></td></tr>
<tr class="separator:a80521795fde4d949d0aa94fc0611bfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e679cbaeb0557fb6c433986ae6bd2f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a0e679cbaeb0557fb6c433986ae6bd2f1">BddFsm_get_fair_states_inputs</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:a0e679cbaeb0557fb6c433986ae6bd2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of fair state-input pairs of the machine.  <a href="#a0e679cbaeb0557fb6c433986ae6bd2f1">More...</a><br /></td></tr>
<tr class="separator:a0e679cbaeb0557fb6c433986ae6bd2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13e3a57ba2375cd5551a6dee4f4fb5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#af13e3a57ba2375cd5551a6dee4f4fb5a">BddFsm_get_forward_image</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> states)</td></tr>
<tr class="memdesc:af13e3a57ba2375cd5551a6dee4f4fb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the forward image of a set of states.  <a href="#af13e3a57ba2375cd5551a6dee4f4fb5a">More...</a><br /></td></tr>
<tr class="separator:af13e3a57ba2375cd5551a6dee4f4fb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f22b364c226c951131a0bbb2e63dff1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a0f22b364c226c951131a0bbb2e63dff1">BddFsm_get_forward_image_states_inputs</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a> si)</td></tr>
<tr class="memdesc:a0f22b364c226c951131a0bbb2e63dff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the forward image of a set of state-input pairs.  <a href="#a0f22b364c226c951131a0bbb2e63dff1">More...</a><br /></td></tr>
<tr class="separator:a0f22b364c226c951131a0bbb2e63dff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84462c3848665877a3ba11c15b18e0f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a84462c3848665877a3ba11c15b18e0f2">BddFsm_get_init</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:a84462c3848665877a3ba11c15b18e0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for init.  <a href="#a84462c3848665877a3ba11c15b18e0f2">More...</a><br /></td></tr>
<tr class="separator:a84462c3848665877a3ba11c15b18e0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59946b63ce2eedda367f6a4fb705e196"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#a61d0a1624260be81cdde5bdaf8779dd0">BddInvarInputs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a59946b63ce2eedda367f6a4fb705e196">BddFsm_get_input_constraints</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:a59946b63ce2eedda367f6a4fb705e196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for input constraints.  <a href="#a59946b63ce2eedda367f6a4fb705e196">More...</a><br /></td></tr>
<tr class="separator:a59946b63ce2eedda367f6a4fb705e196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f190ff957e23f75639c459c7ce2265"><td class="memItemLeft" align="right" valign="top"><a class="el" href="FairnessList_8h.html#a3361a7e562235ba6d8a772fde5250d36">JusticeList_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a10f190ff957e23f75639c459c7ce2265">BddFsm_get_justice</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:a10f190ff957e23f75639c459c7ce2265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for justice list.  <a href="#a10f190ff957e23f75639c459c7ce2265">More...</a><br /></td></tr>
<tr class="separator:a10f190ff957e23f75639c459c7ce2265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832b28a70b6c2702162f6fa6b492d178"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a832b28a70b6c2702162f6fa6b492d178">BddFsm_get_k_backward_image</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> states, int k)</td></tr>
<tr class="memdesc:a832b28a70b6c2702162f6fa6b492d178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the k-backward image of a set of states.  <a href="#a832b28a70b6c2702162f6fa6b492d178">More...</a><br /></td></tr>
<tr class="separator:a832b28a70b6c2702162f6fa6b492d178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6845e12c5fbcf6db67ad4c76bbbc53e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a6845e12c5fbcf6db67ad4c76bbbc53e3">BddFsm_get_minimum_distance_of_states</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> states)</td></tr>
<tr class="memdesc:a6845e12c5fbcf6db67ad4c76bbbc53e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum distance of a given set of states from initial states.  <a href="#a6845e12c5fbcf6db67ad4c76bbbc53e3">More...</a><br /></td></tr>
<tr class="separator:a6845e12c5fbcf6db67ad4c76bbbc53e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a669f3c0e89342c6fde3f84cbb7828"><td class="memItemLeft" align="right" valign="top">bdd_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#ab6a669f3c0e89342c6fde3f84cbb7828">BddFsm_get_monolithic_trans_bdd</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:ab6a669f3c0e89342c6fde3f84cbb7828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bdd that represents the monolithic transition relation.  <a href="#ab6a669f3c0e89342c6fde3f84cbb7828">More...</a><br /></td></tr>
<tr class="separator:ab6a669f3c0e89342c6fde3f84cbb7828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e437f6bf6baea1369c4e45ee2591be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#ad3e437f6bf6baea1369c4e45ee2591be">BddFsm_get_not_successor_states</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:ad3e437f6bf6baea1369c4e45ee2591be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of states without subsequents.  <a href="#ad3e437f6bf6baea1369c4e45ee2591be">More...</a><br /></td></tr>
<tr class="separator:ad3e437f6bf6baea1369c4e45ee2591be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ae7119157f5c9b62eb0aea32cbee6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a78ae7119157f5c9b62eb0aea32cbee6c">BddFsm_get_reachable_states</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:a78ae7119157f5c9b62eb0aea32cbee6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the set of reachable states of this machine.  <a href="#a78ae7119157f5c9b62eb0aea32cbee6c">More...</a><br /></td></tr>
<tr class="separator:a78ae7119157f5c9b62eb0aea32cbee6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af679c976829c7ff87f346439b8123cbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#af679c976829c7ff87f346439b8123cbd">BddFsm_get_reachable_states_at_distance</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, int distance)</td></tr>
<tr class="memdesc:af679c976829c7ff87f346439b8123cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of reachable states at a given distance.  <a href="#af679c976829c7ff87f346439b8123cbd">More...</a><br /></td></tr>
<tr class="separator:af679c976829c7ff87f346439b8123cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65845492b7dc1d7dc7f4498f1c63dca4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a65845492b7dc1d7dc7f4498f1c63dca4">BddFsm_get_revfair_states</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:a65845492b7dc1d7dc7f4498f1c63dca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of reverse fair states of a fsm.  <a href="#a65845492b7dc1d7dc7f4498f1c63dca4">More...</a><br /></td></tr>
<tr class="separator:a65845492b7dc1d7dc7f4498f1c63dca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c26812453f29033cec91d0cfc5f1121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a3c26812453f29033cec91d0cfc5f1121">BddFsm_get_revfair_states_inputs</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:a3c26812453f29033cec91d0cfc5f1121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of reverse fair state-input pairs of the machine.  <a href="#a3c26812453f29033cec91d0cfc5f1121">More...</a><br /></td></tr>
<tr class="separator:a3c26812453f29033cec91d0cfc5f1121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff346aabc40127e04f3dfb263f71b4ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#aff346aabc40127e04f3dfb263f71b4ad">BddFsm_get_sins_constrained_forward_image</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> states, <a class="el" href="fsm_2bdd_2bdd_8h.html#a93b5059a938eaae2147930868ddab394">BddStatesInputsNexts</a> constraints)</td></tr>
<tr class="memdesc:aff346aabc40127e04f3dfb263f71b4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constrained forward image of a set of states.  <a href="#aff346aabc40127e04f3dfb263f71b4ad">More...</a><br /></td></tr>
<tr class="separator:aff346aabc40127e04f3dfb263f71b4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf1f83bebfcf27bf371cd3e4f26eefe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#adea97bb228341054ded7d02900d5a6ed">BddInvarStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a1cf1f83bebfcf27bf371cd3e4f26eefe">BddFsm_get_state_constraints</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:a1cf1f83bebfcf27bf371cd3e4f26eefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for state constraints.  <a href="#a1cf1f83bebfcf27bf371cd3e4f26eefe">More...</a><br /></td></tr>
<tr class="separator:a1cf1f83bebfcf27bf371cd3e4f26eefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9097e971c01df7503a595b2857736c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a9c9097e971c01df7503a595b2857736c">BddFsm_get_states_inputs_constraints</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="BddFsm_8h.html#aeca2663ae3352af8d1e0cc4376e3e430">BddFsm_dir</a> dir)</td></tr>
<tr class="memdesc:a9c9097e971c01df7503a595b2857736c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a state-input pair for which at least one legal successor (if dir = BDD_FSM_DIR_BWD) or predecessor (otherwise) exists.  <a href="#a9c9097e971c01df7503a595b2857736c">More...</a><br /></td></tr>
<tr class="separator:a9c9097e971c01df7503a595b2857736c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea0ef03db2d98a5edfed9514ba6b111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a1ea0ef03db2d98a5edfed9514ba6b111">BddFsm_get_strong_backward_image</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> states)</td></tr>
<tr class="memdesc:a1ea0ef03db2d98a5edfed9514ba6b111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the strong backward image of a set of states.  <a href="#a1ea0ef03db2d98a5edfed9514ba6b111">More...</a><br /></td></tr>
<tr class="separator:a1ea0ef03db2d98a5edfed9514ba6b111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158ba9da860b4a29175225dc611c5fa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BddTrans_8h.html#ab0405396941d16ea98b03cd30ca3afa1">BddTrans_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a158ba9da860b4a29175225dc611c5fa1">BddFsm_get_trans</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:a158ba9da860b4a29175225dc611c5fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the trans.  <a href="#a158ba9da860b4a29175225dc611c5fa1">More...</a><br /></td></tr>
<tr class="separator:a158ba9da860b4a29175225dc611c5fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bebc144c3ab99c6f3b7826ac48b0c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a94bebc144c3ab99c6f3b7826ac48b0c4">BddFsm_get_weak_backward_image</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> states)</td></tr>
<tr class="memdesc:a94bebc144c3ab99c6f3b7826ac48b0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weak backward image of a set of states.  <a href="#a94bebc144c3ab99c6f3b7826ac48b0c4">More...</a><br /></td></tr>
<tr class="separator:a94bebc144c3ab99c6f3b7826ac48b0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62d22d8a6955919f224a8752e963688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#aa62d22d8a6955919f224a8752e963688">BddFsm_has_cached_reachable_states</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:aa62d22d8a6955919f224a8752e963688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set of reachable states exists in the FSM.  <a href="#aa62d22d8a6955919f224a8752e963688">More...</a><br /></td></tr>
<tr class="separator:aa62d22d8a6955919f224a8752e963688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5eb7bccce46a5bd03038f3058a16b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#ad5eb7bccce46a5bd03038f3058a16b9d">BddFsm_is_deadlock_free</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:ad5eb7bccce46a5bd03038f3058a16b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this machine is deadlock free.  <a href="#ad5eb7bccce46a5bd03038f3058a16b9d">More...</a><br /></td></tr>
<tr class="separator:ad5eb7bccce46a5bd03038f3058a16b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74b3fede95fd42fd76a16d65267478e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#aa74b3fede95fd42fd76a16d65267478e">BddFsm_is_fair_states</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> states)</td></tr>
<tr class="memdesc:aa74b3fede95fd42fd76a16d65267478e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a set of states is fair.  <a href="#aa74b3fede95fd42fd76a16d65267478e">More...</a><br /></td></tr>
<tr class="separator:aa74b3fede95fd42fd76a16d65267478e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521e837b9500e19510bcb23dfa078123"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a521e837b9500e19510bcb23dfa078123">BddFsm_is_total</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:a521e837b9500e19510bcb23dfa078123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this machine is total.  <a href="#a521e837b9500e19510bcb23dfa078123">More...</a><br /></td></tr>
<tr class="separator:a521e837b9500e19510bcb23dfa078123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a009f603cff8b5a90fd7f533144b248"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a7a009f603cff8b5a90fd7f533144b248">BddFsm_print_fair_state_input_pairs</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a> env, const <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a> outstream, const <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> verbose)</td></tr>
<tr class="memdesc:a7a009f603cff8b5a90fd7f533144b248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the fair state/input pairs.  <a href="#a7a009f603cff8b5a90fd7f533144b248">More...</a><br /></td></tr>
<tr class="separator:a7a009f603cff8b5a90fd7f533144b248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081a241e732fc8d4196ef407f02a58a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a081a241e732fc8d4196ef407f02a58a7">BddFsm_print_fair_state_input_pairs_info</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, const <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> print_transitions, <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a> file)</td></tr>
<tr class="memdesc:a081a241e732fc8d4196ef407f02a58a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints statistical information about fair state/input pairs.  <a href="#a081a241e732fc8d4196ef407f02a58a7">More...</a><br /></td></tr>
<tr class="separator:a081a241e732fc8d4196ef407f02a58a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b58ea998ce591bfb610583a0a6403c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a42b58ea998ce591bfb610583a0a6403c">BddFsm_print_fair_states</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a> env, const <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a> outstream, const <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> verbose)</td></tr>
<tr class="memdesc:a42b58ea998ce591bfb610583a0a6403c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the fair states.  <a href="#a42b58ea998ce591bfb610583a0a6403c">More...</a><br /></td></tr>
<tr class="separator:a42b58ea998ce591bfb610583a0a6403c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66d0d15aa217c0e90b1bb5abc7834a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#af66d0d15aa217c0e90b1bb5abc7834a2">BddFsm_print_fair_states_info</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, const <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> verbose, <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a> file)</td></tr>
<tr class="memdesc:af66d0d15aa217c0e90b1bb5abc7834a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints statistical information about fair states.  <a href="#af66d0d15aa217c0e90b1bb5abc7834a2">More...</a><br /></td></tr>
<tr class="separator:af66d0d15aa217c0e90b1bb5abc7834a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604f6f346d6e7e7815cc8f5b05cf661b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a604f6f346d6e7e7815cc8f5b05cf661b">BddFsm_print_fair_transitions</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a> env, const enum <a class="el" href="BddFsm_8h.html#a541702918169b39b4f3d5c41e4a65290">BddFsmTransPrinterFormat</a> format, const <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a> outstream)</td></tr>
<tr class="memdesc:a604f6f346d6e7e7815cc8f5b05cf661b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the fair transitions.  <a href="#a604f6f346d6e7e7815cc8f5b05cf661b">More...</a><br /></td></tr>
<tr class="separator:a604f6f346d6e7e7815cc8f5b05cf661b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb3d2056d50cb807205b02226bc3954"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a3eb3d2056d50cb807205b02226bc3954">BddFsm_print_fair_transitions_info</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, const enum <a class="el" href="BddFsm_8h.html#a541702918169b39b4f3d5c41e4a65290">BddFsmTransPrinterFormat</a> format, <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a> file)</td></tr>
<tr class="memdesc:a3eb3d2056d50cb807205b02226bc3954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints statistical information about fair states and transitions.  <a href="#a3eb3d2056d50cb807205b02226bc3954">More...</a><br /></td></tr>
<tr class="separator:a3eb3d2056d50cb807205b02226bc3954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549a582d7c18e76ec067ef376c06eacc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a549a582d7c18e76ec067ef376c06eacc">BddFsm_print_info</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a> file)</td></tr>
<tr class="memdesc:a549a582d7c18e76ec067ef376c06eacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints some information about this <a class="el" href="structBddFsm.html" title="Declares the interface of the class BddFsm. ">BddFsm</a>.  <a href="#a549a582d7c18e76ec067ef376c06eacc">More...</a><br /></td></tr>
<tr class="separator:a549a582d7c18e76ec067ef376c06eacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bd4ca7e5c8633bbed9c89acb5b6c2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#ac4bd4ca7e5c8633bbed9c89acb5b6c2b">BddFsm_print_reachable_states</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a> env, <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a> stream, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> verbose, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> print_defines, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> formula)</td></tr>
<tr class="memdesc:ac4bd4ca7e5c8633bbed9c89acb5b6c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the reachable states.  <a href="#ac4bd4ca7e5c8633bbed9c89acb5b6c2b">More...</a><br /></td></tr>
<tr class="separator:ac4bd4ca7e5c8633bbed9c89acb5b6c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b6b173af1afc3648e9238f165655c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a02b6b173af1afc3648e9238f165655c9">BddFsm_print_reachable_states_info</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, const <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> print_states, const <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> print_defines, const <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> print_formula, <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a> file)</td></tr>
<tr class="memdesc:a02b6b173af1afc3648e9238f165655c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints statistical information about reachable states.  <a href="#a02b6b173af1afc3648e9238f165655c9">More...</a><br /></td></tr>
<tr class="separator:a02b6b173af1afc3648e9238f165655c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee17f35a73eb4503be53c4fe1d2e6cbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#aee17f35a73eb4503be53c4fe1d2e6cbb">BddFsm_reachable_states_computed</a> (<a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self)</td></tr>
<tr class="memdesc:aee17f35a73eb4503be53c4fe1d2e6cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the set of reachable states has already been computed.  <a href="#aee17f35a73eb4503be53c4fe1d2e6cbb">More...</a><br /></td></tr>
<tr class="separator:aee17f35a73eb4503be53c4fe1d2e6cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df3303f2e4255647b51a41a6236a841"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a2df3303f2e4255647b51a41a6236a841">BddFsm_set_reachable_states</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> reachable)</td></tr>
<tr class="memdesc:a2df3303f2e4255647b51a41a6236a841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the whole set of reachable states for this FSM, with no onion ring informations.  <a href="#a2df3303f2e4255647b51a41a6236a841">More...</a><br /></td></tr>
<tr class="separator:a2df3303f2e4255647b51a41a6236a841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76709510a0cbeade2c2b247a11b813fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a76709510a0cbeade2c2b247a11b813fc">BddFsm_states_inputs_to_inputs</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a> si)</td></tr>
<tr class="memdesc:a76709510a0cbeade2c2b247a11b813fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inputs occurring in a set of states-inputs pairs.  <a href="#a76709510a0cbeade2c2b247a11b813fc">More...</a><br /></td></tr>
<tr class="separator:a76709510a0cbeade2c2b247a11b813fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75749e8217f50a707bab7ae3b39a09b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a75749e8217f50a707bab7ae3b39a09b0">BddFsm_states_inputs_to_states</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a> si)</td></tr>
<tr class="memdesc:a75749e8217f50a707bab7ae3b39a09b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the states occurring in a set of states-inputs pairs.  <a href="#a75749e8217f50a707bab7ae3b39a09b0">More...</a><br /></td></tr>
<tr class="separator:a75749e8217f50a707bab7ae3b39a09b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735ee67c58c451056b90d03b4fafe57f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsm_2bdd_2bdd_8h.html#a27b39245a3288de2e162fdcf5f6edd54">BddInputs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#a735ee67c58c451056b90d03b4fafe57f">BddFsm_states_to_states_get_inputs</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, <a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> cur_states, <a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> next_states)</td></tr>
<tr class="memdesc:a735ee67c58c451056b90d03b4fafe57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two sets of states, returns the set of inputs labeling any transition from a state in the first set to a state in the second set.  <a href="#a735ee67c58c451056b90d03b4fafe57f">More...</a><br /></td></tr>
<tr class="separator:a735ee67c58c451056b90d03b4fafe57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e101c207a33c971b987beccfb03057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBddFsm.html#af3e101c207a33c971b987beccfb03057">BddFsm_update_cached_reachable_states</a> (const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> self, node_ptr layers, int size, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> completed)</td></tr>
<tr class="memdesc:af3e101c207a33c971b987beccfb03057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the cached reachable states.  <a href="#af3e101c207a33c971b987beccfb03057">More...</a><br /></td></tr>
<tr class="separator:af3e101c207a33c971b987beccfb03057"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Declares the interface of the class <a class="el" href="structBddFsm.html" title="Declares the interface of the class BddFsm. ">BddFsm</a>. </p>
<p>Declares the private interface of the class <a class="el" href="structBddFsm.html" title="Declares the interface of the class BddFsm. ">BddFsm</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Roberto Cavada, Marco Benedetti A <a class="el" href="structBddFsm.html" title="Declares the interface of the class BddFsm. ">BddFsm</a> is a Finite State Machine (FSM) whose building blocks (the set of initial state, the transition relation, the set of constraints on inputs and so on) are represented by means of BDD data structures, and whose capabilities are based on operations upon and between BDDs as well.</dd>
<dd>
Roberto Cavada </dd></dl>
</div><h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a40d73cde2ca8c8573ca4a1507611340c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d73cde2ca8c8573ca4a1507611340c">&#9670;&nbsp;</a></span>BddFsm_apply_synchronous_product()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddFsm_apply_synchronous_product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variant of BddFsm_apply_synchronous_product_custom_varsets that simply takes all variables in the encoding into account. </p>
<p>The result goes into self, no changes on other. Both the two FSMs must be based on the same dd manager. The cache will change, since a new separated family will be created for the internal cache, and it will not be shared anymore with previous family. From the old cache will be reused as much as possible</p>
<p>self will change</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBddFsm.html#a3b2451e83d56b383ae2f966a0dee0d66" title="Performs the synchronous product of two fsm. ">BddFsm_apply_synchronous_product_custom_varsets</a>, <a class="el" href="structBddFsmCache.html#a75676bd312ebb07b5ee5a18cf9760c66" title="Resets any field in the cache that must be recalculated. ">BddFsmCache_reset_not_reusable_fields_after_product</a> </dd></dl>

</div>
</div>
<a id="a3b2451e83d56b383ae2f966a0dee0d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2451e83d56b383ae2f966a0dee0d66">&#9670;&nbsp;</a></span>BddFsm_apply_synchronous_product_custom_varsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddFsm_apply_synchronous_product_custom_varsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>state_vars_cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>input_vars_cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_ptr&#160;</td>
          <td class="paramname"><em>next_vars_cube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the synchronous product of two fsm. </p>
<p>Original description for BddFsm_apply_synchronous_product: </p><pre class="fragment">          The result goes into self, no changes on other.  Both
          the two FSMs must be based on the same dd manager.
          The cache will change, since a new separated family
          will be created for the internal cache, and it will
          not be shared anymore with previous family.  From the
          old cache will be reused as much as possible.

          Modified part:

          Takes cubes of state, input, and next state variables
          as arguments (rather than obtaining the cubes of all
          these variables from the bdd encoding). This is
          supposed to avoid problems when only subsets of
          variables need to be considered (as is the case for
          games).
</pre><p>self will change</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBddFsm.html#a40d73cde2ca8c8573ca4a1507611340c" title="Variant of BddFsm_apply_synchronous_product_custom_varsets that simply takes all variables in the enc...">BddFsm_apply_synchronous_product</a>, <a class="el" href="structBddFsmCache.html#a75676bd312ebb07b5ee5a18cf9760c66" title="Resets any field in the cache that must be recalculated. ">BddFsmCache_reset_not_reusable_fields_after_product</a> </dd></dl>

</div>
</div>
<a id="a0b8f5a1a217339d7f627cbd8fb1cfdcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8f5a1a217339d7f627cbd8fb1cfdcc">&#9670;&nbsp;</a></span>BddFsm_check_machine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddFsm_check_machine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that the transition relation is total. </p>
<p>Check that the transition relation is total. If not the case than a deadlock state is printed out. May trigger the computation of reachable states and states without successors. </p>

</div>
</div>
<a id="af5ab6caad83512601f58ab88e48477f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ab6caad83512601f58ab88e48477f6">&#9670;&nbsp;</a></span>BddFsm_compute_reachable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BddFsm_compute_reachable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>diameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the set of reachable states. </p>
<p>Computes the set of reachable states </p>

</div>
</div>
<a id="a9bb825e6d1bbc276708567c0fe82e3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb825e6d1bbc276708567c0fe82e3e8">&#9670;&nbsp;</a></span>BddFsm_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> BddFsm_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for <a class="el" href="structBddFsm.html" title="Declares the interface of the class BddFsm. ">BddFsm</a>. </p>

</div>
</div>
<a id="a01d2b63c541778d5853de668a6742594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d2b63c541778d5853de668a6742594">&#9670;&nbsp;</a></span>BddFsm_copy_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddFsm_copy_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>keep_family</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies cached information of 'other' into self. </p>
<p>Copies cached information (reachable states, levels, fair states, etc.) possibly previoulsy calculated by 'other' into self. Call this method when self is qualitatively identical to 'other', but for some reason the trans is organized differently. Call to reuse still valid information calculated by 'other' into self. If keep_family is true, the cache will be reused and not copied, meaning that self will belong to the same family as 'other'. In this case a change in 'other' will have effects also on self (and viceversa). Notice that previoulsy calculated information into 'self' will be lost after the copy. </p>

</div>
</div>
<a id="a6fbf9c77b136fa1fd9051c3b7d7ec874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbf9c77b136fa1fd9051c3b7d7ec874">&#9670;&nbsp;</a></span>BddFsm_copy_reachable_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddFsm_copy_reachable_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>keep_family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>force_calculation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies reachable states of 'other' into 'self'. </p>
<p>This method can be called when reachable states among FSMs can be reused, for example when other's reachable states are an over-extimation of self's. Parameter force_calculation forces the calculation of the reachable states of 'other' if needed (i.e. not previoulsy calculated).</p>
<p>The two FSMs are allowed to belong to the same family. If parameter keep_family is true, than the original FSM's family will not change, and all the family's members (all the FSMs that have a common relative) will have their reachable states changed accordingly. Otherwise, self will be detached by its own original family (originating a new one), and all relatives will be not changed.</p>
<p>Internal cache could change of both self and other </p>

</div>
</div>
<a id="a96e77f2e51d2e78015f232ca2c7ff4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e77f2e51d2e78015f232ca2c7ff4e3">&#9670;&nbsp;</a></span>BddFsm_count_transitions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double BddFsm_count_transitions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a>&#160;</td>
          <td class="paramname"><em>bdd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of transitions exiting given set of states/inputs. </p>

</div>
</div>
<a id="a0368a474a7c3822ca322794aef30e587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0368a474a7c3822ca322794aef30e587">&#9670;&nbsp;</a></span>BddFsm_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a> BddFsm_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#adea97bb228341054ded7d02900d5a6ed">BddInvarStates</a>&#160;</td>
          <td class="paramname"><em>invar_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#a61d0a1624260be81cdde5bdaf8779dd0">BddInvarInputs</a>&#160;</td>
          <td class="paramname"><em>invar_inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BddTrans_8h.html#ab0405396941d16ea98b03cd30ca3afa1">BddTrans_ptr</a>&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="FairnessList_8h.html#a3361a7e562235ba6d8a772fde5250d36">JusticeList_ptr</a>&#160;</td>
          <td class="paramname"><em>justice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="FairnessList_8h.html#abf4781d2a08952f7dd1b33fd3a8eda0f">CompassionList_ptr</a>&#160;</td>
          <td class="paramname"><em>compassion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for <a class="el" href="structBddFsm.html" title="Declares the interface of the class BddFsm. ">BddFsm</a>. </p>
<p>All given bdd are referenced. self becomes the owner of given trans, justice and compassion objects, whereas the encoding is owned by the caller </p>

</div>
</div>
<a id="ab6f3a11f903aa6054d2cafd17338d6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f3a11f903aa6054d2cafd17338d6c4">&#9670;&nbsp;</a></span>BddFsm_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddFsm_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor of class <a class="el" href="structBddFsm.html" title="Declares the interface of the class BddFsm. ">BddFsm</a>. </p>

</div>
</div>
<a id="a9f187dc71f0eb48acc3971e43f358c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f187dc71f0eb48acc3971e43f358c37">&#9670;&nbsp;</a></span>BddFsm_dump_fsm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BddFsm_dump_fsm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>node_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str_constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>invar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>fair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>reachable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>outfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abff19d7e90b00df0210e7a10331d49aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff19d7e90b00df0210e7a10331d49aa">&#9670;&nbsp;</a></span>BddFsm_expand_cached_reachable_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BddFsm_expand_cached_reachable_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes k steps of expansion of the set of reachable states of this machine but limit the computation to terminate in the number of seconds specified (even if this limit can be exceeded for the termination of the last cycle) </p>
<p>If k&lt;0 the set is expanded until fixpoint, if max_seconds&lt;0 no time limit is considered</p>
<p>Changes the internal cache </p>

</div>
</div>
<a id="ac0a74d399cd28c3d8293b7b6ec3df1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a74d399cd28c3d8293b7b6ec3df1bf">&#9670;&nbsp;</a></span>BddFsm_get_backward_image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> BddFsm_get_backward_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td>
          <td class="paramname"><em>states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the backward image of a set of states. </p>
<p>This method computes the backward image of a set S of states, i.e. the set of INVAR states from which some of the INVAR states in S is reachable by means of one single machine transition among those consistent with both the input constraints and the state/input constraints.</p>
<p>The backward image of S(X,F) is computed as follows. X - state variables, I - input variables, F - frozen variables.</p>
<p>a. S1(X,F) := S(X,F) and Invar(X,F) b. S2(X',F) := S1(X,F)[x'/x] c. S3(X,F,I) := Invar(X,F) and InputConst(I) c. BwdImg(X,F) := { &lt;x,f&gt; | &lt;x,f,i,x'&gt; in Tr(X,F,I,X') for some &lt;x,f,i&gt; in S3(X,F,I) and some &lt;x',f&gt; in S2(X',F) }</p>
<p>Note: a state is represented by state and frozen variables, but frozen variable are never abstracted away.</p>
<p>Returned bdd is referenced. </p>

</div>
</div>
<a id="a3578abb0da3719348f39d921d6633f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3578abb0da3719348f39d921d6633f9c">&#9670;&nbsp;</a></span>BddFsm_get_bdd_encoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> BddFsm_get_bdd_encoding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the be encoding associated with the given fsm instance. </p>

</div>
</div>
<a id="a1329050df06adbc7d3d9509cd1dc3b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1329050df06adbc7d3d9509cd1dc3b93">&#9670;&nbsp;</a></span>BddFsm_get_cached_reachable_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BddFsm_get_cached_reachable_states </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> **&#160;</td>
          <td class="paramname"><em>layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the cached reachable states. </p>

</div>
</div>
<a id="a297eb23b3fad65120c97529f007de5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297eb23b3fad65120c97529f007de5af">&#9670;&nbsp;</a></span>BddFsm_get_compassion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="FairnessList_8h.html#abf4781d2a08952f7dd1b33fd3a8eda0f">CompassionList_ptr</a> BddFsm_get_compassion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for compassion list. </p>
<p>self keeps the ownership of the returned object </p>

</div>
</div>
<a id="ae2e372cd7594250181f77d855577e4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e372cd7594250181f77d855577e4ea">&#9670;&nbsp;</a></span>BddFsm_get_constrained_backward_image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> BddFsm_get_constrained_backward_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td>
          <td class="paramname"><em>states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#a93b5059a938eaae2147930868ddab394">BddStatesInputsNexts</a>&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the constrained backward image of a set of states. </p>
<p>This method computes the backward image of a set of states S, given a set C(X,F,I) of contraints on STATE, FROZEN and INPUT vars which are meant to represent a restriction on allowed transitions and inputs.</p>
<p>The constrained image is the set of INVAR states from which some of the INVAR states in S is reachable by means of one single machine transition among those consistent with both the machine constraints and the given additional constraint C(X,F,I).</p>
<p>The backward image of S(X,F,I) is computed as follows. X - state variables, I - input variables, F - frozen variables.</p>
<p>a. S1(X,F) := S(X,F) and Invar(X,F) b. S2(X',F) := S1(X,F)[x'/x] c. S3(X,F,I) := Invar(X,F) and InputConst(I) and IC(I) and C(X,F,I) c. BwdImg(X,F) := { &lt;x,f&gt; | &lt;x,f,i,x'&gt; in Tr(X,F,I,X') for some &lt;x,f,i&gt; in S3(X,F,I) and some &lt;x',f&gt; in S2(X',F) }</p>
<p>To apply no contraints, parameter constraints must be the true bdd.</p>
<p>Note: a state is represented by state and frozen variables, but frozen variable are never abstracted away.</p>
<p>Returned bdd is referenced. </p>

</div>
</div>
<a id="ae451db7925360b51b90ac38a10381b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae451db7925360b51b90ac38a10381b56">&#9670;&nbsp;</a></span>BddFsm_get_constrained_forward_image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> BddFsm_get_constrained_forward_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td>
          <td class="paramname"><em>states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#a93b5059a938eaae2147930868ddab394">BddStatesInputsNexts</a>&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the constrained forward image of a set of states. </p>
<p>This method computes the forward image of a set of states S, given a set C of contraints on STATE, FROZEN and INPUT vars which are meant to represent a restriction on allowed transitions and inputs.</p>
<p>The constrained image is the set of INVAR states which are reachable from one of the INVAR states in S by means of one single machine transition among those consistent with both the constraints defined within the machine and the additional constraint C(X,F,I).</p>
<p>The forward image of S(X,F) is computed as follows. X - state variables, I - input variables, F - frozen variables.</p>
<p>a. S1(X,F,I) := S(X,F) and Invar(X,F) and InputConst(I) and C(X,F,I) b. S2(X',F) := { &lt;x',f&gt; | &lt;x,f,i,x'&gt; in Tr(X,F,I,X') for some &lt;x,f,i&gt; in S1(X,F,I) } c. S3(X,F) := S2(X',F)[x/x'] d. FwdImg(X,F) := S3(X,F) and Invar(X,F)</p>
<p>To apply no contraints, parameter constraints must be the true bdd.</p>
<p>Note: a state is represented by state and frozen variables, but frozen variable are never abstracted away.</p>
<p>Returned bdd is referenced </p>

</div>
</div>
<a id="ae3e516fcf472094d7db012521e392a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e516fcf472094d7db012521e392a85">&#9670;&nbsp;</a></span>BddFsm_get_constrained_forward_image_states_inputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a> BddFsm_get_constrained_forward_image_states_inputs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a>&#160;</td>
          <td class="paramname"><em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#a93b5059a938eaae2147930868ddab394">BddStatesInputsNexts</a>&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the constrained forward image of a set of state-input pairs. </p>
<p>This method computes the forward image of a set of state-input pairs SI constrained by constraints (from now on C). This is the set of state-input pairs that fulfills INVAR and INPUT constraints and can be reached via a legal transition from at least one member of SI that itself must fulfill INVAR, INPUT, and C.</p>
<p>The forward image of SI(X,F,I) is computed as follows. X - state variables, F - frozen variables, I - input variables.</p>
<p>a. S1(X,F,I) := SI(X,F,I) and Invar(X,F) and Input(I) and C(X,F,I) b. S2(X',F) := { &lt;x',f&gt; | &lt;x,f,i,x'&gt; in Tr(X,F,I,X') for some &lt;x,i&gt; in S1(X,F,I) } c. S3(X,F) := S2(X',F)[x/x'] d. FwdImg(X,F,I) := S3(X,F) and Invar(X,F) and Input(I)</p>
<p>To apply no contraints, parameter constraints must be the true bdd.</p>
<p>Note: a state is represented by state and frozen variables, but frozen variable are never abstracted away.</p>
<p>Returned bdd is referenced.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBddFsm.html#a0f22b364c226c951131a0bbb2e63dff1" title="Returns the forward image of a set of state-input pairs. ">BddFsm_get_forward_image_states_inputs</a>, <a class="el" href="structBddFsm.html#ae451db7925360b51b90ac38a10381b56" title="Returns the constrained forward image of a set of states. ">BddFsm_get_constrained_forward_image</a> </dd></dl>

</div>
</div>
<a id="ad97483f941c6a28e95928c9e2ea7f511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97483f941c6a28e95928c9e2ea7f511">&#9670;&nbsp;</a></span>BddFsm_get_deadlock_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> BddFsm_get_deadlock_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of deadlock states. </p>
<p>This method returns the set of deadlock states. A state ds is said to be a deadlock state when all the following conditions hold:</p>
<p>1) ds is a state satisfying stateConstr; 2) no transition from ds exists which is consistent with input and state/input constraint and leads to a state satisfying stateConstr; 3) s is rechable.</p>
<p>Could update the cache. May trigger the computation of reachable states and states without successors. Returned bdd is referenced.</p>
<p>Note: a state is represented by state and frozen variables.</p>
<p>Cache can change </p>

</div>
</div>
<a id="a12a5e97f1f45a95b741a1d72e88263fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a5e97f1f45a95b741a1d72e88263fc">&#9670;&nbsp;</a></span>BddFsm_get_diameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BddFsm_get_diameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the diameter of the machine from the inital state. </p>
<p>This method returns an integer which represents the diameter of the machine with respect to the set of initial states, i.e. the distance of the fatherst state in the machine (starting from the initial states), i.e. the maximal value among the lengths of shortest paths to each reachable state. The initial diameter is computed as the number of iteration the fixpoint procedure described above (see "BddFsm_get_reachable_states") does before reaching the fixpoint. It can also be seen as the maximal value the "BddFsm_get_distance_of_states" can return (which is returned when the argument "states" is set to "all the states").</p>
<p>Could update the cache.</p>
<p>Internal cache could change </p>

</div>
</div>
<a id="a4f7a99ac6b06997320b8a91974040f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7a99ac6b06997320b8a91974040f08">&#9670;&nbsp;</a></span>BddFsm_get_distance_of_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BddFsm_get_distance_of_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td>
          <td class="paramname"><em>states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the distance of a given set of states from initial states. </p>
<p>Computes the set of reachable states if not previously cached. Returns -1 if given states set is not reachable.</p>
<p>This method returns an integer which represents the distance of the farthest state in "states". The distance of one single state "s" is the number of applications of the "BddFsm_get_forward_image" method (starting from the initial set of states) which is necessary and sufficient to end up with a set of states containing "s". The distance of a <em>set</em> of states "set" is the maximal distance of states in "set", i.e. the number of applications of the "BddFsm_get_forward_image" method (starting from the initial set of states) which is necessary and sufficient to reach at least once (not necessarily during the last application, but somewhere along the way) each state in "set".</p>
<p>So, the distance of a set of states is a max-min function. Could update the cache.</p>
<p>Internal cache could change </p>

</div>
</div>
<a id="a80521795fde4d949d0aa94fc0611bfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80521795fde4d949d0aa94fc0611bfa4">&#9670;&nbsp;</a></span>BddFsm_get_fair_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> BddFsm_get_fair_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of fair states of a fsm. </p>
<p>A state is fair iff it can reach a cycle that visits all fairness constraints.</p>
<p>Note: a state is represented by state and frozen variables.</p>
<p>Internal cache could change </p>

</div>
</div>
<a id="a0e679cbaeb0557fb6c433986ae6bd2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e679cbaeb0557fb6c433986ae6bd2f1">&#9670;&nbsp;</a></span>BddFsm_get_fair_states_inputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a> BddFsm_get_fair_states_inputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of fair state-input pairs of the machine. </p>
<p>A state-input pair is fair iff it can reach a cycle that visits all fairness constraints.</p>
<p>Note: a state is represented by state and frozen variables.</p>
<p>Internal cache could change </p>

</div>
</div>
<a id="af13e3a57ba2375cd5551a6dee4f4fb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13e3a57ba2375cd5551a6dee4f4fb5a">&#9670;&nbsp;</a></span>BddFsm_get_forward_image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> BddFsm_get_forward_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td>
          <td class="paramname"><em>states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the forward image of a set of states. </p>
<p>This method computes the forward image of a set of states S, i.e. the set of INVAR states which are reachable from one of the INVAR states in S by means of one single machine transition among those consistent with both the input constraints and the state/input constraints.</p>
<p>The forward image of S(X,F) is computed as follows. X - state variables, I - input variables, F - frozen variables.</p>
<p>a. S1(X,F,I) := S(X,F) and Invar(X,F) and InputConst(I) b. S2(X',F) := { &lt;x',f&gt; | &lt;x,f,i,x'&gt; in Tr(X,F,I,X') for some &lt;x,i&gt; in S1(X,F,I) } c. S3(X,F) := S2(X',F)[x/x'] d. FwdImg(X,F) := S3(X,F) and Invar(X,F)</p>
<p>Note: a state is represented by state and frozen variables, but frozen variable are never abstracted away.</p>
<p>Returned bdd is referenced. </p>

</div>
</div>
<a id="a0f22b364c226c951131a0bbb2e63dff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f22b364c226c951131a0bbb2e63dff1">&#9670;&nbsp;</a></span>BddFsm_get_forward_image_states_inputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a> BddFsm_get_forward_image_states_inputs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a>&#160;</td>
          <td class="paramname"><em>si</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the forward image of a set of state-input pairs. </p>
<p>This method computes the forward image of a set of state-input pairs SI. This is the set of state-input pairs that fulfills INVAR and INPUT constraints and can be reached via a legal transition from at least one member of si that itself must fulfill INVAR and INPUT.</p>
<p>The forward image of SI(X,F,I) is computed as follows. X - state variables, F - frozen variables, I - input variables.</p>
<p>a. S1(X,F,I) := SI(X,F,I) and Invar(X,F) and Input(I) b. S2(X',F) := { &lt;x',f&gt; | &lt;x,f,i,x'&gt; in Tr(X,F,I,X') for some &lt;x,i&gt; in S1(X,F,I) } c. S3(X,F) := S2(X',F)[x/x'] d. FwdImg(X,F,I) := S3(X,F) and Invar(X,F) and Input(X,F,I)</p>
<p>Note: a state is represented by state and frozen variables, but frozen variable are never abstracted away.</p>
<p>Returned bdd is referenced.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBddFsm.html#ae3e516fcf472094d7db012521e392a85" title="Returns the constrained forward image of a set of state-input pairs. ">BddFsm_get_constrained_forward_image_states_inputs</a>, <a class="el" href="structBddFsm.html#af13e3a57ba2375cd5551a6dee4f4fb5a" title="Returns the forward image of a set of states. ">BddFsm_get_forward_image</a> </dd></dl>

</div>
</div>
<a id="a84462c3848665877a3ba11c15b18e0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84462c3848665877a3ba11c15b18e0f2">&#9670;&nbsp;</a></span>BddFsm_get_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> BddFsm_get_init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for init. </p>
<p>Returned bdd is referenced </p>

</div>
</div>
<a id="a59946b63ce2eedda367f6a4fb705e196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59946b63ce2eedda367f6a4fb705e196">&#9670;&nbsp;</a></span>BddFsm_get_input_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#a61d0a1624260be81cdde5bdaf8779dd0">BddInvarInputs</a> BddFsm_get_input_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for input constraints. </p>
<p>Returned bdd is referenced </p>

</div>
</div>
<a id="a10f190ff957e23f75639c459c7ce2265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f190ff957e23f75639c459c7ce2265">&#9670;&nbsp;</a></span>BddFsm_get_justice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="FairnessList_8h.html#a3361a7e562235ba6d8a772fde5250d36">JusticeList_ptr</a> BddFsm_get_justice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for justice list. </p>
<p>self keeps the ownership of the returned object </p>

</div>
</div>
<a id="a832b28a70b6c2702162f6fa6b492d178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832b28a70b6c2702162f6fa6b492d178">&#9670;&nbsp;</a></span>BddFsm_get_k_backward_image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a> BddFsm_get_k_backward_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td>
          <td class="paramname"><em>states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the k-backward image of a set of states. </p>
<p>This method computes the set of &lt;state,frozen,input&gt; tuples that lead into at least k distinct states of the set of states given as input. The returned couples and the states in the set given in input are restricted</p>
<p>The k-backward image of S(X,F) is computed as follows. X - state variables, I - input variables, F - frozen variables.</p>
<p>a. S1(X,F) := S(X,F) and Invar(X,F) b. S2(X',F) := S1(X,F)[X'/X] c. S3(X,F,I,k) := {&lt;x,f,i&gt; | exists x'[1..k] : S2(x'[m],f) and x'[m] != x'[n] if m != n and &lt;x,f,i,x'[m]&gt; in Tr } d. KBwdImg(X,F,I,k) := S3(X,F,I,k) and Invar(X,F) and InputConst(I)</p>
<p>Note: a state is represented by state and frozen variables, but frozen variable are never abstracted away.</p>
<p>The returned bdd is referenced. </p>

</div>
</div>
<a id="a6845e12c5fbcf6db67ad4c76bbbc53e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6845e12c5fbcf6db67ad4c76bbbc53e3">&#9670;&nbsp;</a></span>BddFsm_get_minimum_distance_of_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BddFsm_get_minimum_distance_of_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td>
          <td class="paramname"><em>states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum distance of a given set of states from initial states. </p>
<p>Computes the set of reachable states if not previously cached. Returns -1 if given states set is not reachable.</p>
<p>This method returns an integer which represents the distance of the nearest state in "states". The distance of one single state "s" is the number of applications of the "BddFsm_get_forward_image" method (starting from the initial set of states) which is necessary and sufficient to end up with a set of states containing "s". Could update the cache.</p>
<p>Internal cache could change </p>

</div>
</div>
<a id="ab6a669f3c0e89342c6fde3f84cbb7828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a669f3c0e89342c6fde3f84cbb7828">&#9670;&nbsp;</a></span>BddFsm_get_monolithic_trans_bdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdd_ptr BddFsm_get_monolithic_trans_bdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a bdd that represents the monolithic transition relation. </p>
<p>This method returns a monolithic representation of the transition relation, which is computed on the basis of the internal partitioned representation by composing all the element of the partition.</p>
<p>Returned bdd is referenced.</p>
<p>Internal cache could change </p>

</div>
</div>
<a id="ad3e437f6bf6baea1369c4e45ee2591be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e437f6bf6baea1369c4e45ee2591be">&#9670;&nbsp;</a></span>BddFsm_get_not_successor_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> BddFsm_get_not_successor_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of states without subsequents. </p>
<p>This method returns the set of states with no successor. A state "ds" has no successor when all the following conditions hold:</p>
<p>1) ds is a state satisfying stateConstr. 2) no transition from ds exists which is consistent with input and state/input constraint and leads to a state satisfying stateConstr.</p>
<p>Could update the cache. Note: a state is represented by state and frozen variables.</p>
<p>Internal cache could change </p>

</div>
</div>
<a id="a78ae7119157f5c9b62eb0aea32cbee6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ae7119157f5c9b62eb0aea32cbee6c">&#9670;&nbsp;</a></span>BddFsm_get_reachable_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> BddFsm_get_reachable_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the set of reachable states of this machine. </p>
<p>Returned bdd is referenced.</p>
<p>This method returns the set R of reachable states, i.e. those states that can be actually reached starting from one of the initial state.</p>
<p>R is the set of states such that "i TRC s" holds for some state i in the set of initial states, where TRC is the transitive closure of the conjunction of the transition relation of the machine with the set of invar states, the set of constraints on inputs and the set of state/input constraints.</p>
<p>R is computed by this method in a forward manner by exploiting the "BddFsm_get_forward_image" method during a fixpoint calculation. In particular, R is computed by reaching the fixpoint on the functional that maps S onto the forward image BddFsm_get_forward_image(S) of S, where the computation is started from the set of initial states. Notice that the set of invar states, the set of constraints on inputs and the set of state/input constrains are implicitly taken into account by BddFsm_get_forward_image(S).</p>
<p>Note: a state is represented by state and frozen variables.</p>
<p>Internal cache could change </p>

</div>
</div>
<a id="af679c976829c7ff87f346439b8123cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af679c976829c7ff87f346439b8123cbd">&#9670;&nbsp;</a></span>BddFsm_get_reachable_states_at_distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> BddFsm_get_reachable_states_at_distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of reachable states at a given distance. </p>
<p>Computes the set of reachable states if not previously, cached. Returned bdd is referenced.</p>
<p>If distance is greater than the diameter, an assertion is fired.</p>
<p>This method returns the set R of states of this machine which can be reached in exactly "distance" steps by applying the "BddFsm_get_forward_image" method ("distance" times) starting from one of the initial states (and cannot be reached with less than "distance" steps).</p>
<p>In the case that the distance is less than 0, the empty-set is returned.</p>
<p>These states are computed as intermediate steps of the fixpoint characterization given in the "BddFsm_get_reachable_states" method.</p>
<p>Note: a state is represented by state and frozen variables.</p>
<p>Internal cache could change </p>

</div>
</div>
<a id="a65845492b7dc1d7dc7f4498f1c63dca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65845492b7dc1d7dc7f4498f1c63dca4">&#9670;&nbsp;</a></span>BddFsm_get_revfair_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> BddFsm_get_revfair_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of reverse fair states of a fsm. </p>
<p>A state is reverse fair iff it can be reached from a cycle that visits all fairness constraints.</p>
<p>Note: a state is represented by state and frozen variables.</p>
<p>Internal cache could change </p>

</div>
</div>
<a id="a3c26812453f29033cec91d0cfc5f1121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c26812453f29033cec91d0cfc5f1121">&#9670;&nbsp;</a></span>BddFsm_get_revfair_states_inputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a> BddFsm_get_revfair_states_inputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of reverse fair state-input pairs of the machine. </p>
<p>A state-input pair is reverse fair iff it can be reached from a cycle that visits all fairness constraints.</p>
<p>Note: a state is represented by state and frozen variables.</p>
<p>Internal cache could change </p>

</div>
</div>
<a id="aff346aabc40127e04f3dfb263f71b4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff346aabc40127e04f3dfb263f71b4ad">&#9670;&nbsp;</a></span>BddFsm_get_sins_constrained_forward_image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> BddFsm_get_sins_constrained_forward_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td>
          <td class="paramname"><em>states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#a93b5059a938eaae2147930868ddab394">BddStatesInputsNexts</a>&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the constrained forward image of a set of states. </p>
<p>This method computes the forward image of a set of states S, given a set C of contraints on STATE, FROZEN and INPUT and NEXT vars which are meant to represent a restriction on allowed transitions and inputs.</p>
<p>The constrained image is the set of INVAR states which are reachable from one of the INVAR states in S by means of one single machine transition among those consistent with both the constraints defined within the machine and the additional constraint C(X,F,I).</p>
<p>The forward image of S(X,F) is computed as follows. X - state variables, I - input variables, F - frozen variables.</p>
<p>a. S1(X,F,I) := S(X,F) and Invar(X,F) and InputConst(I) and C(X,F,I) b. S2(X',F) := { &lt;x',f&gt; | &lt;x,f,i,x'&gt; in Tr(X,F,I,X') for some &lt;x,f,i&gt; in S1(X,F,I) } c. S3(X,F) := S2(X',F)[x/x'] d. FwdImg(X,F) := S3(X,F) and Invar(X,F)</p>
<p>To apply no contraints, parameter constraints must be the true bdd.</p>
<p>Note: a state is represented by state and frozen variables, but frozen variable are never abstracted away.</p>
<p>Returned bdd is referenced </p>

</div>
</div>
<a id="a1cf1f83bebfcf27bf371cd3e4f26eefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf1f83bebfcf27bf371cd3e4f26eefe">&#9670;&nbsp;</a></span>BddFsm_get_state_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#adea97bb228341054ded7d02900d5a6ed">BddInvarStates</a> BddFsm_get_state_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for state constraints. </p>
<p>Returned bdd is referenced </p>

</div>
</div>
<a id="a9c9097e971c01df7503a595b2857736c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9097e971c01df7503a595b2857736c">&#9670;&nbsp;</a></span>BddFsm_get_states_inputs_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a> BddFsm_get_states_inputs_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#aeca2663ae3352af8d1e0cc4376e3e430">BddFsm_dir</a>&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a state-input pair for which at least one legal successor (if dir = BDD_FSM_DIR_BWD) or predecessor (otherwise) exists. </p>

</div>
</div>
<a id="a1ea0ef03db2d98a5edfed9514ba6b111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea0ef03db2d98a5edfed9514ba6b111">&#9670;&nbsp;</a></span>BddFsm_get_strong_backward_image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a> BddFsm_get_strong_backward_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td>
          <td class="paramname"><em>states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the strong backward image of a set of states. </p>
<p>This method computes the set of &lt;state,frozem,input&gt; transitions that have at least one successor and are such that all the successors lay inside the INVAR subset of the set of states given as input.</p>
<p>The strong backward image of S(X, F, I) is computed as follows. X - state variables, I - input variables, F - frozen variables.</p>
<p>a. S1(X,F,I) := WeakBwdImg(not S(X,F)) b. S2(X,F,I) := (not S1(X,F,I)) and StateConstr(X,F) and InputConst(I) c. Tr(X,F,I) := {&lt;x,d,i&gt; | &lt;x,d,i,x'&gt; in Tr(X,F,I,X') for some x'} d. StrongBwdImg(X,F,I) := S2(X,F,I) and Tr(X,F,I)</p>
<p>Note: a state is represented by state and frozen variables, but frozen variable are never abstracted away.</p>
<p>Returned bdd is referenced. </p>

</div>
</div>
<a id="a158ba9da860b4a29175225dc611c5fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158ba9da860b4a29175225dc611c5fa1">&#9670;&nbsp;</a></span>BddFsm_get_trans()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BddTrans_8h.html#ab0405396941d16ea98b03cd30ca3afa1">BddTrans_ptr</a> BddFsm_get_trans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the trans. </p>
<p>Returned Trans instance is not copied, do not destroy it, since self keeps the ownership. </p>

</div>
</div>
<a id="a94bebc144c3ab99c6f3b7826ac48b0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bebc144c3ab99c6f3b7826ac48b0c4">&#9670;&nbsp;</a></span>BddFsm_get_weak_backward_image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a> BddFsm_get_weak_backward_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td>
          <td class="paramname"><em>states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the weak backward image of a set of states. </p>
<p>This method computes the set of &lt;state,frozen,input&gt; tuples that leads into the set of states given as input. i.e. the set of &lt;s,f,i&gt; such that &lt;s,f,i&gt; is consistent with both the input constraints and the state/input constraints, s is INVAR, and a transition from s to s' labelled by i exists for some INVAR s' in S.</p>
<p>The weak backward image of S(X,F) is computed as follows. X - state variables, I - input variables, F - frozen variables.</p>
<p>a. S1(X,F) := S(X,F) and Invar(X,F) b. S2(X',F := S1(X,F)[x'/x] c. S3(X,F,I) := Invar(X,F) and InputConst(I) c. WeakBwdImg(X,F,I) := {&lt;x,f,i&gt; | &lt;x,f,i,x'&gt; in Tr(X,F,I,X') for some &lt;x,f,i&gt; in S3(X,I) and some &lt;x,f&gt;' in S2(X',F) }</p>
<p>Note: a state is represented by state and frozen variables, but frozen variable are never abstracted away.</p>
<p>Returned bdd is referenced. </p>

</div>
</div>
<a id="aa62d22d8a6955919f224a8752e963688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62d22d8a6955919f224a8752e963688">&#9670;&nbsp;</a></span>BddFsm_has_cached_reachable_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BddFsm_has_cached_reachable_states </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the set of reachable states exists in the FSM. </p>
<p>Checks if the set of reachable states exists in the FSM </p>

</div>
</div>
<a id="ad5eb7bccce46a5bd03038f3058a16b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5eb7bccce46a5bd03038f3058a16b9d">&#9670;&nbsp;</a></span>BddFsm_is_deadlock_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BddFsm_is_deadlock_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this machine is deadlock free. </p>
<p>This method checks wether this machine is deadlock free, i.e. wether it is impossible to reach an INVAR state with no admittable INVAR successor moving from the initial condition.</p>
<p>This happens when the machine is total. If it is not, each INVAR state from which no transition to another INVAR state can be made according to the input and state/input constraints is non-reachable.</p>
<p>This method checks deadlock freeness by checking that the intersection between the set of reachable states and the set of INVAR states with no admittable INVAR successor is empty.</p>
<p>Could update the cache. May trigger the computation of deadlock states.</p>
<p>Cache can change </p>

</div>
</div>
<a id="aa74b3fede95fd42fd76a16d65267478e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74b3fede95fd42fd76a16d65267478e">&#9670;&nbsp;</a></span>BddFsm_is_fair_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BddFsm_is_fair_states </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td>
          <td class="paramname"><em>states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a set of states is fair. </p>

</div>
</div>
<a id="a521e837b9500e19510bcb23dfa078123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521e837b9500e19510bcb23dfa078123">&#9670;&nbsp;</a></span>BddFsm_is_total()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BddFsm_is_total </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this machine is total. </p>
<p>This method checks wether this machine is total, in the sense that each INVAR state has at least one INVAR successor state given the constraints on the inputs and the state/input.</p>
<p>This is done by checking that the BddFsm_ImageBwd image of the set of all the states is the set of all the INVAR states. This way, the INVAR constraints together with the set of constraints on both input and state/input are implicitly taken into account by BddFsm_get_forward_image.</p>
<p>The answer "false" is produced when states exist that admit no INVAR successor, given the sets of input and state/input constraints. However, all these "dead" states may be non-reachable, so the machine can still be "deadlock free". See the "BddFsm_is_deadlock_free" method.</p>
<p>Could update the cache. May trigger the computation of states without successors.</p>
<p>Cache can change </p>

</div>
</div>
<a id="a7a009f603cff8b5a90fd7f533144b248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a009f603cff8b5a90fd7f533144b248">&#9670;&nbsp;</a></span>BddFsm_print_fair_state_input_pairs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BddFsm_print_fair_state_input_pairs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a>&#160;</td>
          <td class="paramname"><em>outstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the fair state/input pairs. </p>
<p>This is like BddFsm_print_fair_transitions, but without the destination state. </p>

</div>
</div>
<a id="a081a241e732fc8d4196ef407f02a58a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081a241e732fc8d4196ef407f02a58a7">&#9670;&nbsp;</a></span>BddFsm_print_fair_state_input_pairs_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddFsm_print_fair_state_input_pairs_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>print_transitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a>&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints statistical information about fair state/input pairs. </p>
<p>Prints the number of fair states, taking care of the encoding and of the indifferent variables in the encoding. </p>

</div>
</div>
<a id="a42b58ea998ce591bfb610583a0a6403c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b58ea998ce591bfb610583a0a6403c">&#9670;&nbsp;</a></span>BddFsm_print_fair_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BddFsm_print_fair_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a>&#160;</td>
          <td class="paramname"><em>outstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the fair states. </p>
<p>Prints the fair states. </p>

</div>
</div>
<a id="af66d0d15aa217c0e90b1bb5abc7834a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66d0d15aa217c0e90b1bb5abc7834a2">&#9670;&nbsp;</a></span>BddFsm_print_fair_states_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddFsm_print_fair_states_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a>&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints statistical information about fair states. </p>
<p>Prints the number of fair states, taking care of the encoding and of the indifferent variables in the encoding. In verbose mode also prints transitions. </p>

</div>
</div>
<a id="a604f6f346d6e7e7815cc8f5b05cf661b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604f6f346d6e7e7815cc8f5b05cf661b">&#9670;&nbsp;</a></span>BddFsm_print_fair_transitions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BddFsm_print_fair_transitions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="BddFsm_8h.html#a541702918169b39b4f3d5c41e4a65290">BddFsmTransPrinterFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a>&#160;</td>
          <td class="paramname"><em>outstream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the fair transitions. </p>

</div>
</div>
<a id="a3eb3d2056d50cb807205b02226bc3954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb3d2056d50cb807205b02226bc3954">&#9670;&nbsp;</a></span>BddFsm_print_fair_transitions_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddFsm_print_fair_transitions_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="BddFsm_8h.html#a541702918169b39b4f3d5c41e4a65290">BddFsmTransPrinterFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a>&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints statistical information about fair states and transitions. </p>
<p>Prints the number of fair states, taking care of the encoding and of the indifferent variables in the encoding. </p>

</div>
</div>
<a id="a549a582d7c18e76ec067ef376c06eacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549a582d7c18e76ec067ef376c06eacc">&#9670;&nbsp;</a></span>BddFsm_print_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddFsm_print_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a>&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints some information about this <a class="el" href="structBddFsm.html" title="Declares the interface of the class BddFsm. ">BddFsm</a>. </p>
<p>Prints some information about this <a class="el" href="structBddFsm.html" title="Declares the interface of the class BddFsm. ">BddFsm</a>.</p>
<p>None </p>

</div>
</div>
<a id="ac4bd4ca7e5c8633bbed9c89acb5b6c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bd4ca7e5c8633bbed9c89acb5b6c2b">&#9670;&nbsp;</a></span>BddFsm_print_reachable_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BddFsm_print_reachable_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a>&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>print_defines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>formula</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the reachable states. </p>
<p>print_reachable_states </p>

</div>
</div>
<a id="a02b6b173af1afc3648e9238f165655c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b6b173af1afc3648e9238f165655c9">&#9670;&nbsp;</a></span>BddFsm_print_reachable_states_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddFsm_print_reachable_states_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>print_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>print_defines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>print_formula</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="OStream_8h.html#a56f8ec47b9a6eb28741215a65d6d171b">OStream_ptr</a>&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints statistical information about reachable states. </p>
<p>Prints statistical information about reachable states, i.e. the real number of reachable states. It is computed taking care of the encoding and of the indifferent variables in the encoding. </p>

</div>
</div>
<a id="aee17f35a73eb4503be53c4fe1d2e6cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee17f35a73eb4503be53c4fe1d2e6cbb">&#9670;&nbsp;</a></span>BddFsm_reachable_states_computed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BddFsm_reachable_states_computed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the set of reachable states has already been computed. </p>
<p>Note: a state is represented by state and frozen variables. </p>

</div>
</div>
<a id="a2df3303f2e4255647b51a41a6236a841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df3303f2e4255647b51a41a6236a841">&#9670;&nbsp;</a></span>BddFsm_set_reachable_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddFsm_set_reachable_states </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td>
          <td class="paramname"><em>reachable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the whole set of reachable states for this FSM, with no onion ring informations. </p>
<p>Sets the whole set of reachable states for this FSM, with no onion ring informations </p>

</div>
</div>
<a id="a76709510a0cbeade2c2b247a11b813fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76709510a0cbeade2c2b247a11b813fc">&#9670;&nbsp;</a></span>BddFsm_states_inputs_to_inputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> BddFsm_states_inputs_to_inputs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a>&#160;</td>
          <td class="paramname"><em>si</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inputs occurring in a set of states-inputs pairs. </p>
<p>Quantifies away the state variables (including frozen ones). A state is represented by state and frozen variables thus both state and frozen variables are abstracted away. </p>

</div>
</div>
<a id="a75749e8217f50a707bab7ae3b39a09b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75749e8217f50a707bab7ae3b39a09b0">&#9670;&nbsp;</a></span>BddFsm_states_inputs_to_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> BddFsm_states_inputs_to_states </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#a326040e055ddc8a68358d697950e8978">BddStatesInputs</a>&#160;</td>
          <td class="paramname"><em>si</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the states occurring in a set of states-inputs pairs. </p>
<p>Quantifies away the input variables. Note: a state is represented by state and frozen variables. </p>

</div>
</div>
<a id="a735ee67c58c451056b90d03b4fafe57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735ee67c58c451056b90d03b4fafe57f">&#9670;&nbsp;</a></span>BddFsm_states_to_states_get_inputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#a27b39245a3288de2e162fdcf5f6edd54">BddInputs</a> BddFsm_states_to_states_get_inputs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td>
          <td class="paramname"><em>cur_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a>&#160;</td>
          <td class="paramname"><em>next_states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given two sets of states, returns the set of inputs labeling any transition from a state in the first set to a state in the second set. </p>
<p>Note: a state is represented by state and frozen variables. </p>

</div>
</div>
<a id="af3e101c207a33c971b987beccfb03057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e101c207a33c971b987beccfb03057">&#9670;&nbsp;</a></span>BddFsm_update_cached_reachable_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BddFsm_update_cached_reachable_states </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BddFsm_8h.html#a337d2f7c77c9856130cb6d74f61a1ba7">BddFsm_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>completed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the cached reachable states. </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a1c9f8fd60066af3b240757c50accbd78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9f8fd60066af3b240757c50accbd78">&#9670;&nbsp;</a></span>cache</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bddInt_8h.html#a3bd4a6732ac78aa993281e9337e48e19">BddFsmCache_ptr</a> BddFsm::cache</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18334518bdc49b913e81891b9de51c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18334518bdc49b913e81891b9de51c16">&#9670;&nbsp;</a></span>compassion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="FairnessList_8h.html#abf4781d2a08952f7dd1b33fd3a8eda0f">CompassionList_ptr</a> BddFsm::compassion</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4971c26c2719990774e506bec9a2bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4971c26c2719990774e506bec9a2bb5">&#9670;&nbsp;</a></span>dd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DDMgr_8h.html#aaf9e5f2c269dadf9fa0c1ccea1680d78">DDMgr_ptr</a> BddFsm::dd</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95b24b6fe9652973abe3d94f1700cdee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b24b6fe9652973abe3d94f1700cdee">&#9670;&nbsp;</a></span>enc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BddEnc_8h.html#a2e75fc64ffc864ca4585e496b930beae">BddEnc_ptr</a> BddFsm::enc</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4da8cffa21955afb0a93deec515c1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4da8cffa21955afb0a93deec515c1f3">&#9670;&nbsp;</a></span>init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#aa8338141eece26a3c7c5e7946a60973b">BddStates</a> BddFsm::init</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fe674c1fe1444e4ac3583362ded92e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe674c1fe1444e4ac3583362ded92e4">&#9670;&nbsp;</a></span>invar_inputs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#a61d0a1624260be81cdde5bdaf8779dd0">BddInvarInputs</a> BddFsm::invar_inputs</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9726d5d65f17ba012b6c67d9a7e8cbc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9726d5d65f17ba012b6c67d9a7e8cbc6">&#9670;&nbsp;</a></span>invar_states</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsm_2bdd_2bdd_8h.html#adea97bb228341054ded7d02900d5a6ed">BddInvarStates</a> BddFsm::invar_states</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c3bff8de94b701e072cfd99180acfa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3bff8de94b701e072cfd99180acfa6">&#9670;&nbsp;</a></span>justice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="FairnessList_8h.html#a3361a7e562235ba6d8a772fde5250d36">JusticeList_ptr</a> BddFsm::justice</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a453066a6ca86f76ee52a8decc61509a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453066a6ca86f76ee52a8decc61509a2">&#9670;&nbsp;</a></span>symb_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a> BddFsm::symb_table</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abae1186caf8392efb3d944a6c7aef0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae1186caf8392efb3d944a6c7aef0df">&#9670;&nbsp;</a></span>trans</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BddTrans_8h.html#ab0405396941d16ea98b03cd30ca3afa1">BddTrans_ptr</a> BddFsm::trans</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>/root/research/NuSMV-2.6.0/NuSMV/code/nusmv/core/fsm/bdd/<a class="el" href="BddFsm__private_8h_source.html">BddFsm_private.h</a></li>
<li>/root/research/NuSMV-2.6.0/NuSMV/code/nusmv/core/fsm/bdd/<a class="el" href="BddFsm_8h_source.html">BddFsm.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 18 2022 22:26:36 for NuSMV Developers Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
