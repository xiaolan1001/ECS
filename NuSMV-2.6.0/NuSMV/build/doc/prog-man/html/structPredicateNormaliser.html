<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NuSMV Developers Manual: PredicateNormaliser Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NuSMV Developers Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">PredicateNormaliser Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Public interface for a predicate-normaliser class.  
 <a href="structPredicateNormaliser.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PredicateNormaliser_8h_source.html">PredicateNormaliser.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a4458ea89ca3096c2877b8604dbb3e3e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="PredicateNormaliser_8h.html#aefa15e9dd0888af4a0989e9abf8cb63b">PredicateNormaliser_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPredicateNormaliser.html#a4458ea89ca3096c2877b8604dbb3e3e8">PredicateNormaliser_create</a> (<a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a> st)</td></tr>
<tr class="memdesc:a4458ea89ca3096c2877b8604dbb3e3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor creates a predicate-normaliser.  <a href="#a4458ea89ca3096c2877b8604dbb3e3e8">More...</a><br /></td></tr>
<tr class="separator:a4458ea89ca3096c2877b8604dbb3e3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7311c5c5ebff82cd0ac952d221466f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPredicateNormaliser.html#af7311c5c5ebff82cd0ac952d221466f9">PredicateNormaliser_destroy</a> (<a class="el" href="PredicateNormaliser_8h.html#aefa15e9dd0888af4a0989e9abf8cb63b">PredicateNormaliser_ptr</a> self)</td></tr>
<tr class="memdesc:af7311c5c5ebff82cd0ac952d221466f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="structPredicateNormaliser.html" title="Public interface for a predicate-normaliser class. ">PredicateNormaliser</a> destructor.  <a href="#af7311c5c5ebff82cd0ac952d221466f9">More...</a><br /></td></tr>
<tr class="separator:af7311c5c5ebff82cd0ac952d221466f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff5add3b493f24f8db26184dd36aa5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPredicateNormaliser.html#a5ff5add3b493f24f8db26184dd36aa5c">PredicateNormaliser_get_predicates_only</a> (const <a class="el" href="PredicateNormaliser_8h.html#aefa15e9dd0888af4a0989e9abf8cb63b">PredicateNormaliser_ptr</a> self, <a class="el" href="set_8h.html#a0beb5bfe44c73e9239f023bde8a305b2">Set_t</a> *preds, node_ptr expr)</td></tr>
<tr class="memdesc:a5ff5add3b493f24f8db26184dd36aa5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function adds to the given set the expression's predicates, i.e. subexpressions which have not-boolean operands.  <a href="#a5ff5add3b493f24f8db26184dd36aa5c">More...</a><br /></td></tr>
<tr class="separator:a5ff5add3b493f24f8db26184dd36aa5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cdb234c90da1548c27d515bb29ee3b"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPredicateNormaliser.html#a74cdb234c90da1548c27d515bb29ee3b">PredicateNormaliser_normalise_expr</a> (<a class="el" href="PredicateNormaliser_8h.html#aefa15e9dd0888af4a0989e9abf8cb63b">PredicateNormaliser_ptr</a> self, node_ptr expr)</td></tr>
<tr class="memdesc:a74cdb234c90da1548c27d515bb29ee3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function performs predicate-normalisation of a generic boolean expression.  <a href="#a74cdb234c90da1548c27d515bb29ee3b">More...</a><br /></td></tr>
<tr class="separator:a74cdb234c90da1548c27d515bb29ee3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabeb29b7086fa0389ee3563d2bde8533"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPredicateNormaliser.html#aabeb29b7086fa0389ee3563d2bde8533">PredicateNormaliser_normalise_expr_no_expand</a> (<a class="el" href="PredicateNormaliser_8h.html#aefa15e9dd0888af4a0989e9abf8cb63b">PredicateNormaliser_ptr</a> self, node_ptr expr)</td></tr>
<tr class="memdesc:aabeb29b7086fa0389ee3563d2bde8533"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function performs predicate-normalisation of a generic boolean expression, but it does not expand the defines.  <a href="#aabeb29b7086fa0389ee3563d2bde8533">More...</a><br /></td></tr>
<tr class="separator:aabeb29b7086fa0389ee3563d2bde8533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2007c0753fee806e927d9d5830077b5"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPredicateNormaliser.html#ad2007c0753fee806e927d9d5830077b5">PredicateNormaliser_normalise_specification</a> (<a class="el" href="PredicateNormaliser_8h.html#aefa15e9dd0888af4a0989e9abf8cb63b">PredicateNormaliser_ptr</a> self, node_ptr expr)</td></tr>
<tr class="memdesc:ad2007c0753fee806e927d9d5830077b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function performs predicate-normalisation of specification (SPEC, LTLSPEC, etc)  <a href="#ad2007c0753fee806e927d9d5830077b5">More...</a><br /></td></tr>
<tr class="separator:ad2007c0753fee806e927d9d5830077b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fcb2c649244387686336e04ce018c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPredicateNormaliser.html#a48fcb2c649244387686336e04ce018c6">PredicateNormaliser_print_predicates_only</a> (const <a class="el" href="PredicateNormaliser_8h.html#aefa15e9dd0888af4a0989e9abf8cb63b">PredicateNormaliser_ptr</a> self, FILE *stream, node_ptr expr)</td></tr>
<tr class="memdesc:a48fcb2c649244387686336e04ce018c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function prints out the expressions's predicates, i.e. subexpressions which have not-boolean operands.  <a href="#a48fcb2c649244387686336e04ce018c6">More...</a><br /></td></tr>
<tr class="separator:a48fcb2c649244387686336e04ce018c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Public interface for a predicate-normaliser class. </p>
<dl class="section author"><dt>Author</dt><dd>Andrei Tchaltsev The purpose of a predicate normaliser is to take a symbolic expression (node_ptr), normalise predicates and return a newly created expressions with normlised predicates. A predicate-normalised expression is an expression where none of not-boolean subexpressions may have a boolean subexpression, i.e. only boolean expressions may have boolean subexpressions. Normalisation is done by (creating and) pushing IfThenElse expression up to the root of not-boolean subexpression. For example,</dd></dl>
<p>"case a : 3; 1 : 4; esac + 2 = 7"</p>
<p>have boolean expression "a" as a subexpression of not-boolean expression "case ...". The normalised version will look like "case a : 3 + 2 = 7; 1 : 4 + 2 = 7; esac"</p>
<p>This is a stand-alone class. This class needs only a type checker &ndash; to get the type of input expression and type check the generated (returned) expressions.</p>
<p>Preicate Normaliser class </p>
</div><h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a4458ea89ca3096c2877b8604dbb3e3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4458ea89ca3096c2877b8604dbb3e3e8">&#9670;&nbsp;</a></span>PredicateNormaliser_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="PredicateNormaliser_8h.html#aefa15e9dd0888af4a0989e9abf8cb63b">PredicateNormaliser_ptr</a> PredicateNormaliser_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a>&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constructor creates a predicate-normaliser. </p>
<p>See <a class="el" href="PredicateNormaliser_8h.html">PredicateNormaliser.h</a> for more info on predicate normalisation. The paramer 'checker' is a type checker used during predication-normalisation, and subsequent type checking of generated expressions. NOTE that the type checker remember the type of checked expressions. </p>

</div>
</div>
<a id="af7311c5c5ebff82cd0ac952d221466f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7311c5c5ebff82cd0ac952d221466f9">&#9670;&nbsp;</a></span>PredicateNormaliser_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PredicateNormaliser_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PredicateNormaliser_8h.html#aefa15e9dd0888af4a0989e9abf8cb63b">PredicateNormaliser_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class <a class="el" href="structPredicateNormaliser.html" title="Public interface for a predicate-normaliser class. ">PredicateNormaliser</a> destructor. </p>

</div>
</div>
<a id="a5ff5add3b493f24f8db26184dd36aa5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff5add3b493f24f8db26184dd36aa5c">&#9670;&nbsp;</a></span>PredicateNormaliser_get_predicates_only()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PredicateNormaliser_get_predicates_only </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="PredicateNormaliser_8h.html#aefa15e9dd0888af4a0989e9abf8cb63b">PredicateNormaliser_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="set_8h.html#a0beb5bfe44c73e9239f023bde8a305b2">Set_t</a> *&#160;</td>
          <td class="paramname"><em>preds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function adds to the given set the expression's predicates, i.e. subexpressions which have not-boolean operands. </p>
<p>Only boolean expressions obtained with PredicateNormaliser_normalise_expr and with the same predicate-normaliser (i.e. 'self') can be given to this function.</p>
<p>See function PredicateNormaliser_compute_predicates_and_clusters if only predicates are required without normalization of a whole expression.</p>
<p>This function just walks the exressions, tries to find a subexpression with not-boolean operands then adds it to the given set. Every predicate is added only once. </p>

</div>
</div>
<a id="a74cdb234c90da1548c27d515bb29ee3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74cdb234c90da1548c27d515bb29ee3b">&#9670;&nbsp;</a></span>PredicateNormaliser_normalise_expr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr PredicateNormaliser_normalise_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PredicateNormaliser_8h.html#aefa15e9dd0888af4a0989e9abf8cb63b">PredicateNormaliser_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function performs predicate-normalisation of a generic boolean expression. </p>
<p>The function returns a new expression &ndash; a predicate-normalised version of the given one. A predicate normalised expression is a symbolic expression (Sexp) whose not-boolean subexpressions do not encompass boolean subexpression. For example, not predicate-normalised expression "case a : 3; 1 : 4; esac + 2 = 7" after normalisatio becomes "case a : 3 + 2 = 7; 1 : 4 + 2 = 7; esac"</p>
<p>The provided expression should be scalar (since there is no meaning to normalise booleanised expressions). The given expression must be already type checked (by the type checker given to the constructor), but may be or may not be flattened and expanded.</p>
<p>During normalisation the type checker (given during construction) is used to distinguish boolean from not-boolean expressions. Note that the generated expressions may be type checked, i.e. the type checker remember their types.</p>
<p>The normaliser caches processed expressions. So, if the same expression is given, the same result will be returned.</p>
<p>The returned expression is always flattened and expanded. Also, it is created by find_node function, therefore it belongs to the node package (i.e. do not modify it).</p>
<p>NOTE: if only predicates are required at the end and not the whole normalized expressions, then it is better to use <a class="el" href="structPredicateExtractor.html" title="Public interface for a predicate-extractor class. ">PredicateExtractor</a> class. </p>

</div>
</div>
<a id="aabeb29b7086fa0389ee3563d2bde8533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabeb29b7086fa0389ee3563d2bde8533">&#9670;&nbsp;</a></span>PredicateNormaliser_normalise_expr_no_expand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr PredicateNormaliser_normalise_expr_no_expand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PredicateNormaliser_8h.html#aefa15e9dd0888af4a0989e9abf8cb63b">PredicateNormaliser_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function performs predicate-normalisation of a generic boolean expression, but it does not expand the defines. </p>
<p>This is similar to the PredicateNormaliser_normalise_expr, i.e. it returns a flattened expression with predicates on the leaves, but differently from PredicateNormaliser_normalise_expr, the defines are not expanded.</p>
<p>The returned expression is created by find_node function, therefore it belongs to the node package (i.e. do not modify it).</p>
<p>NOTE: if only predicates are required at the end and not the whole normalized expressions, then it is better to use <a class="el" href="structPredicateExtractor.html" title="Public interface for a predicate-extractor class. ">PredicateExtractor</a> class. </p>

</div>
</div>
<a id="ad2007c0753fee806e927d9d5830077b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2007c0753fee806e927d9d5830077b5">&#9670;&nbsp;</a></span>PredicateNormaliser_normalise_specification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr PredicateNormaliser_normalise_specification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PredicateNormaliser_8h.html#aefa15e9dd0888af4a0989e9abf8cb63b">PredicateNormaliser_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function performs predicate-normalisation of specification (SPEC, LTLSPEC, etc) </p>
<p>This function does the same things as PredicateNormaliser_normalise_expr, except that the input expression must be a specification (such expression are returned by Prop_get_expr_core) </p>

</div>
</div>
<a id="a48fcb2c649244387686336e04ce018c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fcb2c649244387686336e04ce018c6">&#9670;&nbsp;</a></span>PredicateNormaliser_print_predicates_only()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PredicateNormaliser_print_predicates_only </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="PredicateNormaliser_8h.html#aefa15e9dd0888af4a0989e9abf8cb63b">PredicateNormaliser_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function prints out the expressions's predicates, i.e. subexpressions which have not-boolean operands. </p>
<p>Only expressions obtained with PredicateNormaliser_normalise_expr and with the same predicate-normaliser (i.e. 'self') can be given to this function.</p>
<p>This function just walks the exressions, tries to find a subexpression with not-boolean operands then print it.</p>
<p>PredicateNormaliser_get_predicates_only </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/root/research/NuSMV-2.6.0/NuSMV/code/nusmv/core/compile/<a class="el" href="PredicateNormaliser_8h_source.html">PredicateNormaliser.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 18 2022 22:26:36 for NuSMV Developers Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
