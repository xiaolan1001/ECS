<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NuSMV Developers Manual: NodeWalker Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NuSMV Developers Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">NodeWalker Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Private and protected interface of class '<a class="el" href="structNodeWalker.html" title="Private and protected interface of class &#39;NodeWalker&#39;. ">NodeWalker</a>'.  
 <a href="structNodeWalker.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="NodeWalker__private_8h_source.html">NodeWalker_private.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2ee44376bc0efe35131c01f9ec631f3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#a2ee44376bc0efe35131c01f9ec631f3c">INHERITS_FROM</a> (<a class="el" href="structEnvObject.html">EnvObject</a>)</td></tr>
<tr class="separator:a2ee44376bc0efe35131c01f9ec631f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:afba5fa56d30d5f8034abaf5f1e91ca79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#afba5fa56d30d5f8034abaf5f1e91ca79">can_handle_null</a></td></tr>
<tr class="separator:afba5fa56d30d5f8034abaf5f1e91ca79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeacb0f7eae349a2e1a4c72ea6f5d4d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#adeacb0f7eae349a2e1a4c72ea6f5d4d8">low</a></td></tr>
<tr class="separator:adeacb0f7eae349a2e1a4c72ea6f5d4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f18dbc2aa34026b0d334a46f297a718"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MasterNodeWalker_8h.html#a0b3ff8fd3cb366559c7250176d203719">MasterNodeWalker_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#a1f18dbc2aa34026b0d334a46f297a718">master</a></td></tr>
<tr class="separator:a1f18dbc2aa34026b0d334a46f297a718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dd51e102a756f2cb47a25dfa3ef734"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#a91dd51e102a756f2cb47a25dfa3ef734">name</a></td></tr>
<tr class="separator:a91dd51e102a756f2cb47a25dfa3ef734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532266b861bdfae109b187c9519af9be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray__t.html">array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#a532266b861bdfae109b187c9519af9be">node_transformations</a></td></tr>
<tr class="separator:a532266b861bdfae109b187c9519af9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9bf1a157fdcd85ca395176a57e9d18"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#a3b9bf1a157fdcd85ca395176a57e9d18">num</a></td></tr>
<tr class="separator:a3b9bf1a157fdcd85ca395176a57e9d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aad08193c3ad3c326a6db9e50e4038b01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#aad08193c3ad3c326a6db9e50e4038b01">node_walker_can_handle_null_node</a> (const <a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a> self)</td></tr>
<tr class="memdesc:aad08193c3ad3c326a6db9e50e4038b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the walker can handle the null case.  <a href="#aad08193c3ad3c326a6db9e50e4038b01">More...</a><br /></td></tr>
<tr class="separator:aad08193c3ad3c326a6db9e50e4038b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08a4816af50cfbd05cfefe47b905f89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#aa08a4816af50cfbd05cfefe47b905f89">node_walker_deinit</a> (<a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a> self)</td></tr>
<tr class="memdesc:aa08a4816af50cfbd05cfefe47b905f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structNodeWalker.html" title="Private and protected interface of class &#39;NodeWalker&#39;. ">NodeWalker</a> class private deinitializer.  <a href="#aa08a4816af50cfbd05cfefe47b905f89">More...</a><br /></td></tr>
<tr class="separator:aa08a4816af50cfbd05cfefe47b905f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32600796418c6e7ef894f1268f438f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#ab32600796418c6e7ef894f1268f438f3">node_walker_init</a> (<a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a> self, const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a> env, const char *<a class="el" href="structNodeWalker.html#a91dd51e102a756f2cb47a25dfa3ef734">name</a>, int <a class="el" href="structNodeWalker.html#adeacb0f7eae349a2e1a4c72ea6f5d4d8">low</a>, size_t <a class="el" href="structNodeWalker.html#a3b9bf1a157fdcd85ca395176a57e9d18">num</a>, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="structNodeWalker.html#afba5fa56d30d5f8034abaf5f1e91ca79">can_handle_null</a>)</td></tr>
<tr class="memdesc:ab32600796418c6e7ef894f1268f438f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structNodeWalker.html" title="Private and protected interface of class &#39;NodeWalker&#39;. ">NodeWalker</a> class private initializer.  <a href="#ab32600796418c6e7ef894f1268f438f3">More...</a><br /></td></tr>
<tr class="separator:ab32600796418c6e7ef894f1268f438f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00d65146439711085fa401459ad0b0d"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#ab00d65146439711085fa401459ad0b0d">node_walker_run_transformation_chain</a> (const <a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a> self, node_ptr <a class="el" href="structnode.html">node</a>)</td></tr>
<tr class="separator:ab00d65146439711085fa401459ad0b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6313dca3a234a137cd0e3087fe0db1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#a3d6313dca3a234a137cd0e3087fe0db1">node_walker_set_master</a> (<a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a> self, <a class="el" href="MasterNodeWalker_8h.html#a0b3ff8fd3cb366559c7250176d203719">MasterNodeWalker_ptr</a> <a class="el" href="structNodeWalker.html#a1f18dbc2aa34026b0d334a46f297a718">master</a>)</td></tr>
<tr class="memdesc:a3d6313dca3a234a137cd0e3087fe0db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is privately called by master while registering the walker.  <a href="#a3d6313dca3a234a137cd0e3087fe0db1">More...</a><br /></td></tr>
<tr class="separator:a3d6313dca3a234a137cd0e3087fe0db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6598cffce9176f05b7af9d933fc608fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#a6598cffce9176f05b7af9d933fc608fa">NodeWalker_add_node_transformation</a> (<a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a> self, const <a class="el" href="structNodeTransformation.html">NodeTransformation</a> *nt)</td></tr>
<tr class="memdesc:a6598cffce9176f05b7af9d933fc608fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node tranformation function that will be called at each step before printing.  <a href="#a6598cffce9176f05b7af9d933fc608fa">More...</a><br /></td></tr>
<tr class="separator:a6598cffce9176f05b7af9d933fc608fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8acaeb88822f6cf3c5116d8fdd76716"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#af8acaeb88822f6cf3c5116d8fdd76716">NodeWalker_can_handle</a> (const <a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a> self, node_ptr n)</td></tr>
<tr class="memdesc:af8acaeb88822f6cf3c5116d8fdd76716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node belongs to the partition associated to this walker.  <a href="#af8acaeb88822f6cf3c5116d8fdd76716">More...</a><br /></td></tr>
<tr class="separator:af8acaeb88822f6cf3c5116d8fdd76716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cfc5383d01c4bf7bfa99e496e784f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#a68cfc5383d01c4bf7bfa99e496e784f0">NodeWalker_collides</a> (const <a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a> self, const <a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a> other)</td></tr>
<tr class="memdesc:a68cfc5383d01c4bf7bfa99e496e784f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if self collides with other in terms of their respective symbol sets.  <a href="#a68cfc5383d01c4bf7bfa99e496e784f0">More...</a><br /></td></tr>
<tr class="separator:a68cfc5383d01c4bf7bfa99e496e784f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11983c34b068c6af6739f5321335f451"><td class="memItemLeft" align="right" valign="top"><a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#a11983c34b068c6af6739f5321335f451">NodeWalker_create</a> (const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a> env, const char *<a class="el" href="structNodeWalker.html#a91dd51e102a756f2cb47a25dfa3ef734">name</a>, int <a class="el" href="structNodeWalker.html#adeacb0f7eae349a2e1a4c72ea6f5d4d8">low</a>, size_t <a class="el" href="structNodeWalker.html#a3b9bf1a157fdcd85ca395176a57e9d18">num</a>, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="structNodeWalker.html#afba5fa56d30d5f8034abaf5f1e91ca79">can_handle_null</a>)</td></tr>
<tr class="memdesc:a11983c34b068c6af6739f5321335f451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a walker. To be usable, the walker will have to be registered to a <a class="el" href="structMasterNodeWalker.html" title="Private interface of class &#39;MasterNodeWalker&#39;, to be used by derivated classes. ">MasterNodeWalker</a>.  <a href="#a11983c34b068c6af6739f5321335f451">More...</a><br /></td></tr>
<tr class="separator:a11983c34b068c6af6739f5321335f451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d878b492089c7c3ad7f99dce545ced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#a88d878b492089c7c3ad7f99dce545ced">NodeWalker_destroy</a> (<a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a> self)</td></tr>
<tr class="memdesc:a88d878b492089c7c3ad7f99dce545ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structNodeWalker.html" title="Private and protected interface of class &#39;NodeWalker&#39;. ">NodeWalker</a> class destructor.  <a href="#a88d878b492089c7c3ad7f99dce545ced">More...</a><br /></td></tr>
<tr class="separator:a88d878b492089c7c3ad7f99dce545ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c72a0d437f33713c2da5d566ad8d71b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#a5c72a0d437f33713c2da5d566ad8d71b">NodeWalker_get_name</a> (const <a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a> self)</td></tr>
<tr class="memdesc:a5c72a0d437f33713c2da5d566ad8d71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the walker name as a string.  <a href="#a5c72a0d437f33713c2da5d566ad8d71b">More...</a><br /></td></tr>
<tr class="separator:a5c72a0d437f33713c2da5d566ad8d71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add61e6d0bfc5791ae89a6a64cbc98f7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeWalker.html#add61e6d0bfc5791ae89a6a64cbc98f7f">NodeWalker_remove_node_transformation</a> (<a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a> self, int tranf_handle)</td></tr>
<tr class="separator:add61e6d0bfc5791ae89a6a64cbc98f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Private and protected interface of class '<a class="el" href="structNodeWalker.html" title="Private and protected interface of class &#39;NodeWalker&#39;. ">NodeWalker</a>'. </p>
<p>Public interface of class '<a class="el" href="structNodeWalker.html" title="Private and protected interface of class &#39;NodeWalker&#39;. ">NodeWalker</a>'.</p>
<dl class="section author"><dt>Author</dt><dd>Roberto Cavada This file can be included only by derived and friend classes</dd></dl>
<p><a class="el" href="structNodeWalker.html" title="Private and protected interface of class &#39;NodeWalker&#39;. ">NodeWalker</a> class definition derived from class <a class="el" href="structObject.html" title="Basic (private) services for object-oriented design. ">Object</a></p>
<dl class="section see"><dt>See also</dt><dd>Base class <a class="el" href="structObject.html" title="Basic (private) services for object-oriented design. ">Object</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>Roberto Cavada A <a class="el" href="structNodeWalker.html" title="Private and protected interface of class &#39;NodeWalker&#39;. ">NodeWalker</a> instance is used to traverse a parse tree. Depending on the purpose, the class must be specialized. For example a node printer, or a type checker would derive from this class. A node walker can handle a partition over the set of node's types, and one instance can live into a 'master' that is responsible for calling the right walker depending on the node it is traversing.</dd></dl>
<p>See for example classes node.printers.PrinterBase and compile.type_checking.checkers.CheckerBase</p>
<p>Definition of the public accessor for class <a class="el" href="structNodeWalker.html" title="Private and protected interface of class &#39;NodeWalker&#39;. ">NodeWalker</a> </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2ee44376bc0efe35131c01f9ec631f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee44376bc0efe35131c01f9ec631f3c">&#9670;&nbsp;</a></span>INHERITS_FROM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeWalker::INHERITS_FROM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEnvObject.html">EnvObject</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aad08193c3ad3c326a6db9e50e4038b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad08193c3ad3c326a6db9e50e4038b01">&#9670;&nbsp;</a></span>node_walker_can_handle_null_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> node_walker_can_handle_null_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the walker can handle the null case. </p>
<p>The null case is trasversal to the partitions set, so only the first registered walker that can handle null case will be called to handle the null node. </p>

</div>
</div>
<a id="aa08a4816af50cfbd05cfefe47b905f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08a4816af50cfbd05cfefe47b905f89">&#9670;&nbsp;</a></span>node_walker_deinit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void node_walker_deinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="structNodeWalker.html" title="Private and protected interface of class &#39;NodeWalker&#39;. ">NodeWalker</a> class private deinitializer. </p>
<p>The <a class="el" href="structNodeWalker.html" title="Private and protected interface of class &#39;NodeWalker&#39;. ">NodeWalker</a> class private deinitializer</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structNodeWalker.html#a88d878b492089c7c3ad7f99dce545ced" title="The NodeWalker class destructor. ">NodeWalker_destroy</a> </dd></dl>

</div>
</div>
<a id="ab32600796418c6e7ef894f1268f438f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32600796418c6e7ef894f1268f438f3">&#9670;&nbsp;</a></span>node_walker_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void node_walker_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>can_handle_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="structNodeWalker.html" title="Private and protected interface of class &#39;NodeWalker&#39;. ">NodeWalker</a> class private initializer. </p>
<p>The <a class="el" href="structNodeWalker.html" title="Private and protected interface of class &#39;NodeWalker&#39;. ">NodeWalker</a> class private initializer</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structNodeWalker.html#a11983c34b068c6af6739f5321335f451" title="Creates and initializes a walker. To be usable, the walker will have to be registered to a MasterNode...">NodeWalker_create</a> </dd></dl>

</div>
</div>
<a id="ab00d65146439711085fa401459ad0b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00d65146439711085fa401459ad0b0d">&#9670;&nbsp;</a></span>node_walker_run_transformation_chain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr node_walker_run_transformation_chain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Protected method to call the transformation chain of nodes iff the user has set a transformation chain.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structNodeWalker.html#a6598cffce9176f05b7af9d933fc608fa" title="Adds a node tranformation function that will be called at each step before printing. ">NodeWalker_add_node_transformation</a> </dd></dl>

</div>
</div>
<a id="a3d6313dca3a234a137cd0e3087fe0db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6313dca3a234a137cd0e3087fe0db1">&#9670;&nbsp;</a></span>node_walker_set_master()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void node_walker_set_master </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MasterNodeWalker_8h.html#a0b3ff8fd3cb366559c7250176d203719">MasterNodeWalker_ptr</a>&#160;</td>
          <td class="paramname"><em>master</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is privately called by master while registering the walker. </p>
<p>If already assigned to a master, it unregisters itself from the old master before setting the new master </p>

</div>
</div>
<a id="a6598cffce9176f05b7af9d933fc608fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6598cffce9176f05b7af9d933fc608fa">&#9670;&nbsp;</a></span>NodeWalker_add_node_transformation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int NodeWalker_add_node_transformation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structNodeTransformation.html">NodeTransformation</a> *&#160;</td>
          <td class="paramname"><em>nt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a node tranformation function that will be called at each step before printing. </p>
<p>A shallow copy of the given structure will be done and kept internally. Returned handle can be used later to remove the transformation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structNodeWalker.html#add61e6d0bfc5791ae89a6a64cbc98f7f">NodeWalker_remove_node_transformation</a> </dd></dl>

</div>
</div>
<a id="af8acaeb88822f6cf3c5116d8fdd76716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8acaeb88822f6cf3c5116d8fdd76716">&#9670;&nbsp;</a></span>NodeWalker_can_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> NodeWalker_can_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given node belongs to the partition associated to this walker. </p>
<p>Returns true if the given node belongs to the partition associated to this walker. If n is Nil then the specific walker will be asked </p>

</div>
</div>
<a id="a68cfc5383d01c4bf7bfa99e496e784f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68cfc5383d01c4bf7bfa99e496e784f0">&#9670;&nbsp;</a></span>NodeWalker_collides()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> NodeWalker_collides </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if self collides with other in terms of their respective symbol sets. </p>
<p>Returns true if self and other's symbols set collide (i.e. are not partitions). Returns false if they are ok. </p>

</div>
</div>
<a id="a11983c34b068c6af6739f5321335f451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11983c34b068c6af6739f5321335f451">&#9670;&nbsp;</a></span>NodeWalker_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a> NodeWalker_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NuSMVEnv_8h.html#a5f07fb120e7f4b2febca587acbeae8c0">NuSMVEnv_ptr</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>can_handle_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and initializes a walker. To be usable, the walker will have to be registered to a <a class="el" href="structMasterNodeWalker.html" title="Private interface of class &#39;MasterNodeWalker&#39;, to be used by derivated classes. ">MasterNodeWalker</a>. </p>
<p>To each walker is associated a partition of consecutive indices over the symbols set. The lowest index of the partition is given through the parameter low, while num is the partition size. Name is used to easily identify walker instances.</p>
<p>Constructor is private, as this class is a virtual base class.</p>
<p>can_handle_null must be set to true if the walker can handle the null case. The null case is trasversal to the partitions set, so only the first registered walker that can handle null case will be called to handle the null node.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structNodeWalker.html#a88d878b492089c7c3ad7f99dce545ced" title="The NodeWalker class destructor. ">NodeWalker_destroy</a> </dd></dl>

</div>
</div>
<a id="a88d878b492089c7c3ad7f99dce545ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d878b492089c7c3ad7f99dce545ced">&#9670;&nbsp;</a></span>NodeWalker_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NodeWalker_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="structNodeWalker.html" title="Private and protected interface of class &#39;NodeWalker&#39;. ">NodeWalker</a> class destructor. </p>
<p>The <a class="el" href="structNodeWalker.html" title="Private and protected interface of class &#39;NodeWalker&#39;. ">NodeWalker</a> class destructor. If registerd to a master, it unregisters itself before finalizing.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structNodeWalker.html#a11983c34b068c6af6739f5321335f451" title="Creates and initializes a walker. To be usable, the walker will have to be registered to a MasterNode...">NodeWalker_create</a> </dd></dl>

</div>
</div>
<a id="a5c72a0d437f33713c2da5d566ad8d71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c72a0d437f33713c2da5d566ad8d71b">&#9670;&nbsp;</a></span>NodeWalker_get_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * NodeWalker_get_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the walker name as a string. </p>
<p>The returned string belongs to self, do not deallocate or change it. </p>

</div>
</div>
<a id="add61e6d0bfc5791ae89a6a64cbc98f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add61e6d0bfc5791ae89a6a64cbc98f7f">&#9670;&nbsp;</a></span>NodeWalker_remove_node_transformation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NodeWalker_remove_node_transformation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NodeWalker_8h.html#a4719714abde5309c9e1b148930f5471b">NodeWalker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tranf_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a previously registered node transformation. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structNodeWalker.html#a6598cffce9176f05b7af9d933fc608fa" title="Adds a node tranformation function that will be called at each step before printing. ">NodeWalker_add_node_transformation</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="afba5fa56d30d5f8034abaf5f1e91ca79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba5fa56d30d5f8034abaf5f1e91ca79">&#9670;&nbsp;</a></span>can_handle_null</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> NodeWalker::can_handle_null</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adeacb0f7eae349a2e1a4c72ea6f5d4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeacb0f7eae349a2e1a4c72ea6f5d4d8">&#9670;&nbsp;</a></span>low</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NodeWalker::low</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f18dbc2aa34026b0d334a46f297a718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f18dbc2aa34026b0d334a46f297a718">&#9670;&nbsp;</a></span>master</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MasterNodeWalker_8h.html#a0b3ff8fd3cb366559c7250176d203719">MasterNodeWalker_ptr</a> NodeWalker::master</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91dd51e102a756f2cb47a25dfa3ef734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91dd51e102a756f2cb47a25dfa3ef734">&#9670;&nbsp;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NodeWalker::name</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a532266b861bdfae109b187c9519af9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532266b861bdfae109b187c9519af9be">&#9670;&nbsp;</a></span>node_transformations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray__t.html">array_t</a>* NodeWalker::node_transformations</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b9bf1a157fdcd85ca395176a57e9d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9bf1a157fdcd85ca395176a57e9d18">&#9670;&nbsp;</a></span>num</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NodeWalker::num</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>/root/research/NuSMV-2.6.0/NuSMV/code/nusmv/core/node/<a class="el" href="NodeWalker__private_8h_source.html">NodeWalker_private.h</a></li>
<li>/root/research/NuSMV-2.6.0/NuSMV/code/nusmv/core/node/<a class="el" href="NodeWalker_8h_source.html">NodeWalker.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 18 2022 22:26:36 for NuSMV Developers Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
