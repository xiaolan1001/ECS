<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NuSMV Developers Manual: BeEnc Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NuSMV Developers Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">BeEnc Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Private and protected interface of class '<a class="el" href="structBeEnc.html" title="Private and protected interface of class &#39;BeEnc&#39;. ">BeEnc</a>'.  
 <a href="structBeEnc.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BeEnc__private_8h_source.html">BeEnc_private.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa6d397e35411091aa1898f182a5456da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#aa6d397e35411091aa1898f182a5456da">INHERITS_FROM</a> (<a class="el" href="structBoolEncClient.html">BoolEncClient</a>)</td></tr>
<tr class="separator:aa6d397e35411091aa1898f182a5456da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a3ea31de6e85b6a8d39bd5ab55f1913ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a3ea31de6e85b6a8d39bd5ab55f1913ef">avail_phy_idx_queue</a></td></tr>
<tr class="separator:a3ea31de6e85b6a8d39bd5ab55f1913ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa993e664a7bb7281d9d4ff57c09fdb9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="be_8h.html#afdc4ea4bbf871ce77b7404f9b60cb438">Be_Manager_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#aa993e664a7bb7281d9d4ff57c09fdb9d">be_mgr</a></td></tr>
<tr class="separator:aa993e664a7bb7281d9d4ff57c09fdb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcc0f9172cefc14f8b67172f1511ad3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a8bcc0f9172cefc14f8b67172f1511ad3">frozen_vars_num</a></td></tr>
<tr class="separator:a8bcc0f9172cefc14f8b67172f1511ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab719d535cb22dd65b0b013d4aed8c643"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#ab719d535cb22dd65b0b013d4aed8c643">grow_excess</a></td></tr>
<tr class="separator:ab719d535cb22dd65b0b013d4aed8c643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec9b276e981c7aac5979681114b7be8"><td class="memItemLeft" align="right" valign="top">node_ptr *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a6ec9b276e981c7aac5979681114b7be8">index2name</a></td></tr>
<tr class="separator:a6ec9b276e981c7aac5979681114b7be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd73195145c853a880cc8a1927189152"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#acd73195145c853a880cc8a1927189152">index2name_size</a></td></tr>
<tr class="separator:acd73195145c853a880cc8a1927189152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0712408b72e413c9c02f4fac1f53cd63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a0712408b72e413c9c02f4fac1f53cd63">input_vars_num</a></td></tr>
<tr class="separator:a0712408b72e413c9c02f4fac1f53cd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734cf1e69a04ca2e2ca4cade58cada52"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a734cf1e69a04ca2e2ca4cade58cada52">log2phy</a></td></tr>
<tr class="separator:a734cf1e69a04ca2e2ca4cade58cada52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d0063753653681bae20b526a6f804e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a56d0063753653681bae20b526a6f804e">log_idx_capacity</a></td></tr>
<tr class="separator:a56d0063753653681bae20b526a6f804e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada69025a5bdc414be7fb04bb112397a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#ada69025a5bdc414be7fb04bb112397a1">max_allocated_time</a></td></tr>
<tr class="separator:ada69025a5bdc414be7fb04bb112397a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e98002ee537d237ef588c22f24455d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a60e98002ee537d237ef588c22f24455d">max_used_phy_idx</a></td></tr>
<tr class="separator:a60e98002ee537d237ef588c22f24455d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae715d92022f76aea235f123a871914b1"><td class="memItemLeft" align="right" valign="top">hash_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#ae715d92022f76aea235f123a871914b1">name2be</a></td></tr>
<tr class="separator:ae715d92022f76aea235f123a871914b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018be417642c03edb96cb4ab43671ef4"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a018be417642c03edb96cb4ab43671ef4">phy2log</a></td></tr>
<tr class="separator:a018be417642c03edb96cb4ab43671ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230420578115e5323de8647d4203b2d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a230420578115e5323de8647d4203b2d0">phy_idx_capacity</a></td></tr>
<tr class="separator:a230420578115e5323de8647d4203b2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6a69460cab4a5eb34f475f21a327bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__table.html">st_table</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a6b6a69460cab4a5eb34f475f21a327bb">shift_hash</a></td></tr>
<tr class="separator:a6b6a69460cab4a5eb34f475f21a327bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac049576dc55ea78d2f06cccf98addd44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#ac049576dc55ea78d2f06cccf98addd44">state_vars_num</a></td></tr>
<tr class="separator:ac049576dc55ea78d2f06cccf98addd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842dd04b003e8c4961c1aee5cb92ef5f"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a842dd04b003e8c4961c1aee5cb92ef5f">subst_array</a></td></tr>
<tr class="separator:a842dd04b003e8c4961c1aee5cb92ef5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355b299a2c88fb2f4c025e4154b43da0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a355b299a2c88fb2f4c025e4154b43da0">subst_array_size</a></td></tr>
<tr class="separator:a355b299a2c88fb2f4c025e4154b43da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:acbee72f794aae6298da384efe9c3c67f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#acbee72f794aae6298da384efe9c3c67f">be_enc_deinit</a> (<a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self)</td></tr>
<tr class="separator:acbee72f794aae6298da384efe9c3c67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a27f69978611d5e7a95b9ab9296545f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a9a27f69978611d5e7a95b9ab9296545f">be_enc_init</a> (<a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, <a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a> symb_table, <a class="el" href="BoolEnc_8h.html#aa0e4c6a22ddb7ac20c5dc94254d859e9">BoolEnc_ptr</a> bool_enc)</td></tr>
<tr class="separator:a9a27f69978611d5e7a95b9ab9296545f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38861d1cef1f42e23defda0bf6cad491"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a38861d1cef1f42e23defda0bf6cad491">BeEnc_create</a> (<a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a> symb_table, <a class="el" href="BoolEnc_8h.html#aa0e4c6a22ddb7ac20c5dc94254d859e9">BoolEnc_ptr</a> bool_enc)</td></tr>
<tr class="memdesc:a38861d1cef1f42e23defda0bf6cad491"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structBeEnc.html" title="Private and protected interface of class &#39;BeEnc&#39;. ">BeEnc</a> class constructor.  <a href="#a38861d1cef1f42e23defda0bf6cad491">More...</a><br /></td></tr>
<tr class="separator:a38861d1cef1f42e23defda0bf6cad491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4280fe23bc4ff1c55b8bbc33219d5f48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="object_8h.html#a6dd04ec3fff7c731cc71d6796699d902">VIRTUAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a4280fe23bc4ff1c55b8bbc33219d5f48">BeEnc_destroy</a> (<a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self)</td></tr>
<tr class="memdesc:a4280fe23bc4ff1c55b8bbc33219d5f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structBeEnc.html" title="Private and protected interface of class &#39;BeEnc&#39;. ">BeEnc</a> class destructor.  <a href="#a4280fe23bc4ff1c55b8bbc33219d5f48">More...</a><br /></td></tr>
<tr class="separator:a4280fe23bc4ff1c55b8bbc33219d5f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01954b50dcbbd584fb2336da59f9a5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="be_8h.html#afdc4ea4bbf871ce77b7404f9b60cb438">Be_Manager_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#ab01954b50dcbbd584fb2336da59f9a5c">BeEnc_get_be_manager</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self)</td></tr>
<tr class="memdesc:ab01954b50dcbbd584fb2336da59f9a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Returns</b> the <code>Boolean Expressions manager</code> contained into the variable manager, to be used by any operation on BEs  <a href="#ab01954b50dcbbd584fb2336da59f9a5c">More...</a><br /></td></tr>
<tr class="separator:ab01954b50dcbbd584fb2336da59f9a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af943551a5cdaa162f49b9f33601890"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a6af943551a5cdaa162f49b9f33601890">BeEnc_get_first_untimed_var_index</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, <a class="el" href="BeEnc_8h.html#a9a89d3f9dde7aa989c06e40c5d8827fc">BeVarType</a> type)</td></tr>
<tr class="memdesc:a6af943551a5cdaa162f49b9f33601890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this to begin an iteration between a given category of variables.  <a href="#a6af943551a5cdaa162f49b9f33601890">More...</a><br /></td></tr>
<tr class="separator:a6af943551a5cdaa162f49b9f33601890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d979e60f64fe95dad218ed12654a39"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#ab3d979e60f64fe95dad218ed12654a39">BeEnc_get_frozen_vars_num</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self)</td></tr>
<tr class="memdesc:ab3d979e60f64fe95dad218ed12654a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>number of frozen variables currently handled by the encoder</code>  <a href="#ab3d979e60f64fe95dad218ed12654a39">More...</a><br /></td></tr>
<tr class="separator:ab3d979e60f64fe95dad218ed12654a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee705b317eda0a5baae2b1b4b9e504e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#aee705b317eda0a5baae2b1b4b9e504e5">BeEnc_get_input_vars_num</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self)</td></tr>
<tr class="memdesc:aee705b317eda0a5baae2b1b4b9e504e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>number of input variables currently handled by the encoder</code>  <a href="#aee705b317eda0a5baae2b1b4b9e504e5">More...</a><br /></td></tr>
<tr class="separator:aee705b317eda0a5baae2b1b4b9e504e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b96f0369965312836f2370104be7d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a19b96f0369965312836f2370104be7d6">BeEnc_get_max_time</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self)</td></tr>
<tr class="memdesc:a19b96f0369965312836f2370104be7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Returns</b> the <code>maximum allocated time </code>  <a href="#a19b96f0369965312836f2370104be7d6">More...</a><br /></td></tr>
<tr class="separator:a19b96f0369965312836f2370104be7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff9e21a2031a780e0c2d542a6f1198b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a2ff9e21a2031a780e0c2d542a6f1198b">BeEnc_get_next_var_index</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, int var_index, <a class="el" href="BeEnc_8h.html#a9a89d3f9dde7aa989c06e40c5d8827fc">BeVarType</a> type)</td></tr>
<tr class="memdesc:a2ff9e21a2031a780e0c2d542a6f1198b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to sequentially iterate over a selected category of variables.  <a href="#a2ff9e21a2031a780e0c2d542a6f1198b">More...</a><br /></td></tr>
<tr class="separator:a2ff9e21a2031a780e0c2d542a6f1198b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7685a98b99de25d1cf2a1064116b8b7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a7685a98b99de25d1cf2a1064116b8b7e">BeEnc_get_state_vars_num</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self)</td></tr>
<tr class="memdesc:a7685a98b99de25d1cf2a1064116b8b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>number of state variables currently handled by the encoder</code>  <a href="#a7685a98b99de25d1cf2a1064116b8b7e">More...</a><br /></td></tr>
<tr class="separator:a7685a98b99de25d1cf2a1064116b8b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aea4ccc207a8cf6d84eab57234602f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a2aea4ccc207a8cf6d84eab57234602f5">BeEnc_get_var_index_with_offset</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, int from_index, int offset, <a class="el" href="BeEnc_8h.html#a9a89d3f9dde7aa989c06e40c5d8827fc">BeVarType</a> type)</td></tr>
<tr class="memdesc:a2aea4ccc207a8cf6d84eab57234602f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to randomly iterate over a selected category of variables within the untimed block.  <a href="#a2aea4ccc207a8cf6d84eab57234602f5">More...</a><br /></td></tr>
<tr class="separator:a2aea4ccc207a8cf6d84eab57234602f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86186840eada2836f2a91d0f2216e2e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a86186840eada2836f2a91d0f2216e2e0">BeEnc_get_vars_num</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self)</td></tr>
<tr class="memdesc:a86186840eada2836f2a91d0f2216e2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>number of input and state variables currently handled by the encoder</code>  <a href="#a86186840eada2836f2a91d0f2216e2e0">More...</a><br /></td></tr>
<tr class="separator:a86186840eada2836f2a91d0f2216e2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d8506aacbde2f213b953e305c25961"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#ab1d8506aacbde2f213b953e305c25961">BeEnc_index_to_name</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const int index)</td></tr>
<tr class="memdesc:ab1d8506aacbde2f213b953e305c25961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the index of a be var, returns the symbolic variable name.  <a href="#ab1d8506aacbde2f213b953e305c25961">More...</a><br /></td></tr>
<tr class="separator:ab1d8506aacbde2f213b953e305c25961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509b52f84e38ba5f8f50252b3d019b3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a509b52f84e38ba5f8f50252b3d019b3c">BeEnc_index_to_time</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const int index)</td></tr>
<tr class="memdesc:a509b52f84e38ba5f8f50252b3d019b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a state or input variable index this returns the time the variable is allocated.  <a href="#a509b52f84e38ba5f8f50252b3d019b3c">More...</a><br /></td></tr>
<tr class="separator:a509b52f84e38ba5f8f50252b3d019b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f3e3d38bd32a094b10cade94e3eec9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#ae5f3e3d38bd32a094b10cade94e3eec9">BeEnc_index_to_timed</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const int index, const int time)</td></tr>
<tr class="memdesc:ae5f3e3d38bd32a094b10cade94e3eec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an untimed variable index, returns the corresponding BE variable at the given time.  <a href="#ae5f3e3d38bd32a094b10cade94e3eec9">More...</a><br /></td></tr>
<tr class="separator:ae5f3e3d38bd32a094b10cade94e3eec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4072671bde353e7df579f2ed29d5c354"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a4072671bde353e7df579f2ed29d5c354">BeEnc_index_to_untimed_index</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const int index)</td></tr>
<tr class="memdesc:a4072671bde353e7df579f2ed29d5c354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a timed variable index, returns the corresponding untimed BE variable index.  <a href="#a4072671bde353e7df579f2ed29d5c354">More...</a><br /></td></tr>
<tr class="separator:a4072671bde353e7df579f2ed29d5c354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f593d52704bb9441a5adb45fea3c68b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a7f593d52704bb9441a5adb45fea3c68b">BeEnc_index_to_var</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const int index)</td></tr>
<tr class="memdesc:a7f593d52704bb9441a5adb45fea3c68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a variable index, returns the corresponding be variable.  <a href="#a7f593d52704bb9441a5adb45fea3c68b">More...</a><br /></td></tr>
<tr class="separator:a7f593d52704bb9441a5adb45fea3c68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6763d2e6f3c670bf37ea5104c971fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#aee6763d2e6f3c670bf37ea5104c971fe">BeEnc_is_index_frozen_var</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const int index)</td></tr>
<tr class="memdesc:aee6763d2e6f3c670bf37ea5104c971fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether given index corresponds to a frozen variable.  <a href="#aee6763d2e6f3c670bf37ea5104c971fe">More...</a><br /></td></tr>
<tr class="separator:aee6763d2e6f3c670bf37ea5104c971fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f612ac70f1d27d9f8babf3825a57a81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a8f612ac70f1d27d9f8babf3825a57a81">BeEnc_is_index_input_var</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const int index)</td></tr>
<tr class="memdesc:a8f612ac70f1d27d9f8babf3825a57a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether given index corresponds to an input variable.  <a href="#a8f612ac70f1d27d9f8babf3825a57a81">More...</a><br /></td></tr>
<tr class="separator:a8f612ac70f1d27d9f8babf3825a57a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93d9945d783a73bd6c6942d01004f92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#af93d9945d783a73bd6c6942d01004f92">BeEnc_is_index_state_var</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const int index)</td></tr>
<tr class="memdesc:af93d9945d783a73bd6c6942d01004f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether given index corresponds to a state variable.  <a href="#af93d9945d783a73bd6c6942d01004f92">More...</a><br /></td></tr>
<tr class="separator:af93d9945d783a73bd6c6942d01004f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098f6651c9ef9e9d259df99666c2f2ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a098f6651c9ef9e9d259df99666c2f2ae">BeEnc_is_index_untimed</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const int index)</td></tr>
<tr class="memdesc:a098f6651c9ef9e9d259df99666c2f2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether given index corresponds to an untimed variable.  <a href="#a098f6651c9ef9e9d259df99666c2f2ae">More...</a><br /></td></tr>
<tr class="separator:a098f6651c9ef9e9d259df99666c2f2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bc4dca1a151d3abbbf67f7750d25e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a55bc4dca1a151d3abbbf67f7750d25e8">BeEnc_is_index_untimed_curr</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const int index)</td></tr>
<tr class="memdesc:a55bc4dca1a151d3abbbf67f7750d25e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether given index corresponds to an untimed current state variable.  <a href="#a55bc4dca1a151d3abbbf67f7750d25e8">More...</a><br /></td></tr>
<tr class="separator:a55bc4dca1a151d3abbbf67f7750d25e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58dcb3b5991acec850d5f0d82d6e71e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a58dcb3b5991acec850d5f0d82d6e71e4">BeEnc_is_index_untimed_curr_frozen_input</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const int index)</td></tr>
<tr class="memdesc:a58dcb3b5991acec850d5f0d82d6e71e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether given index corresponds to an untimed current state variable, or an untimed frozen, or an untimed input variable.  <a href="#a58dcb3b5991acec850d5f0d82d6e71e4">More...</a><br /></td></tr>
<tr class="separator:a58dcb3b5991acec850d5f0d82d6e71e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14fda4289cf841d02cb57fc1c24a4ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#ab14fda4289cf841d02cb57fc1c24a4ad">BeEnc_is_index_untimed_frozen</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const int index)</td></tr>
<tr class="memdesc:ab14fda4289cf841d02cb57fc1c24a4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether given index corresponds to an untimed frozen variable.  <a href="#ab14fda4289cf841d02cb57fc1c24a4ad">More...</a><br /></td></tr>
<tr class="separator:ab14fda4289cf841d02cb57fc1c24a4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e404e25132c827853e79dd149554efe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a6e404e25132c827853e79dd149554efe">BeEnc_is_index_untimed_input</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const int index)</td></tr>
<tr class="memdesc:a6e404e25132c827853e79dd149554efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether given index corresponds to an untimed input variable.  <a href="#a6e404e25132c827853e79dd149554efe">More...</a><br /></td></tr>
<tr class="separator:a6e404e25132c827853e79dd149554efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9233116d1baac85ac969130e3b9754d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#ac9233116d1baac85ac969130e3b9754d">BeEnc_is_index_untimed_next</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const int index)</td></tr>
<tr class="memdesc:ac9233116d1baac85ac969130e3b9754d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether given index corresponds to an untimed next state variable.  <a href="#ac9233116d1baac85ac969130e3b9754d">More...</a><br /></td></tr>
<tr class="separator:ac9233116d1baac85ac969130e3b9754d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef8e41a67c3054d6eadb930c7b75bc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a1ef8e41a67c3054d6eadb930c7b75bc8">BeEnc_is_var_index_valid</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, int var_index)</td></tr>
<tr class="memdesc:a1ef8e41a67c3054d6eadb930c7b75bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to check whether an iteration over a set of variables is over.  <a href="#a1ef8e41a67c3054d6eadb930c7b75bc8">More...</a><br /></td></tr>
<tr class="separator:a1ef8e41a67c3054d6eadb930c7b75bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fd9f493a18104703e7b72eb2bfda9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a29fd9f493a18104703e7b72eb2bfda9e">BeEnc_name_to_index</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const node_ptr name)</td></tr>
<tr class="memdesc:a29fd9f493a18104703e7b72eb2bfda9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the name of a be var, returns the untimed index that variable is allocated at.  <a href="#a29fd9f493a18104703e7b72eb2bfda9e">More...</a><br /></td></tr>
<tr class="separator:a29fd9f493a18104703e7b72eb2bfda9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd469515831d037fdb323bcaa701603"><td class="memItemLeft" align="right" valign="top"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#afbd469515831d037fdb323bcaa701603">BeEnc_name_to_timed</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const node_ptr name, const int time)</td></tr>
<tr class="memdesc:afbd469515831d037fdb323bcaa701603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the name of an untimed variable, returns the corresponding BE variable at the given time.  <a href="#afbd469515831d037fdb323bcaa701603">More...</a><br /></td></tr>
<tr class="separator:afbd469515831d037fdb323bcaa701603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c3e3fa0a0552d4a328c4dd04aa159a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a06c3e3fa0a0552d4a328c4dd04aa159a">BeEnc_name_to_untimed</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const node_ptr var_name)</td></tr>
<tr class="memdesc:a06c3e3fa0a0552d4a328c4dd04aa159a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the variable name, returns the corresponding BE untimed variable.  <a href="#a06c3e3fa0a0552d4a328c4dd04aa159a">More...</a><br /></td></tr>
<tr class="separator:a06c3e3fa0a0552d4a328c4dd04aa159a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081f988057cdbcc5beb620a1f06abcbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a081f988057cdbcc5beb620a1f06abcbc">BeEnc_shift_curr_to_next</a> (<a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> exp)</td></tr>
<tr class="memdesc:a081f988057cdbcc5beb620a1f06abcbc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Shifts</b> given <em>current</em> <b>expression at next time</b>  <a href="#a081f988057cdbcc5beb620a1f06abcbc">More...</a><br /></td></tr>
<tr class="separator:a081f988057cdbcc5beb620a1f06abcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9731edee708ea793636a448a5af8c1fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a9731edee708ea793636a448a5af8c1fa">BeEnc_untimed_expr_to_timed</a> (<a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> exp, const int time)</td></tr>
<tr class="memdesc:a9731edee708ea793636a448a5af8c1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Shifts</b> given <em>untimed</em> <b>expression at the given time</b>  <a href="#a9731edee708ea793636a448a5af8c1fa">More...</a><br /></td></tr>
<tr class="separator:a9731edee708ea793636a448a5af8c1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64500cc0b3689e21482358cc9502d087"><td class="memItemLeft" align="right" valign="top"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a64500cc0b3689e21482358cc9502d087">BeEnc_untimed_expr_to_times</a> (<a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> exp, const int ctime, const int ftime, const int itime, const int ntime)</td></tr>
<tr class="memdesc:a64500cc0b3689e21482358cc9502d087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an untimed expression, shifts current, frozen, input and next variables to given times.  <a href="#a64500cc0b3689e21482358cc9502d087">More...</a><br /></td></tr>
<tr class="separator:a64500cc0b3689e21482358cc9502d087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732f33616c81a0f1244e6a42e9403a9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a732f33616c81a0f1244e6a42e9403a9d">BeEnc_untimed_to_timed_and_interval</a> (<a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> exp, const int from, const int to)</td></tr>
<tr class="memdesc:a732f33616c81a0f1244e6a42e9403a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Makes an AND interval</b> of given expression using <b>range [<code>from</code>, <code>to</code>]</b>  <a href="#a732f33616c81a0f1244e6a42e9403a9d">More...</a><br /></td></tr>
<tr class="separator:a732f33616c81a0f1244e6a42e9403a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29309f8735238bfc9ee71698ba364e7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a29309f8735238bfc9ee71698ba364e7f">BeEnc_untimed_to_timed_or_interval</a> (<a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> exp, const int from, const int to)</td></tr>
<tr class="memdesc:a29309f8735238bfc9ee71698ba364e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Makes an OR interval</b> of given expression using <b>range [<code>from</code>, <code>to</code>]</b>  <a href="#a29309f8735238bfc9ee71698ba364e7f">More...</a><br /></td></tr>
<tr class="separator:a29309f8735238bfc9ee71698ba364e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a6acde669216682ae98dc0b9d38521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a99a6acde669216682ae98dc0b9d38521">BeEnc_var_curr_to_next</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> curr)</td></tr>
<tr class="memdesc:a99a6acde669216682ae98dc0b9d38521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an untimed current state variable to the corresponding untimed variable in the next state untimed block.  <a href="#a99a6acde669216682ae98dc0b9d38521">More...</a><br /></td></tr>
<tr class="separator:a99a6acde669216682ae98dc0b9d38521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115e5476aa598b99a57bb7baca205c7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a115e5476aa598b99a57bb7baca205c7e">BeEnc_var_next_to_curr</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> next)</td></tr>
<tr class="memdesc:a115e5476aa598b99a57bb7baca205c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an untimed next state variable to the corresponding untimed variable in the current state untimed block.  <a href="#a115e5476aa598b99a57bb7baca205c7e">More...</a><br /></td></tr>
<tr class="separator:a115e5476aa598b99a57bb7baca205c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5a113238d701dca72eeeca652bdde3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#aff5a113238d701dca72eeeca652bdde3">BeEnc_var_to_index</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> var)</td></tr>
<tr class="memdesc:aff5a113238d701dca72eeeca652bdde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a be variable, returns the corresponding be index.  <a href="#aff5a113238d701dca72eeeca652bdde3">More...</a><br /></td></tr>
<tr class="separator:aff5a113238d701dca72eeeca652bdde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e6159cff7f6d9be7c67b353cc88f7e"><td class="memItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#ae3e6159cff7f6d9be7c67b353cc88f7e">BeEnc_var_to_name</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> be_var)</td></tr>
<tr class="memdesc:ae3e6159cff7f6d9be7c67b353cc88f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a be variable, returns the correponding variable name.  <a href="#ae3e6159cff7f6d9be7c67b353cc88f7e">More...</a><br /></td></tr>
<tr class="separator:ae3e6159cff7f6d9be7c67b353cc88f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788689efc3eb4cd8dca8d20f04330ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a788689efc3eb4cd8dca8d20f04330ae7">BeEnc_var_to_timed</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> var, const int time)</td></tr>
<tr class="memdesc:a788689efc3eb4cd8dca8d20f04330ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an untimed variable, returns the corresponding BE variable at the given time.  <a href="#a788689efc3eb4cd8dca8d20f04330ae7">More...</a><br /></td></tr>
<tr class="separator:a788689efc3eb4cd8dca8d20f04330ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3d0c49b6bd607f768318658064866a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeEnc.html#a9f3d0c49b6bd607f768318658064866a">BeEnc_var_to_untimed</a> (const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> self, const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> var)</td></tr>
<tr class="memdesc:a9f3d0c49b6bd607f768318658064866a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a timed or untimed variable, returns the corresponding BE variable in the current state untimed block (current state, frozen and input vars).  <a href="#a9f3d0c49b6bd607f768318658064866a">More...</a><br /></td></tr>
<tr class="separator:a9f3d0c49b6bd607f768318658064866a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Private and protected interface of class '<a class="el" href="structBeEnc.html" title="Private and protected interface of class &#39;BeEnc&#39;. ">BeEnc</a>'. </p>
<p>Public interface of class '<a class="el" href="structBeEnc.html" title="Private and protected interface of class &#39;BeEnc&#39;. ">BeEnc</a>'.</p>
<dl class="section author"><dt>Author</dt><dd>Roberto Cavada This file can be included only by derived and friend classes</dd></dl>
<p><a class="el" href="structBeEnc.html" title="Private and protected interface of class &#39;BeEnc&#39;. ">BeEnc</a> class definition derived from class <a class="el" href="structBoolEncClient.html" title="Private and protected interface of class &#39;BoolEncClient&#39;. ">BoolEncClient</a>. This is the variables encoder for BMC. This class implements the boolean encoding for BMC, by providing variables groups and time-related functions. If the Boolean Expression (BE) layer provides actual access to variables, such as creation, shifting, substitution, expressions, etc., the <a class="el" href="structBeEnc.html" title="Private and protected interface of class &#39;BeEnc&#39;. ">BeEnc</a> class provides the right semantics for those variables.</p>
<p>The idea is to provide:</p><ol type="1">
<li>A structured layer for variables (encoding)</li>
<li>A set of functionalities to manage the variables.</li>
</ol>
<p>The encoding is internally organized to provide efficient operations on generic BEs, like variables shifting and substitutions, and conversions between symbolic variables to BE variables, BE indices, etc.</p>
<p>The class <a class="el" href="structBeEnc.html" title="Private and protected interface of class &#39;BeEnc&#39;. ">BeEnc</a> keeps and manages a set of encoded input, state and frozen variables that are committed as bunches within SymbLayers. The encoder keeps the relation between:</p><ul>
<li>The variables occurring within the committed layers and the untimed variables in terms of BE variables.</li>
<li>The untimed variables and the corresponding timed variables instantitated at determinated times.</li>
</ul>
<p>The management of the untimed and timed variables is allowed by the use of two separated levels, called the Physical Level and the Logical Level.</p>
<p>Physical Level</p>
<p>This level holds the actual BE variables, that are instantitated to represent both untimed and timed variables. The order the variables are organized must be considered as random and not directly controllable from outside the class <a class="el" href="structBeEnc.html" title="Private and protected interface of class &#39;BeEnc&#39;. ">BeEnc</a>, but it is the physical level that will be seen when the indices of BE variables are manipulated. Since there is not visible structure which BE variables within the physical level are organized with, the user cannot assume anything about the indices. For this reason, special iterators are provided to iterate over a set of variables (for example, the set of state untimed vars).</p>
<p>Logical Level</p>
<p>This level provides the necessary structure to the physical level, and it is visible only from within the class <a class="el" href="structBeEnc.html" title="Private and protected interface of class &#39;BeEnc&#39;. ">BeEnc</a>. Every operation that operates on BE variables will pass through the physical level at first, and then through the logical level. The class <a class="el" href="structBeEnc.html" title="Private and protected interface of class &#39;BeEnc&#39;. ">BeEnc</a> provides the necessary support to pass from one level to the other, but it is necessary to remember that the logical level is NOT visible and accessible from outside the class.</p>
<p>The logical level is splitted into two distinct parts: 1.1 Untimed variables block. 1.2 Timed variables block.</p>
<p>1.1 Untimed variables block </p><pre class="fragment">Keeps the set of untimed (logical) BE variables, such that
any (untimed) expression in term of BE will contain
references to variables located in this logical block. This
block is splitted into 4 sub-blocks, that group respectively
untimed current state variables, frozen variables, input
variables, and next state variables.

   : current state variable
 @ : frozen variable
 = : input variable
 # : next state variable

    --- -- -- ---  
        @@ == ### 
    --- -- -- ---  
    012 34 56 789     : BE variable logical index 
    143 52 87 690     : BE variable physical index

The picture shows an example of a logical untimed variables
block. The model contains 7 boolean variables (logical indices
from 0..6), where logical indices 0..2 refer the state
variables, indices 3 and 4 refer to frozen variables, and logical 
indices 5 and 6 refer the input
variables. The set of state variables is than replicated to
represent the next state variables, referred by logical indices
7..9 that constitutes the forth sub-block in the picture.

Notice that logical indices 0..9 refer a boolean variable
allocated by the BE layer, that does not distinguish between
state, input, frozen or next variables.  

Also notice that BE variables are physically allocated at
indices that can be completely different from the corresponding
indices within the logical level. The class BeEnc keeps the
relation between the logical and the physical level, and
viceversa.

    state     frozen  input      next      UNTIMED BLOCK
  |-------|   |---|   |---|   |-------|
  0   1   2   3   4   5   6   7   8   9    LOGICAL INDEX
 _______________________________________
| 1 | 4 | 3 | 5 | 2 | 8 | 7 | 6 | 9 | 0 |  LOG-&gt;PHY LEVEL MAP
 ---------------------------------------
| 9 | 0 | 4 | 2 | 1 | 3 | 7 | 6 | 5 | 8 |  PHY-&gt;LOG LEVEL MAP
 ---------------------------------------
</pre><p>1.2 Timed variables block </p><pre class="fragment">Following the untimed logical variables block, the timed
logical variables block holds the set of frozen, state and
input variables that are instantiated at a given time. A BE
expression instantiated at time t, will contain BE logical
variables that belong to this block.

Timed vars block is logically splitted into separate frames,
each of one corresponding to a given time t.  The structure
of each frame depends on the specific time t and on the
number of transitions the model has. When the problem
length k is 0, only frame from time 0 is allocated, and this
frame is constituted by only state and frozen variables. In
this condition the encoding structure (with untimed and
timed blocks) would be this:

              Untimed block             Timed block
  |--------------------------------| |---------------|
    current frozen  input    next     state 0  frozen 0
   -- -- --  -- --  -- --  -- -- --   -- -- --  -- -- 
  |  |  |  ||  |  ||  |  ||  |  |  | |  |  |  ||  |  |
   -- -- --  -- --  -- --  -- -- --   -- -- --  -- -- 
   00 01 02  03 04  05 06  07 08 09   10 11 12  13 14  : logical indices
   01 04 03  05 02  08 07  06 09 00   13 11 17  05 02  : physical indices


In the example BE logical indices 10..12 are allocated to
keep current state variables and logical indices 13..14 to
keep frozen variables at the initial state (time 0). Since
there are no transitions, input variables are not allocated
for this value of problem length k.

Frozen variables keep their values constant at all times. Thus
to encode a frozen variable at any time it is enough to have
just one (untimed) index. As result, new PHYSICAL indexes for
frozen variables are introduced only in the untimed block. To
enable more efficient time shifting, LOGICAL timed frames
include frozen variables, but the corresponding physical indexes
are the same as in the untimed block (see indexes 13..14 and
03..04, respectively, in the example). Thus just one BE variable
is created for a given frozen variable at any time.

When problem length k=1, the encoding becomes:

               Untimed block                   Timed block
</pre><p> |-----------------------------&mdash;| |------------------------------------&mdash;| current frozen input next state0 frozen0 input0 state1 frozen1 </p><hr/>
<p> | | | || | || | || | | | | | | || | || | || | | || | | </p><hr/>
<p> 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21</p>
<pre class="fragment">Here 00..21 are logical indices, and the corresponding
physical indices are not shown.

When k&gt;0 the timed block is a sequence of 
state-frozen (input-state-frozen)+ timed sub-blocks.
In the example above BE logical variables 15 and 16 have been
added to encode input variables at time 0 (since there is a
transition leading to time 1), and logical variables 17..19 and 20..21
have been added to encode state and frozen variables, respectively,
at time 1.

When a generic, untimed BE expressions E is instantiated at time
t (i.e. is shifted to time t), each current state variable
occurring in E will be replaced by the corresponding BE logical
variable in the timed sub-block t, as well any occurring input
variable. Each next state variable will be replaced by the
corresponding state variable located in the timed sub-block
(t+1). Frozen variables during shifting always stay untimed.

It is important to notice that the problem length k must be
strictly taken into account when shifting operations are
performed. In particular, as there are not transitions outgoing
the last state at time t=k, neither inputs nor next states can
be shifted at time t=k.

From the logics point of view, when t=k inputs variables at
time t do not exist at all (and the encoding directly maps
this idea).  Because of this, the logic value of input
variables at time t=k is false.

See the class interface for further details on the provided
features.
</pre><dl class="section see"><dt>See also</dt><dd>Base class <a class="el" href="structBoolEncClient.html" title="Private and protected interface of class &#39;BoolEncClient&#39;. ">BoolEncClient</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>Roberto Cavada </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000758">Todo:</a></b></dt><dd>: Missing description</dd></dl>
<p>Definition of the public accessor for class <a class="el" href="structBeEnc.html" title="Private and protected interface of class &#39;BeEnc&#39;. ">BeEnc</a> </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa6d397e35411091aa1898f182a5456da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d397e35411091aa1898f182a5456da">&#9670;&nbsp;</a></span>INHERITS_FROM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BeEnc::INHERITS_FROM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBoolEncClient.html">BoolEncClient</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="acbee72f794aae6298da384efe9c3c67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbee72f794aae6298da384efe9c3c67f">&#9670;&nbsp;</a></span>be_enc_deinit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void be_enc_deinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000763">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a9a27f69978611d5e7a95b9ab9296545f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a27f69978611d5e7a95b9ab9296545f">&#9670;&nbsp;</a></span>be_enc_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void be_enc_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a>&#160;</td>
          <td class="paramname"><em>symb_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoolEnc_8h.html#aa0e4c6a22ddb7ac20c5dc94254d859e9">BoolEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>bool_enc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000762">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a38861d1cef1f42e23defda0bf6cad491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38861d1cef1f42e23defda0bf6cad491">&#9670;&nbsp;</a></span>BeEnc_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a> BeEnc_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SymbTable_8h.html#ac665b53472111f817b3039654b894784">SymbTable_ptr</a>&#160;</td>
          <td class="paramname"><em>symb_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoolEnc_8h.html#aa0e4c6a22ddb7ac20c5dc94254d859e9">BoolEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>bool_enc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="structBeEnc.html" title="Private and protected interface of class &#39;BeEnc&#39;. ">BeEnc</a> class constructor. </p>
<p>AutomaticStart</p>
<p>The <a class="el" href="structBeEnc.html" title="Private and protected interface of class &#39;BeEnc&#39;. ">BeEnc</a> class constructor</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBeEnc.html#a4280fe23bc4ff1c55b8bbc33219d5f48" title="The BeEnc class destructor. ">BeEnc_destroy</a> </dd></dl>

</div>
</div>
<a id="a4280fe23bc4ff1c55b8bbc33219d5f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4280fe23bc4ff1c55b8bbc33219d5f48">&#9670;&nbsp;</a></span>BeEnc_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="object_8h.html#a6dd04ec3fff7c731cc71d6796699d902">VIRTUAL</a> void BeEnc_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="structBeEnc.html" title="Private and protected interface of class &#39;BeEnc&#39;. ">BeEnc</a> class destructor. </p>
<p>The <a class="el" href="structBeEnc.html" title="Private and protected interface of class &#39;BeEnc&#39;. ">BeEnc</a> class destructor</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBeEnc.html#a38861d1cef1f42e23defda0bf6cad491" title="The BeEnc class constructor. ">BeEnc_create</a></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000761">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="ab01954b50dcbbd584fb2336da59f9a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01954b50dcbbd584fb2336da59f9a5c">&#9670;&nbsp;</a></span>BeEnc_get_be_manager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="be_8h.html#afdc4ea4bbf871ce77b7404f9b60cb438">Be_Manager_ptr</a> BeEnc_get_be_manager </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Returns</b> the <code>Boolean Expressions manager</code> contained into the variable manager, to be used by any operation on BEs </p>
<p>Warning: do not delete the returned instance of <a class="el" href="structBe__Manager.html" title="The private interface of the Be_Manager class. ">Be_Manager</a> class, it belongs to self</p>
<p>None </p>

</div>
</div>
<a id="a6af943551a5cdaa162f49b9f33601890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af943551a5cdaa162f49b9f33601890">&#9670;&nbsp;</a></span>BeEnc_get_first_untimed_var_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc_get_first_untimed_var_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BeEnc_8h.html#a9a89d3f9dde7aa989c06e40c5d8827fc">BeVarType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this to begin an iteration between a given category of variables. </p>
<p>Use this method to begin an iteration between a given category of variables, for example the set of input variables, or the set of current and next state variables. The type is a bitwise OR combination of types. When the first index is obtained, following indices can be obtained by calling get_next_var_index, until is_var_index_valid returns false, that means that the iteration is over and must be given up.</p>
<p>None</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBeEnc.html#a2ff9e21a2031a780e0c2d542a6f1198b" title="Use to sequentially iterate over a selected category of variables. ">BeEnc_get_next_var_index</a>, <a class="el" href="structBeEnc.html#a2aea4ccc207a8cf6d84eab57234602f5" title="Use to randomly iterate over a selected category of variables within the untimed block. ">BeEnc_get_var_index_with_offset</a>, <a class="el" href="structBeEnc.html#a1ef8e41a67c3054d6eadb930c7b75bc8" title="Use to check whether an iteration over a set of variables is over. ">BeEnc_is_var_index_valid</a> </dd></dl>

</div>
</div>
<a id="ab3d979e60f64fe95dad218ed12654a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d979e60f64fe95dad218ed12654a39">&#9670;&nbsp;</a></span>BeEnc_get_frozen_vars_num()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc_get_frozen_vars_num </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>number of frozen variables currently handled by the encoder</code> </p>
<p>None </p>

</div>
</div>
<a id="aee705b317eda0a5baae2b1b4b9e504e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee705b317eda0a5baae2b1b4b9e504e5">&#9670;&nbsp;</a></span>BeEnc_get_input_vars_num()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc_get_input_vars_num </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>number of input variables currently handled by the encoder</code> </p>
<p>None </p>

</div>
</div>
<a id="a19b96f0369965312836f2370104be7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b96f0369965312836f2370104be7d6">&#9670;&nbsp;</a></span>BeEnc_get_max_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc_get_max_time </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Returns</b> the <code>maximum allocated time </code> </p>
<p>None </p>

</div>
</div>
<a id="a2ff9e21a2031a780e0c2d542a6f1198b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff9e21a2031a780e0c2d542a6f1198b">&#9670;&nbsp;</a></span>BeEnc_get_next_var_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc_get_next_var_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BeEnc_8h.html#a9a89d3f9dde7aa989c06e40c5d8827fc">BeVarType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use to sequentially iterate over a selected category of variables. </p>
<p>Use this method to obtain the index of the variable that follows the variable whose index is provided. If the iteration is over, an invalid index will be returned. Use the method is_var_index_valid to check the validity of the returned index.</p>
<p>None</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBeEnc.html#a6af943551a5cdaa162f49b9f33601890" title="Call this to begin an iteration between a given category of variables. ">BeEnc_get_first_untimed_var_index</a>, <a class="el" href="structBeEnc.html#a1ef8e41a67c3054d6eadb930c7b75bc8" title="Use to check whether an iteration over a set of variables is over. ">BeEnc_is_var_index_valid</a>, <a class="el" href="structBeEnc.html#a2aea4ccc207a8cf6d84eab57234602f5" title="Use to randomly iterate over a selected category of variables within the untimed block. ">BeEnc_get_var_index_with_offset</a> </dd></dl>

</div>
</div>
<a id="a7685a98b99de25d1cf2a1064116b8b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7685a98b99de25d1cf2a1064116b8b7e">&#9670;&nbsp;</a></span>BeEnc_get_state_vars_num()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc_get_state_vars_num </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>number of state variables currently handled by the encoder</code> </p>
<p>None </p>

</div>
</div>
<a id="a2aea4ccc207a8cf6d84eab57234602f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aea4ccc207a8cf6d84eab57234602f5">&#9670;&nbsp;</a></span>BeEnc_get_var_index_with_offset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc_get_var_index_with_offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BeEnc_8h.html#a9a89d3f9dde7aa989c06e40c5d8827fc">BeVarType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use to randomly iterate over a selected category of variables within the untimed block. </p>
<p>Use this method to obtain the index of the variable that follows the variable whose index is provided, after offset positions. If the iteration is over, an invalid index will be returned. Use the method is_var_index_valid to check the validity of the returned index.</p>
<p>None</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBeEnc.html#a6af943551a5cdaa162f49b9f33601890" title="Call this to begin an iteration between a given category of variables. ">BeEnc_get_first_untimed_var_index</a>, <a class="el" href="structBeEnc.html#a1ef8e41a67c3054d6eadb930c7b75bc8" title="Use to check whether an iteration over a set of variables is over. ">BeEnc_is_var_index_valid</a>, <a class="el" href="structBeEnc.html#a2ff9e21a2031a780e0c2d542a6f1198b" title="Use to sequentially iterate over a selected category of variables. ">BeEnc_get_next_var_index</a> </dd></dl>

</div>
</div>
<a id="a86186840eada2836f2a91d0f2216e2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86186840eada2836f2a91d0f2216e2e0">&#9670;&nbsp;</a></span>BeEnc_get_vars_num()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc_get_vars_num </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>number of input and state variables currently handled by the encoder</code> </p>
<p>None </p>

</div>
</div>
<a id="ab1d8506aacbde2f213b953e305c25961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d8506aacbde2f213b953e305c25961">&#9670;&nbsp;</a></span>BeEnc_index_to_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr BeEnc_index_to_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the index of a be var, returns the symbolic variable name. </p>
<p>Current implementation requires that the variable belongs to the untimed block</p>
<p>None </p>

</div>
</div>
<a id="a509b52f84e38ba5f8f50252b3d019b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509b52f84e38ba5f8f50252b3d019b3c">&#9670;&nbsp;</a></span>BeEnc_index_to_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc_index_to_time </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a state or input variable index this returns the time the variable is allocated. </p>
<p>The given state or input variable index must refer a timed variable.</p>
<p>If the given index refer to a frozen variable then BE_CURRENT_UNTIMED constant is returned (frozen variables are only allocated in the untimed block).</p>
<p>None </p>

</div>
</div>
<a id="ae5f3e3d38bd32a094b10cade94e3eec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f3e3d38bd32a094b10cade94e3eec9">&#9670;&nbsp;</a></span>BeEnc_index_to_timed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> BeEnc_index_to_timed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an untimed variable index, returns the corresponding BE variable at the given time. </p>
<p>This method expands the maximum allocated time if necessary.</p>
<p>WARNING: If the given index corresponds to an untimed next state var, the returned timed var will be instantitated at time+1</p>
<p>NOTE: Frozen variables are returned untimed as timed frozen variables are never instantiated.</p>
<p>None </p>

</div>
</div>
<a id="a4072671bde353e7df579f2ed29d5c354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4072671bde353e7df579f2ed29d5c354">&#9670;&nbsp;</a></span>BeEnc_index_to_untimed_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc_index_to_untimed_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a timed variable index, returns the corresponding untimed BE variable index. </p>
<p>Returned index will refer either to an untimed current state variable, an untimed frozen variable or an untimed input variable.</p>
<p>None </p>

</div>
</div>
<a id="a7f593d52704bb9441a5adb45fea3c68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f593d52704bb9441a5adb45fea3c68b">&#9670;&nbsp;</a></span>BeEnc_index_to_var()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> BeEnc_index_to_var </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a variable index, returns the corresponding be variable. </p>
<p>Current implementation requires that the variable index belongs to the untimed block</p>
<p>None </p>

</div>
</div>
<a id="aee6763d2e6f3c670bf37ea5104c971fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6763d2e6f3c670bf37ea5104c971fe">&#9670;&nbsp;</a></span>BeEnc_is_index_frozen_var()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BeEnc_is_index_frozen_var </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether given index corresponds to a frozen variable. </p>

</div>
</div>
<a id="a8f612ac70f1d27d9f8babf3825a57a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f612ac70f1d27d9f8babf3825a57a81">&#9670;&nbsp;</a></span>BeEnc_is_index_input_var()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BeEnc_is_index_input_var </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether given index corresponds to an input variable. </p>
<p>Input variables are in the input untimed block, or in timed input areas. </p>

</div>
</div>
<a id="af93d9945d783a73bd6c6942d01004f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93d9945d783a73bd6c6942d01004f92">&#9670;&nbsp;</a></span>BeEnc_is_index_state_var()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BeEnc_is_index_state_var </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether given index corresponds to a state variable. </p>
<p>Valid state variables are in current and next state blocks, and in timed state areas. </p>

</div>
</div>
<a id="a098f6651c9ef9e9d259df99666c2f2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098f6651c9ef9e9d259df99666c2f2ae">&#9670;&nbsp;</a></span>BeEnc_is_index_untimed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BeEnc_is_index_untimed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether given index corresponds to an untimed variable. </p>
<p>Note: frozen variables are always untimed. </p>

</div>
</div>
<a id="a55bc4dca1a151d3abbbf67f7750d25e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55bc4dca1a151d3abbbf67f7750d25e8">&#9670;&nbsp;</a></span>BeEnc_is_index_untimed_curr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BeEnc_is_index_untimed_curr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether given index corresponds to an untimed current state variable. </p>

</div>
</div>
<a id="a58dcb3b5991acec850d5f0d82d6e71e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58dcb3b5991acec850d5f0d82d6e71e4">&#9670;&nbsp;</a></span>BeEnc_is_index_untimed_curr_frozen_input()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BeEnc_is_index_untimed_curr_frozen_input </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether given index corresponds to an untimed current state variable, or an untimed frozen, or an untimed input variable. </p>

</div>
</div>
<a id="ab14fda4289cf841d02cb57fc1c24a4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14fda4289cf841d02cb57fc1c24a4ad">&#9670;&nbsp;</a></span>BeEnc_is_index_untimed_frozen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BeEnc_is_index_untimed_frozen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether given index corresponds to an untimed frozen variable. </p>
<p>Frozen variables are always untimed. So this function is exactly the same as BeEnc_is_index_frozen_var</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBeEnc.html#aee6763d2e6f3c670bf37ea5104c971fe" title="Checks whether given index corresponds to a frozen variable. ">BeEnc_is_index_frozen_var</a> </dd></dl>

</div>
</div>
<a id="a6e404e25132c827853e79dd149554efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e404e25132c827853e79dd149554efe">&#9670;&nbsp;</a></span>BeEnc_is_index_untimed_input()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BeEnc_is_index_untimed_input </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether given index corresponds to an untimed input variable. </p>

</div>
</div>
<a id="ac9233116d1baac85ac969130e3b9754d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9233116d1baac85ac969130e3b9754d">&#9670;&nbsp;</a></span>BeEnc_is_index_untimed_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BeEnc_is_index_untimed_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether given index corresponds to an untimed next state variable. </p>

</div>
</div>
<a id="a1ef8e41a67c3054d6eadb930c7b75bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef8e41a67c3054d6eadb930c7b75bc8">&#9670;&nbsp;</a></span>BeEnc_is_var_index_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> BeEnc_is_var_index_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use to check whether an iteration over a set of variables is over. </p>
<p>This method returns true whether the index returned by methods get_first_untimed_var_index, get_next_var_index and get_var_index_with_offset is valid and can be used later in the iteration. If false is returned, then the iteration is over.</p>
<p>None</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBeEnc.html#a6af943551a5cdaa162f49b9f33601890" title="Call this to begin an iteration between a given category of variables. ">BeEnc_get_first_untimed_var_index</a>, <a class="el" href="structBeEnc.html#a2ff9e21a2031a780e0c2d542a6f1198b" title="Use to sequentially iterate over a selected category of variables. ">BeEnc_get_next_var_index</a>, <a class="el" href="structBeEnc.html#a2aea4ccc207a8cf6d84eab57234602f5" title="Use to randomly iterate over a selected category of variables within the untimed block. ">BeEnc_get_var_index_with_offset</a> </dd></dl>

</div>
</div>
<a id="a29fd9f493a18104703e7b72eb2bfda9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29fd9f493a18104703e7b72eb2bfda9e">&#9670;&nbsp;</a></span>BeEnc_name_to_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc_name_to_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const node_ptr&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the name of a be var, returns the untimed index that variable is allocated at. </p>
<p>None </p>

</div>
</div>
<a id="afbd469515831d037fdb323bcaa701603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd469515831d037fdb323bcaa701603">&#9670;&nbsp;</a></span>BeEnc_name_to_timed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> BeEnc_name_to_timed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const node_ptr&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the name of an untimed variable, returns the corresponding BE variable at the given time. </p>
<p>This method expands the maximum allocated time if necessary.</p>
<p>WARNING: If the given variable name corresponds to an untimed next state var, the returned index will be instantitated at time+1</p>
<p>NOTE: Frozen variables are returned untimed as they are never allocated as timed variables.</p>
<p>None </p>

</div>
</div>
<a id="a06c3e3fa0a0552d4a328c4dd04aa159a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c3e3fa0a0552d4a328c4dd04aa159a">&#9670;&nbsp;</a></span>BeEnc_name_to_untimed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> BeEnc_name_to_untimed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const node_ptr&#160;</td>
          <td class="paramname"><em>var_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the variable name, returns the corresponding BE untimed variable. </p>
<p>None </p>

</div>
</div>
<a id="a081f988057cdbcc5beb620a1f06abcbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081f988057cdbcc5beb620a1f06abcbc">&#9670;&nbsp;</a></span>BeEnc_shift_curr_to_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> BeEnc_shift_curr_to_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Shifts</b> given <em>current</em> <b>expression at next time</b> </p>
<p>Warning: argument 'exp' must contain only untimed current state variables and untimed frozen variables, otherwise results will be unpredictible </p>

</div>
</div>
<a id="a9731edee708ea793636a448a5af8c1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9731edee708ea793636a448a5af8c1fa">&#9670;&nbsp;</a></span>BeEnc_untimed_expr_to_timed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> BeEnc_untimed_expr_to_timed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td>
          <td class="paramname"><em>exp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Shifts</b> given <em>untimed</em> <b>expression at the given time</b> </p>
<p>All next state variables will be shifted to time+1. Maximum time is extended if necessary. WARNING: argument 'exp' must contain only untimed variables, otherwise results will be unpredictible </p>

</div>
</div>
<a id="a64500cc0b3689e21482358cc9502d087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64500cc0b3689e21482358cc9502d087">&#9670;&nbsp;</a></span>BeEnc_untimed_expr_to_times()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> BeEnc_untimed_expr_to_times </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td>
          <td class="paramname"><em>exp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ctime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ftime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>itime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ntime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an untimed expression, shifts current, frozen, input and next variables to given times. </p>
<p>Shifts untimed current state vars to time ctime, frozen untimed vars to ftime, input untimed vars to itime, and untimed next state vars to ntime. </p>

</div>
</div>
<a id="a732f33616c81a0f1244e6a42e9403a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732f33616c81a0f1244e6a42e9403a9d">&#9670;&nbsp;</a></span>BeEnc_untimed_to_timed_and_interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> BeEnc_untimed_to_timed_and_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td>
          <td class="paramname"><em>exp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Makes an AND interval</b> of given expression using <b>range [<code>from</code>, <code>to</code>]</b> </p>
<p>Maximum time is extended if necessary. </p>

</div>
</div>
<a id="a29309f8735238bfc9ee71698ba364e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29309f8735238bfc9ee71698ba364e7f">&#9670;&nbsp;</a></span>BeEnc_untimed_to_timed_or_interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> BeEnc_untimed_to_timed_or_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td>
          <td class="paramname"><em>exp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Makes an OR interval</b> of given expression using <b>range [<code>from</code>, <code>to</code>]</b> </p>
<p>Maximum time is extended if necessary. </p>

</div>
</div>
<a id="a99a6acde669216682ae98dc0b9d38521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a6acde669216682ae98dc0b9d38521">&#9670;&nbsp;</a></span>BeEnc_var_curr_to_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> BeEnc_var_curr_to_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td>
          <td class="paramname"><em>curr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an untimed current state variable to the corresponding untimed variable in the next state untimed block. </p>
<p>Given variable must be a current state untimed variable</p>
<p>None </p>

</div>
</div>
<a id="a115e5476aa598b99a57bb7baca205c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115e5476aa598b99a57bb7baca205c7e">&#9670;&nbsp;</a></span>BeEnc_var_next_to_curr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> BeEnc_var_next_to_curr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an untimed next state variable to the corresponding untimed variable in the current state untimed block. </p>
<p>Given variable must be a next state untimed variable</p>
<p>None </p>

</div>
</div>
<a id="aff5a113238d701dca72eeeca652bdde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5a113238d701dca72eeeca652bdde3">&#9670;&nbsp;</a></span>BeEnc_var_to_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc_var_to_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a be variable, returns the corresponding be index. </p>
<p>None </p>

</div>
</div>
<a id="ae3e6159cff7f6d9be7c67b353cc88f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e6159cff7f6d9be7c67b353cc88f7e">&#9670;&nbsp;</a></span>BeEnc_var_to_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr BeEnc_var_to_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td>
          <td class="paramname"><em>be_var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a be variable, returns the correponding variable name. </p>
<p>Current implementation requires the given be variable to be untimed</p>
<p>None </p>

</div>
</div>
<a id="a788689efc3eb4cd8dca8d20f04330ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788689efc3eb4cd8dca8d20f04330ae7">&#9670;&nbsp;</a></span>BeEnc_var_to_timed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> BeEnc_var_to_timed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an untimed variable, returns the corresponding BE variable at the given time. </p>
<p>This method expands the maximum allocated time if necessary.</p>
<p>WARNING: If the given variable is an untimed next state, the returned index will be instantitated at time+1</p>
<p>NOTE: Frozen variables are returned untimed as they are always untimed.</p>
<p>None </p>

</div>
</div>
<a id="a9f3d0c49b6bd607f768318658064866a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3d0c49b6bd607f768318658064866a">&#9670;&nbsp;</a></span>BeEnc_var_to_untimed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a> BeEnc_var_to_untimed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BeEnc_8h.html#a8e1c1d3800b1c49a3016aa13642e396e">BeEnc_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="be_8h.html#a0f1936f6bcd20f529cb8ceec087221ed">be_ptr</a>&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a timed or untimed variable, returns the corresponding BE variable in the current state untimed block (current state, frozen and input vars). </p>
<p>None </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a3ea31de6e85b6a8d39bd5ab55f1913ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea31de6e85b6a8d39bd5ab55f1913ef">&#9670;&nbsp;</a></span>avail_phy_idx_queue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="NodeList_8h.html#a90a98001181a39cecf644325a5dddb3d">NodeList_ptr</a> BeEnc::avail_phy_idx_queue</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa993e664a7bb7281d9d4ff57c09fdb9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa993e664a7bb7281d9d4ff57c09fdb9d">&#9670;&nbsp;</a></span>be_mgr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="be_8h.html#afdc4ea4bbf871ce77b7404f9b60cb438">Be_Manager_ptr</a> BeEnc::be_mgr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8bcc0f9172cefc14f8b67172f1511ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcc0f9172cefc14f8b67172f1511ad3">&#9670;&nbsp;</a></span>frozen_vars_num</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc::frozen_vars_num</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab719d535cb22dd65b0b013d4aed8c643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab719d535cb22dd65b0b013d4aed8c643">&#9670;&nbsp;</a></span>grow_excess</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc::grow_excess</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ec9b276e981c7aac5979681114b7be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec9b276e981c7aac5979681114b7be8">&#9670;&nbsp;</a></span>index2name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr* BeEnc::index2name</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd73195145c853a880cc8a1927189152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd73195145c853a880cc8a1927189152">&#9670;&nbsp;</a></span>index2name_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc::index2name_size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0712408b72e413c9c02f4fac1f53cd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0712408b72e413c9c02f4fac1f53cd63">&#9670;&nbsp;</a></span>input_vars_num</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc::input_vars_num</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a734cf1e69a04ca2e2ca4cade58cada52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734cf1e69a04ca2e2ca4cade58cada52">&#9670;&nbsp;</a></span>log2phy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* BeEnc::log2phy</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56d0063753653681bae20b526a6f804e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d0063753653681bae20b526a6f804e">&#9670;&nbsp;</a></span>log_idx_capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc::log_idx_capacity</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada69025a5bdc414be7fb04bb112397a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada69025a5bdc414be7fb04bb112397a1">&#9670;&nbsp;</a></span>max_allocated_time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc::max_allocated_time</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a60e98002ee537d237ef588c22f24455d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e98002ee537d237ef588c22f24455d">&#9670;&nbsp;</a></span>max_used_phy_idx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc::max_used_phy_idx</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae715d92022f76aea235f123a871914b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae715d92022f76aea235f123a871914b1">&#9670;&nbsp;</a></span>name2be</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash_ptr BeEnc::name2be</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a018be417642c03edb96cb4ab43671ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018be417642c03edb96cb4ab43671ef4">&#9670;&nbsp;</a></span>phy2log</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* BeEnc::phy2log</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a230420578115e5323de8647d4203b2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230420578115e5323de8647d4203b2d0">&#9670;&nbsp;</a></span>phy_idx_capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc::phy_idx_capacity</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b6a69460cab4a5eb34f475f21a327bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6a69460cab4a5eb34f475f21a327bb">&#9670;&nbsp;</a></span>shift_hash</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__table.html">st_table</a>* BeEnc::shift_hash</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac049576dc55ea78d2f06cccf98addd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac049576dc55ea78d2f06cccf98addd44">&#9670;&nbsp;</a></span>state_vars_num</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc::state_vars_num</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a842dd04b003e8c4961c1aee5cb92ef5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842dd04b003e8c4961c1aee5cb92ef5f">&#9670;&nbsp;</a></span>subst_array</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* BeEnc::subst_array</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a355b299a2c88fb2f4c025e4154b43da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355b299a2c88fb2f4c025e4154b43da0">&#9670;&nbsp;</a></span>subst_array_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BeEnc::subst_array_size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>/root/research/NuSMV-2.6.0/NuSMV/code/nusmv/core/enc/be/<a class="el" href="BeEnc__private_8h_source.html">BeEnc_private.h</a></li>
<li>/root/research/NuSMV-2.6.0/NuSMV/code/nusmv/core/enc/be/<a class="el" href="BeEnc_8h_source.html">BeEnc.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 18 2022 22:26:36 for NuSMV Developers Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
