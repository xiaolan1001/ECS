<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NuSMV Developers Manual: TypeChecker Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NuSMV Developers Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">TypeChecker Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Public interface of class '<a class="el" href="structTypeChecker.html" title="Public interface of class &#39;TypeChecker&#39;. ">TypeChecker</a>'.  
 <a href="structTypeChecker.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="TypeChecker_8h_source.html">TypeChecker.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a6454bf5fa653ac71e0dd42eb60ddc1e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeChecker.html#a6454bf5fa653ac71e0dd42eb60ddc1e4">type_checker_check_expression</a> (<a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> self, node_ptr expression, node_ptr context)</td></tr>
<tr class="memdesc:a6454bf5fa653ac71e0dd42eb60ddc1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform type checking of an expression, and returns its type.  <a href="#a6454bf5fa653ac71e0dd42eb60ddc1e4">More...</a><br /></td></tr>
<tr class="separator:a6454bf5fa653ac71e0dd42eb60ddc1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18de98539b52d9b73a69f4e9d309a3d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeChecker.html#a18de98539b52d9b73a69f4e9d309a3d1">type_checker_enable_memoizing</a> (<a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> self, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> enabled)</td></tr>
<tr class="memdesc:a18de98539b52d9b73a69f4e9d309a3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables internal type memoizing.  <a href="#a18de98539b52d9b73a69f4e9d309a3d1">More...</a><br /></td></tr>
<tr class="separator:a18de98539b52d9b73a69f4e9d309a3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d5bbe170dc0ac375354005dd6b5742"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeChecker.html#ad0d5bbe170dc0ac375354005dd6b5742">type_checker_is_memoizing_enabled</a> (const <a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> self)</td></tr>
<tr class="memdesc:ad0d5bbe170dc0ac375354005dd6b5742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if memoizing is currently enabled, false otherwise.  <a href="#ad0d5bbe170dc0ac375354005dd6b5742">More...</a><br /></td></tr>
<tr class="separator:ad0d5bbe170dc0ac375354005dd6b5742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00aa607e1524259628ddee83bb544cd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeChecker.html#a00aa607e1524259628ddee83bb544cd8">type_checker_print_error_message</a> (<a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> self, node_ptr expr, <a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> is_error)</td></tr>
<tr class="memdesc:a00aa607e1524259628ddee83bb544cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints whther an error or a warning message, depending on the given parameter.  <a href="#a00aa607e1524259628ddee83bb544cd8">More...</a><br /></td></tr>
<tr class="separator:a00aa607e1524259628ddee83bb544cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9368d6ee8fd325c05e50527d45d4f3cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeChecker.html#a9368d6ee8fd325c05e50527d45d4f3cc">TypeChecker_check_constrains</a> (<a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> self, node_ptr init, node_ptr trans, node_ptr invar, node_ptr assign, node_ptr justice, node_ptr compassion)</td></tr>
<tr class="memdesc:a9368d6ee8fd325c05e50527d45d4f3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks all the module contrains are correctly typed.  <a href="#a9368d6ee8fd325c05e50527d45d4f3cc">More...</a><br /></td></tr>
<tr class="separator:a9368d6ee8fd325c05e50527d45d4f3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8b895e37c2006620361e3578fa64be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeChecker.html#a4a8b895e37c2006620361e3578fa64be">TypeChecker_check_layer</a> (<a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> self, <a class="el" href="SymbLayer_8h.html#aefd4aad33d23e220d585b5736d6aaa90">SymbLayer_ptr</a> layer)</td></tr>
<tr class="memdesc:a4a8b895e37c2006620361e3578fa64be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the types of variable decalarations in the layer are correctly formed. Also defines are checked to have some well-formed type.  <a href="#a4a8b895e37c2006620361e3578fa64be">More...</a><br /></td></tr>
<tr class="separator:a4a8b895e37c2006620361e3578fa64be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8577c8815a7ebc806c3c62d1a8c8b97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeChecker.html#ae8577c8815a7ebc806c3c62d1a8c8b97">TypeChecker_check_property</a> (<a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> self, struct Prop_TAG *property)</td></tr>
<tr class="memdesc:ae8577c8815a7ebc806c3c62d1a8c8b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the expression constituting the property is correctly typed.  <a href="#ae8577c8815a7ebc806c3c62d1a8c8b97">More...</a><br /></td></tr>
<tr class="separator:ae8577c8815a7ebc806c3c62d1a8c8b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8b482c0fbba40079f3a6c5a996fbfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeChecker.html#a6d8b482c0fbba40079f3a6c5a996fbfc">TypeChecker_check_symb_table</a> (<a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> self)</td></tr>
<tr class="memdesc:a6d8b482c0fbba40079f3a6c5a996fbfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls TypeChecker_check_layer over all the layers of the symbol table of self.  <a href="#a6d8b482c0fbba40079f3a6c5a996fbfc">More...</a><br /></td></tr>
<tr class="separator:a6d8b482c0fbba40079f3a6c5a996fbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df487b9fdcaca04779ca5a2a9ceeeb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeChecker.html#a8df487b9fdcaca04779ca5a2a9ceeeb2">TypeChecker_create</a> (struct SymbTable_TAG *symbolTable)</td></tr>
<tr class="memdesc:a8df487b9fdcaca04779ca5a2a9ceeeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structTypeChecker.html" title="Public interface of class &#39;TypeChecker&#39;. ">TypeChecker</a> class constructor.  <a href="#a8df487b9fdcaca04779ca5a2a9ceeeb2">More...</a><br /></td></tr>
<tr class="separator:a8df487b9fdcaca04779ca5a2a9ceeeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbba0858b635c7bc17f2b9db4e3ab076"><td class="memItemLeft" align="right" valign="top"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeChecker.html#afbba0858b635c7bc17f2b9db4e3ab076">TypeChecker_create_with_default_checkers</a> (struct SymbTable_TAG *symbolTable)</td></tr>
<tr class="memdesc:afbba0858b635c7bc17f2b9db4e3ab076"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structTypeChecker.html" title="Public interface of class &#39;TypeChecker&#39;. ">TypeChecker</a> class constructor, with registration of a set of default of checkers.  <a href="#afbba0858b635c7bc17f2b9db4e3ab076">More...</a><br /></td></tr>
<tr class="separator:afbba0858b635c7bc17f2b9db4e3ab076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343407b3a899e6594a7a8b96bfe3ff2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeChecker.html#a343407b3a899e6594a7a8b96bfe3ff2e">TypeChecker_destroy</a> (<a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> self)</td></tr>
<tr class="memdesc:a343407b3a899e6594a7a8b96bfe3ff2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structTypeChecker.html" title="Public interface of class &#39;TypeChecker&#39;. ">TypeChecker</a> class destructor.  <a href="#a343407b3a899e6594a7a8b96bfe3ff2e">More...</a><br /></td></tr>
<tr class="separator:a343407b3a899e6594a7a8b96bfe3ff2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c40ecb1756203b8f4b504038b335eb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeChecker.html#a7c40ecb1756203b8f4b504038b335eb6">TypeChecker_get_expression_type</a> (<a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> self, node_ptr expression, node_ptr context)</td></tr>
<tr class="memdesc:a7c40ecb1756203b8f4b504038b335eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of an expression.  <a href="#a7c40ecb1756203b8f4b504038b335eb6">More...</a><br /></td></tr>
<tr class="separator:a7c40ecb1756203b8f4b504038b335eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaff84a48d742dcaf8aeb8908b4a0b27"><td class="memItemLeft" align="right" valign="top">struct SymbTable_TAG *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeChecker.html#abaff84a48d742dcaf8aeb8908b4a0b27">TypeChecker_get_symb_table</a> (<a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> self)</td></tr>
<tr class="memdesc:abaff84a48d742dcaf8aeb8908b4a0b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the symbol table this type checker is associated to.  <a href="#abaff84a48d742dcaf8aeb8908b4a0b27">More...</a><br /></td></tr>
<tr class="separator:abaff84a48d742dcaf8aeb8908b4a0b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5faaec98b4a1275f69d59b92c24f789"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeChecker.html#ae5faaec98b4a1275f69d59b92c24f789">TypeChecker_is_expression_type_checked</a> (<a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> self, node_ptr expression, node_ptr context)</td></tr>
<tr class="memdesc:ae5faaec98b4a1275f69d59b92c24f789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff a given expression has been type checked.  <a href="#ae5faaec98b4a1275f69d59b92c24f789">More...</a><br /></td></tr>
<tr class="separator:ae5faaec98b4a1275f69d59b92c24f789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669e3f8f95fbaf46f8791ab0c293b0c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeChecker.html#a669e3f8f95fbaf46f8791ab0c293b0c6">TypeChecker_is_expression_wellformed</a> (<a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> self, node_ptr expression, node_ptr context)</td></tr>
<tr class="memdesc:a669e3f8f95fbaf46f8791ab0c293b0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method type checks an expression and returns true if an expression is wellformed with respect to the type system and false otherwise.  <a href="#a669e3f8f95fbaf46f8791ab0c293b0c6">More...</a><br /></td></tr>
<tr class="separator:a669e3f8f95fbaf46f8791ab0c293b0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cc9ee72b1c62be048e4e4f6f15ecc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeChecker.html#a07cc9ee72b1c62be048e4e4f6f15ecc9">TypeChecker_is_specification_wellformed</a> (<a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> self, node_ptr expression)</td></tr>
<tr class="memdesc:a07cc9ee72b1c62be048e4e4f6f15ecc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type checking of a specification.  <a href="#a07cc9ee72b1c62be048e4e4f6f15ecc9">More...</a><br /></td></tr>
<tr class="separator:a07cc9ee72b1c62be048e4e4f6f15ecc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2781036b82ec02f2b83f482fd69dc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeChecker.html#a7f2781036b82ec02f2b83f482fd69dc5">TypeChecker_is_type_wellformed</a> (<a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> self, <a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> type, node_ptr varName)</td></tr>
<tr class="memdesc:a7f2781036b82ec02f2b83f482fd69dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that a type is well formed.  <a href="#a7f2781036b82ec02f2b83f482fd69dc5">More...</a><br /></td></tr>
<tr class="separator:a7f2781036b82ec02f2b83f482fd69dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Public interface of class '<a class="el" href="structTypeChecker.html" title="Public interface of class &#39;TypeChecker&#39;. ">TypeChecker</a>'. </p>
<dl class="section author"><dt>Author</dt><dd>Andrei Tchaltsev This class contains the functions performing type checking. The class uses type_checking_violation_handler to deal with type system violations (which may result in an error or warning) in the input files. After the type checking is performed, use function TypeChecker_get_expression_type to get the type of a particular expression. After the type checking is performed it is possible to obtain the type of an expression. Only memory-sharing types (SymbTablePkg_..._type) are used, so you can compare pointers instead of the type's contents.</dd></dl>
<p>Definition of the public type for class <a class="el" href="structTypeChecker.html" title="Public interface of class &#39;TypeChecker&#39;. ">TypeChecker</a> </p>
</div><h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a6454bf5fa653ac71e0dd42eb60ddc1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6454bf5fa653ac71e0dd42eb60ddc1e4">&#9670;&nbsp;</a></span>type_checker_check_expression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> type_checker_check_expression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform type checking of an expression, and returns its type. </p>
<p>This function is the core of the expression type checking.</p>
<p>The expression may by unmodified (after compilation), flattened or flattened+expanded.</p>
<p>The return value is the type of the expression. If an expression violates the type system, the violation handler function is invoked and "error" type is returned (not NULL).</p>
<p>NB: As it is said in <a class="el" href="TypeChecker_8h.html">TypeChecker.h</a>, the expression type checking package uses only memory-shared types (SymbTablePkg_..._type).</p>
<p>NB: This function does not perform the type checking on already checked expressions (even if they were erroneous), but just returns their types (possibly error-type). This avoids multiple error and warning messages for the same subexpression.</p>
<dl class="section see"><dt>See also</dt><dd>type_checking_violation_handler </dd></dl>

</div>
</div>
<a id="a18de98539b52d9b73a69f4e9d309a3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18de98539b52d9b73a69f4e9d309a3d1">&#9670;&nbsp;</a></span>type_checker_enable_memoizing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void type_checker_enable_memoizing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables internal type memoizing. </p>
<p>This method is used by checkers to temporary disable internal type memoizing that associates each sub-expression to its type. This can be used to force an already checked formula to be re-checked. For example the PSL checker while checking 'forall' expressions requires the repeated formula to be checked as many times as the id has a range of possible values.</p>
<p>Important: memoizing is enabled by default and re-enabled every time the user calls the top level checking method. However, it is good behaviour for checkers to re-enable memoizing after disabling it </p>

</div>
</div>
<a id="ad0d5bbe170dc0ac375354005dd6b5742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d5bbe170dc0ac375354005dd6b5742">&#9670;&nbsp;</a></span>type_checker_is_memoizing_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> type_checker_is_memoizing_enabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if memoizing is currently enabled, false otherwise. </p>

</div>
</div>
<a id="a00aa607e1524259628ddee83bb544cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00aa607e1524259628ddee83bb544cd8">&#9670;&nbsp;</a></span>type_checker_print_error_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void type_checker_print_error_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>is_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints whther an error or a warning message, depending on the given parameter. </p>
<p>This private funciont is called by violation handler into checkers and self, to print a uniform message when type errors and warnings occur </p>

</div>
</div>
<a id="a9368d6ee8fd325c05e50527d45d4f3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9368d6ee8fd325c05e50527d45d4f3cc">&#9670;&nbsp;</a></span>TypeChecker_check_constrains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> TypeChecker_check_constrains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>invar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>assign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>justice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>compassion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks all the module contrains are correctly typed. </p>
<p>The module contrains are declarations INIT, INVAR, TRANS, ASSIGN, JUSTICE, COMPASSION.</p>
<p>The first parameter 'checker' is a type checker to perfrom checking. All the remaining parameters are the sets of expressions constituting the bodies of the corresponding high-level declarations. These expressions are created during compilation and then passed to this function unmodified, flattened or flattened+expanded. So this function is relatively specialised to deal with concrete data-structures created during compilation. For example, the expressions in the given sets are expected to be separated by CONS and AND.</p>
<p>NOTE: if an expression has been flattened, then info about line numbers mat not be accurate.</p>
<p>The type checker remebers all the checked expressions and their types, thus TypeChecker_get_expression_type uses memoizing to return the type of already checked expressions.</p>
<p>The parameter 'assign' is actually the 'procs' returned by Compile_FlattenHierarchy, which contains all the assignments.</p>
<p>If some of expressions violates the type system, the type checker's violation handler is invoked. See checkers into the checkers sub-package for more info.</p>
<p>Returns false if the module contrains violate the type system, and otherwise true is returned. </p>

</div>
</div>
<a id="a4a8b895e37c2006620361e3578fa64be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8b895e37c2006620361e3578fa64be">&#9670;&nbsp;</a></span>TypeChecker_check_layer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> TypeChecker_check_layer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SymbLayer_8h.html#aefd4aad33d23e220d585b5736d6aaa90">SymbLayer_ptr</a>&#160;</td>
          <td class="paramname"><em>layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that the types of variable decalarations in the layer are correctly formed. Also defines are checked to have some well-formed type. </p>
<p>Constrain: the input layer should belong to the symbol table the type checker is associated with.</p>
<p>The function iterates over all variables in the layer, and checks their type with function TypeChecker_is_type_wellformed.</p>
<p>The function also type checks the expressions provided in defines (also the generated "running" defines) have some type. NB for developers: This is done to allow the type checker to remember the type of these defines (and associated constants and variable <em>process_selector</em>). Without this list the evaluation phase will not know the type of these defines (if there were not explicitly used in the input text), since they can be implicitly used in ASSIGN(TRANS) contrains.</p>
<p>Returns true if all the types are correctly formed and the defines are correct, false otherwise.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTypeChecker.html#a7f2781036b82ec02f2b83f482fd69dc5" title="Checks that a type is well formed. ">TypeChecker_is_type_wellformed</a> </dd></dl>

</div>
</div>
<a id="ae8577c8815a7ebc806c3c62d1a8c8b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8577c8815a7ebc806c3c62d1a8c8b97">&#9670;&nbsp;</a></span>TypeChecker_check_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> TypeChecker_check_property </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct Prop_TAG *&#160;</td>
          <td class="paramname"><em>property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that the expression constituting the property is correctly typed. </p>
<p>If some of expressions violates the type system, the type checker's violation handler is invoked. See checkers into the checkers sub-package for more info.</p>
<p>The type checker remebers all the checked expressions and their types, thus TypeChecker_get_expression_type uses memoizing to return the type of already checked expressions.</p>
<p>If the property violates the type system, the false value is return, and true value otherwise. </p>

</div>
</div>
<a id="a6d8b482c0fbba40079f3a6c5a996fbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8b482c0fbba40079f3a6c5a996fbfc">&#9670;&nbsp;</a></span>TypeChecker_check_symb_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> TypeChecker_check_symb_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls TypeChecker_check_layer over all the layers of the symbol table of self. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTypeChecker.html#a4a8b895e37c2006620361e3578fa64be" title="Checks that the types of variable decalarations in the layer are correctly formed. Also defines are checked to have some well-formed type. ">TypeChecker_check_layer</a> </dd></dl>

</div>
</div>
<a id="a8df487b9fdcaca04779ca5a2a9ceeeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df487b9fdcaca04779ca5a2a9ceeeb2">&#9670;&nbsp;</a></span>TypeChecker_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> TypeChecker_create </td>
          <td>(</td>
          <td class="paramtype">struct SymbTable_TAG *&#160;</td>
          <td class="paramname"><em>symbolTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structTypeChecker.html" title="Public interface of class &#39;TypeChecker&#39;. ">TypeChecker</a> class constructor. </p>
<p>AutomaticStart</p>
<p><a class="el" href="structTypeChecker.html" title="Public interface of class &#39;TypeChecker&#39;. ">TypeChecker</a> class constructor. The 'symbolTable' is a symbol table to look for the type of found identifiers</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTypeChecker.html#a343407b3a899e6594a7a8b96bfe3ff2e" title="The TypeChecker class destructor. ">TypeChecker_destroy</a> </dd></dl>

</div>
</div>
<a id="afbba0858b635c7bc17f2b9db4e3ab076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbba0858b635c7bc17f2b9db4e3ab076">&#9670;&nbsp;</a></span>TypeChecker_create_with_default_checkers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a> TypeChecker_create_with_default_checkers </td>
          <td>(</td>
          <td class="paramtype">struct SymbTable_TAG *&#160;</td>
          <td class="paramname"><em>symbolTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structTypeChecker.html" title="Public interface of class &#39;TypeChecker&#39;. ">TypeChecker</a> class constructor, with registration of a set of default of checkers. </p>
<p><a class="el" href="structTypeChecker.html" title="Public interface of class &#39;TypeChecker&#39;. ">TypeChecker</a> class constructor, with registration of a set of default of checkers. The 'symbolTable' is a symbol table to look for the type of found identifiers</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTypeChecker.html#a343407b3a899e6594a7a8b96bfe3ff2e" title="The TypeChecker class destructor. ">TypeChecker_destroy</a> </dd></dl>

</div>
</div>
<a id="a343407b3a899e6594a7a8b96bfe3ff2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343407b3a899e6594a7a8b96bfe3ff2e">&#9670;&nbsp;</a></span>TypeChecker_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TypeChecker_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="structTypeChecker.html" title="Public interface of class &#39;TypeChecker&#39;. ">TypeChecker</a> class destructor. </p>
<p>The <a class="el" href="structTypeChecker.html" title="Public interface of class &#39;TypeChecker&#39;. ">TypeChecker</a> class destructor</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTypeChecker.html#a8df487b9fdcaca04779ca5a2a9ceeeb2" title="TypeChecker class constructor. ">TypeChecker_create</a> </dd></dl>

</div>
</div>
<a id="a7c40ecb1756203b8f4b504038b335eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c40ecb1756203b8f4b504038b335eb6">&#9670;&nbsp;</a></span>TypeChecker_get_expression_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a> TypeChecker_get_expression_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of an expression. </p>
<p>If the expression has been already type-checked by the same type-checker, then the type of an expression is returned. Otherwise, the expression is type checked and its type is returned.</p>
<p>The parameter 'context' indicates the context where expression has been checked. It should be exactly the same as during type checking. For outside user this parameter is usually Nil. NOTE: The returned type may be error-type indicating that the expression violates the type system. NOTE: all returned types are the memory-sharing types (see SymbTablePkg_..._type). So you can compare pointers instead of the type's contents.</p>
<p>TypeChecker_is_expression_wellformed, TypeChecker_is_specification_wellformed </p>

</div>
</div>
<a id="abaff84a48d742dcaf8aeb8908b4a0b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaff84a48d742dcaf8aeb8908b4a0b27">&#9670;&nbsp;</a></span>TypeChecker_get_symb_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct SymbTable_TAG * TypeChecker_get_symb_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the symbol table this type checker is associated to. </p>
<p>During its lifetime every type checker can deal only with one symbol table instance (because type checker caches the checked expressions and their types). The symbol table is given to the type checker during construction, and this function returns this symbol table.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTypeChecker.html#a8df487b9fdcaca04779ca5a2a9ceeeb2" title="TypeChecker class constructor. ">TypeChecker_create</a> </dd></dl>

</div>
</div>
<a id="ae5faaec98b4a1275f69d59b92c24f789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5faaec98b4a1275f69d59b92c24f789">&#9670;&nbsp;</a></span>TypeChecker_is_expression_type_checked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> TypeChecker_is_expression_type_checked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff a given expression has been type checked. </p>
<p>If this function returns true then TypeChecker_get_expression_type will return the cached type without performing the actual type checking.</p>
<p>The parameter 'context' indicates the context where expression has been checked. It should be exactly the same as during type checking. For outside user this parameter is usually Nil.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTypeChecker.html#a7c40ecb1756203b8f4b504038b335eb6" title="Returns the type of an expression. ">TypeChecker_get_expression_type</a> </dd></dl>

</div>
</div>
<a id="a669e3f8f95fbaf46f8791ab0c293b0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669e3f8f95fbaf46f8791ab0c293b0c6">&#9670;&nbsp;</a></span>TypeChecker_is_expression_wellformed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> TypeChecker_is_expression_wellformed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The method type checks an expression and returns true if an expression is wellformed with respect to the type system and false otherwise. </p>
<p>The main purpose of this function is to be invoked on temporarily created expressions before they are evaluated to ADD or BDD. This function may not be useful for expressions read from files (such as bodies of INVAR, SPEC, etc) since they go through flattening in the compilation package and type-checked there.</p>
<p>NOTE: an expression may be unmodified (after parsing and compilation), flattened or flattened+expanded. The expressions and their types are remembered by the type checker and the expressions types can be obtained with TypeChecker_get_expression_type.</p>
<p>NOTE: memoizing is enabled before checking the expression.</p>
<p>See checkers into the checkers sub-package for more info.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTypeChecker.html#a6454bf5fa653ac71e0dd42eb60ddc1e4" title="Perform type checking of an expression, and returns its type. ">type_checker_check_expression</a> </dd></dl>

</div>
</div>
<a id="a07cc9ee72b1c62be048e4e4f6f15ecc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cc9ee72b1c62be048e4e4f6f15ecc9">&#9670;&nbsp;</a></span>TypeChecker_is_specification_wellformed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> TypeChecker_is_specification_wellformed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>expression</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs type checking of a specification. </p>
<p>A specification is a usual (i.e. able to have a type) expression wrapped into a node with a specification tag such as INIT, INVAR, SPEC, COMPASSION, etc. There are two special case: ASSIGN can contains a list of EQDEF statements, and COMPUTE can contains MIN and MAX statement.</p>
<p>The returned value is true if no violations of the type system are detected, and false otherwise.</p>
<p>NOTE: the expression may be unmodified (after compilation), flattened or flattened+expanded. The expressions and their types are remembered by the type checker and the expressions types can be obtained with TypeChecker_get_expression_type.</p>
<p>NOTE: memizing is enbaled before checking the specification</p>
<p>See checkers into the checkers sub-package for more info.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTypeChecker.html#a6454bf5fa653ac71e0dd42eb60ddc1e4" title="Perform type checking of an expression, and returns its type. ">type_checker_check_expression</a> </dd></dl>

</div>
</div>
<a id="a7f2781036b82ec02f2b83f482fd69dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2781036b82ec02f2b83f482fd69dc5">&#9670;&nbsp;</a></span>TypeChecker_is_type_wellformed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> TypeChecker_is_type_wellformed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="TypeChecker_8h.html#aa4538dcf4cf023efe118d200e87d3115">TypeChecker_ptr</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SymbType_8h.html#a98fd95440c428ccdc1ac0181dc140c47">SymbType_ptr</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>varName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that a type is well formed. </p>
<p>This function is used to check the well-formedness of a type from a symbol table. This type should have properly created body, in particular, bodies should have correct line info.</p>
<p>The constrains on a type are:</p><ol type="1">
<li>word type: the width should be a NUMBER and have positive value. The width should not be greater than implemenetation limit <a class="el" href="WordNumber_8h.html#ad3256ce53aeb063b203d73c4cea9431f" title="The functions returns the maximal width a Word constant can have. This is implemenatation-dependent l...">WordNumber_max_width()</a> bit (since we do not use arbitrary-precision arithmetic and ADD structores will be too big otherwise)</li>
<li>enum type: there should be no duplicate values.</li>
</ol>
<p>The third parameter is the variable name that type is to be checked. The variable name is used just to output proper message in the case of a type violation.</p>
<p>In the case of a type violation the violation handler obtain an expression CONS with variable name as left child and the body of the type as the right child.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTypeChecker.html#a6454bf5fa653ac71e0dd42eb60ddc1e4" title="Perform type checking of an expression, and returns its type. ">type_checker_check_expression</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>/root/research/NuSMV-2.6.0/NuSMV/code/nusmv/core/compile/type_checking/<a class="el" href="TypeChecker_8h_source.html">TypeChecker.h</a></li>
<li>/root/research/NuSMV-2.6.0/NuSMV/code/nusmv/core/compile/type_checking/<a class="el" href="TypeChecker__private_8h_source.html">TypeChecker_private.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 18 2022 22:26:37 for NuSMV Developers Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
